<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDK新特性上</title>
      <link href="/2023/03/13/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/03/13/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第18章-JDK8-17新特性（上）"><a href="#第18章-JDK8-17新特性（上）" class="headerlink" title="第18章_JDK8-17新特性（上）"></a>第18章_JDK8-17新特性（上）</h1><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/../images/%E7%AC%AC3%E9%98%B6%E6%AE%B5%EF%BC%9AJava%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8-%E7%AC%AC18%E7%AB%A0.png" alt="第3阶段：Java高级应用-第18章"></p><hr><h2 id="1-Java版本迭代概述"><a href="#1-Java版本迭代概述" class="headerlink" title="1. Java版本迭代概述"></a>1. Java版本迭代概述</h2><h3 id="1-1-发布特点（小步快跑，快速迭代）"><a href="#1-1-发布特点（小步快跑，快速迭代）" class="headerlink" title="1.1 发布特点（小步快跑，快速迭代）"></a>1.1 发布特点（小步快跑，快速迭代）</h3><table><thead><tr><th align="center">发行版本</th><th align="center">发行时间</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Java 1.0</td><td align="center">1996.01.23</td><td align="center">Sun公司发布了Java的第一个开发工具包</td></tr><tr><td align="center">Java 5.0</td><td align="center">2004.09.30</td><td align="center">①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME</td></tr><tr><td align="center">Java 8.0</td><td align="center">2014.03.18</td><td align="center">此版本是继Java 5.0以来变化最大的版本。是长期支持版本（<code>LTS</code>）</td></tr><tr><td align="center">Java 9.0</td><td align="center">2017.09.22</td><td align="center"><strong>此版本开始，每半年更新一次</strong></td></tr><tr><td align="center">Java 10.0</td><td align="center">2018.03.21</td><td align="center"></td></tr><tr><td align="center">Java 11.0</td><td align="center">2018.09.25</td><td align="center">JDK安装包取消独立JRE安装包，是长期支持版本（<code>LTS</code>）</td></tr><tr><td align="center">Java 12.0</td><td align="center">2019.03.19</td><td align="center"></td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center"></td></tr><tr><td align="center">Java17.0</td><td align="center">2021.09</td><td align="center">发布Java 17.0，版本号也称为21.9，是长期支持版本（<code>LTS</code>）</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center"></td></tr><tr><td align="center">Java19.0</td><td align="center">2022.09</td><td align="center">发布Java19.0，版本号也称为22.9。</td></tr></tbody></table><p>从Java 9 这个版本开始，Java 的计划发布周期是 <code>6个月</code>。</p><p>这意味着Java的更新从传统的以<code>特性驱动</code>的发布周期，转变为以<code>时间驱动</code>的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。</p><p>针对企业客户的需求，Oracle 将以<code>三年</code>为周期发布长期支持版本（long term support）。</p><p>Oracle 的官方观点认为：<strong>与 Java 7-&gt;8-&gt;9 相比，Java 9-&gt;10-&gt;11的升级和 8-&gt;8u20-&gt;8u40 更相似。</strong></p><p>新模式下的 Java 版本发布都会包含许多变更，包括<code>语言变更</code>和 <code>JVM 变更</code>，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 <code>API被删除</code>（这在 Java 8 之前没有发生过）。</p><p>目前看这种发布策略是非常成功的，<strong>解开了 Java&#x2F;JVM 演进的许多枷锁，至关重要的是，OpenJDK 的权力中心，正在转移到开发社区和开发者手中。</strong>在新的模式中，既可以利用 LTS 满足企业长期可靠支持的需求，也可以满足各种开发者对于新特性迭代的诉求。因为用 2-3 年的最小间隔粒度来试验一个特性，基本是不现实的。</p><h3 id="1-2-名词解释"><a href="#1-2-名词解释" class="headerlink" title="1.2 名词解释"></a>1.2 名词解释</h3><h4 id="名词解释：Oracle-JDK和Open-JDK"><a href="#名词解释：Oracle-JDK和Open-JDK" class="headerlink" title="名词解释：Oracle JDK和Open JDK"></a>名词解释：Oracle JDK和Open JDK</h4><p>这两个JDK最大不同就是许可证不一样。<strong>但是对于个人用户来讲，没区别。</strong></p><table><thead><tr><th></th><th>Oracle JDK</th><th>Open JDK</th></tr></thead><tbody><tr><td>来源</td><td>Oracle团队维护</td><td>Oracle和Open Java社区</td></tr><tr><td>授权协议</td><td>Java 17及更高版本 Oracle Java SE 许可证<br>Java16及更低版本甲骨文免费条款和条件 （NFTC） 许可协议</td><td>GPL v2许可证</td></tr><tr><td>关系</td><td>由Open JDK构建，增加了少许内容</td><td></td></tr><tr><td>是否收费</td><td>2021年9月起Java17及更高版本所有用户免费。 16及更低版本，个人用户、开发用户免费。</td><td>2017年9月起，所有版本免费</td></tr><tr><td>对语法的支持</td><td>一致</td><td>一致</td></tr></tbody></table><h4 id="名词解释：JEP"><a href="#名词解释：JEP" class="headerlink" title="名词解释：JEP"></a>名词解释：JEP</h4><p>JEP(JDK Enhancement Proposals)：jdk 改进提案，每当需要有新的设想时候，JEP可以提出非正式的规范(specification)，被正式认可的JEP正式写进JDK的发展路线图并分配版本号。</p><h4 id="名词解释：LTS"><a href="#名词解释：LTS" class="headerlink" title="名词解释：LTS"></a>名词解释：LTS</h4><p>LTS（Long-term Support）即长期支持。Oracle官网提供了对Oracle JDK个别版本的长期支持，即使发发行了新版本，比如目前最新的JDK19，在结束日期前，LTS版本都会被长期支持。（出了bug，会被修复，非LTS则不会再有补丁发布）所以，一定要选一个LTS版本，不然出了漏洞没人修复了。</p><table><thead><tr><th>版本</th><th>开始日期</th><th>结束日期</th><th>延期结束日期</th></tr></thead><tbody><tr><td>7（LTS）</td><td>2011年7月</td><td>2019年7月</td><td>2022年7月</td></tr><tr><td>8（LTS）</td><td>2014年3月</td><td>2022年3月</td><td>2030年12月</td></tr><tr><td>11（LTS）</td><td>2018年9月</td><td>2023年9月</td><td>2026年9月</td></tr><tr><td>17（LTS）</td><td>2021年9月</td><td>2026年9月</td><td>2029年9月</td></tr><tr><td>21（LTS）</td><td>2023年9月</td><td>2028年9月</td><td>2031年9月</td></tr></tbody></table><p>如果要选择Oracle JDK，目前可选的LTS版本为8、11、17三个。</p><h3 id="1-3-各版本支持时间路线图"><a href="#1-3-各版本支持时间路线图" class="headerlink" title="1.3 各版本支持时间路线图"></a>1.3 各版本支持时间路线图</h3><p><img src="/../images/4428b288361296048.png" alt="4428b288361296048"></p><h3 id="1-4-各版本介绍"><a href="#1-4-各版本介绍" class="headerlink" title="1.4 各版本介绍"></a>1.4 各版本介绍</h3><p><img src="/../images/jdkxintexing.jpg" alt="jdkxintexing"></p><h4 id="jdk-9"><a href="#jdk-9" class="headerlink" title="jdk 9"></a>jdk 9</h4><p>Java 9 提供了<code>超过150项</code>新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。</p><p>特性太多，查看链接：</p><p><a href="https://openjdk.java.net/projects/jdk9/">https://openjdk.java.net/projects/jdk9/</a></p><h4 id="jdk-10"><a href="#jdk-10" class="headerlink" title="jdk 10"></a>jdk 10</h4><p><a href="https://openjdk.java.net/projects/jdk/10/">https://openjdk.java.net/projects/jdk/10/</a></p><blockquote><p>286: <a href="http://openjdk.java.net/jeps/286">Local-Variable Type Inference</a> 局部变量类型推断<br> 296: <a href="http://openjdk.java.net/jeps/296">Consolidate the JDK Forest into a Single Repository</a> JDK库的合并<br> 304: <a href="http://openjdk.java.net/jeps/304">Garbage-Collector Interface</a> 统一的垃圾回收接口<br> 307: <a href="http://openjdk.java.net/jeps/307">Parallel Full GC for G1</a> 为G1提供并行的Full GC<br> 310: <a href="http://openjdk.java.net/jeps/310">Application Class-Data Sharing</a> 应用程序类数据（AppCDS）共享<br> 312: <a href="http://openjdk.java.net/jeps/312">Thread-Local Handshakes</a> ThreadLocal握手交互<br> 313: <a href="http://openjdk.java.net/jeps/313">Remove the Native-Header Generation Tool (javah)</a> 移除JDK中附带的javah工具<br> 314: <a href="http://openjdk.java.net/jeps/314">Additional Unicode Language-Tag Extensions</a> 使用附加的Unicode语言标记扩展<br> 316: <a href="http://openjdk.java.net/jeps/316">Heap Allocation on Alternative Memory Devices</a> 能将堆内存占用分配给用户指定的备用内存设备<br> 317: <a href="http://openjdk.java.net/jeps/317">Experimental Java-Based JIT Compiler</a> 使用Graal基于Java的编译器</p><p>319: <a href="http://openjdk.java.net/jeps/319">Root Certificates</a> 根证书<br> 322: <a href="http://openjdk.java.net/jeps/322">Time-Based Release Versioning</a> 基于时间定于的发布版本</p></blockquote><h4 id="jdk-11"><a href="#jdk-11" class="headerlink" title="jdk 11"></a>jdk 11</h4><p><a href="https://openjdk.java.net/projects/jdk/11/">https://openjdk.java.net/projects/jdk/11/</a></p><blockquote><p>181: <a href="https://openjdk.java.net/jeps/181">Nest-Based Access Control</a>  基于嵌套的访问控制<br>309: <a href="https://openjdk.java.net/jeps/309">Dynamic Class-File Constants</a> 动态类文件常量<br>315: <a href="https://openjdk.java.net/jeps/315">Improve Aarch64 Intrinsics</a> 改进 Aarch64 Intrinsics<br>318: <a href="https://openjdk.java.net/jeps/318">Epsilon: A No-Op Garbage Collector</a> Epsilon — 一个No-Op（无操作）的垃圾收集器<br>320: <a href="https://openjdk.java.net/jeps/320">Remove the Java EE and CORBA Modules</a> 删除 Java EE 和 CORBA 模块<br>321: <a href="https://openjdk.java.net/jeps/321">HTTP Client (Standard)</a>  HTTPClient API<br>323: <a href="https://openjdk.java.net/jeps/323">Local-Variable Syntax for Lambda Parameters</a>  用于 Lambda 参数的局部变量语法<br>324: <a href="https://openjdk.java.net/jeps/324">Key Agreement with Curve25519 and Curve448</a> Curve25519 和 Curve448 算法的密钥协议<br>327: <a href="https://openjdk.java.net/jeps/327">Unicode 10</a><br>328: <a href="https://openjdk.java.net/jeps/328">Flight Recorder</a> 飞行记录仪<br>329: <a href="https://openjdk.java.net/jeps/329">ChaCha20 and Poly1305 Cryptographic Algorithms</a> ChaCha20 和 Poly1305 加密算法<br>330: <a href="https://openjdk.java.net/jeps/330">Launch Single-File Source-Code Programs</a> 启动单一文件的源代码程序<br>331: <a href="https://openjdk.java.net/jeps/331">Low-Overhead Heap Profiling</a> 低开销的 Heap Profiling<br>332: <a href="https://openjdk.java.net/jeps/332">Transport Layer Security (TLS) 1.3</a> 支持 TLS 1.3<br>333: <a href="https://openjdk.java.net/jeps/333">ZGC: A Scalable Low-Latency Garbage Collector<br>   (Experimental)</a> 可伸缩低延迟垃圾收集器<br>335: <a href="https://openjdk.java.net/jeps/335">Deprecate the Nashorn JavaScript Engine</a> 弃用 Nashorn JavaScript 引擎<br>336: <a href="https://openjdk.java.net/jeps/336">Deprecate the Pack200 Tools and API</a>  弃用 Pack200 工具和 API</p></blockquote><h4 id="jdk-12"><a href="#jdk-12" class="headerlink" title="jdk 12"></a>jdk 12</h4><p><a href="https://openjdk.java.net/projects/jdk/12/">https://openjdk.java.net/projects/jdk/12/</a></p><blockquote><p>189：<a href="https://openjdk.java.net/jeps/189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a> 低暂停时间的GC<br>230: <a href="https://openjdk.java.net/jeps/230">Microbenchmark Suite</a> 微基准测试套件<br>325: <a href="https://openjdk.java.net/jeps/325">Switch Expressions (Preview)</a> switch表达式<br>334: <a href="https://openjdk.java.net/jeps/334">JVM Constants API </a> JVM常量API<br>340: <a href="https://openjdk.java.net/jeps/340">One AArch64 Port, Not Two</a> 只保留一个AArch64实现<br>341: <a href="https://openjdk.java.net/jeps/341">Default CDS Archives</a> 默认类数据共享归档文件<br>344: <a href="https://openjdk.java.net/jeps/344">Abortable Mixed Collections for G1</a> 可中止的G1 Mixed GC<br>346: <a href="https://openjdk.java.net/jeps/346">Promptly Return Unused Committed Memory from G1</a> G1及时返回未使用的已分配内存</p></blockquote><h4 id="jdk-13"><a href="#jdk-13" class="headerlink" title="jdk 13"></a>jdk 13</h4><p><a href="https://openjdk.java.net/projects/jdk/13/">https://openjdk.java.net/projects/jdk/13/</a></p><blockquote><p>350: <a href="https://openjdk.java.net/jeps/350">Dynamic CDS Archives</a> 动态CDS档案<br>351: <a href="https://openjdk.java.net/jeps/351">ZGC: Uncommit Unused Memory</a> ZGC:取消使用未使用的内存<br>353: <a href="https://openjdk.java.net/jeps/353">Reimplement the Legacy Socket API</a> 重新实现旧版套接字API<br>354: <a href="https://openjdk.java.net/jeps/354">Switch Expressions (Preview)</a> switch表达式（预览）<br>355: <a href="https://openjdk.java.net/jeps/355">Text Blocks (Preview)</a> 文本块（预览）</p></blockquote><h4 id="jdk-14"><a href="#jdk-14" class="headerlink" title="jdk 14"></a>jdk 14</h4><p><a href="https://openjdk.java.net/projects/jdk/14/">https://openjdk.java.net/projects/jdk/14/</a></p><blockquote><p>305: <a href="https://openjdk.java.net/jeps/305">Pattern Matching for instanceof (Preview)</a> instanceof的模式匹配<br>343: <a href="https://openjdk.java.net/jeps/343">Packaging Tool (Incubator)</a> 打包工具<br>345: <a href="https://openjdk.java.net/jeps/345">NUMA-Aware Memory Allocation for G1</a> G1的NUMA-Aware内存分配<br>349: <a href="https://openjdk.java.net/jeps/349">JFR Event Streaming</a> JFR事件流<br>352: <a href="https://openjdk.java.net/jeps/352">Non-Volatile Mapped Byte Buffers</a> 非易失性映射字节缓冲区<br>358: <a href="https://openjdk.java.net/jeps/358">Helpful NullPointerExceptions</a> 实用的NullPointerExceptions<br>359: <a href="https://openjdk.java.net/jeps/359">Records (Preview)</a><br>361: <a href="https://openjdk.java.net/jeps/361">Switch Expressions (Standard)</a> Switch表达式<br>362: <a href="https://openjdk.java.net/jeps/362">Deprecate the Solaris and SPARC Ports</a> 弃用Solaris和SPARC端口<br>363: <a href="https://openjdk.java.net/jeps/363">Remove the Concurrent Mark Sweep (CMS) Garbage Collector</a> 删除并发标记扫描（CMS）垃圾回收器<br>364: <a href="https://openjdk.java.net/jeps/364">ZGC on macOS</a><br>365: <a href="https://openjdk.java.net/jeps/365">ZGC on Windows</a><br>366: <a href="https://openjdk.java.net/jeps/366">Deprecate the ParallelScavenge + SerialOld GC Combination</a> 弃用ParallelScavenge + SerialOld GC组合<br>367: <a href="https://openjdk.java.net/jeps/367">Remove the Pack200 Tools and API</a> 删除Pack200工具和API<br>368: <a href="https://openjdk.java.net/jeps/368">Text Blocks (Second Preview)</a> 文本块<br>370: <a href="https://openjdk.java.net/jeps/370">Foreign-Memory Access API (Incubator)</a> 外部存储器访问API</p></blockquote><h4 id="jdk-15"><a href="#jdk-15" class="headerlink" title="jdk 15"></a>jdk 15</h4><p><a href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p><blockquote><p>339: <a href="https://openjdk.java.net/jeps/339">Edwards-Curve Digital Signature Algorithm (EdDSA)</a> EdDSA 数字签名算法<br>360: <a href="https://openjdk.java.net/jeps/360">Sealed Classes (Preview)</a> 密封类（预览）<br>371: <a href="https://openjdk.java.net/jeps/371">Hidden Classes</a> 隐藏类<br>372: <a href="https://openjdk.java.net/jeps/372">Remove the Nashorn JavaScript Engine</a> 移除 Nashorn JavaScript 引擎<br>373: <a href="https://openjdk.java.net/jeps/373">Reimplement the Legacy DatagramSocket API</a> 重新实现 Legacy DatagramSocket API<br>374: <a href="https://openjdk.java.net/jeps/374">Disable and Deprecate Biased Locking</a> 禁用偏向锁定<br>375: <a href="https://openjdk.java.net/jeps/375">Pattern Matching for instanceof (Second Preview)</a> instanceof 模式匹配（第二次预览）<br>377: <a href="https://openjdk.java.net/jeps/377">ZGC: A Scalable Low-Latency Garbage Collector</a> ZGC：一个可扩展的低延迟垃圾收集器<br>378: <a href="https://openjdk.java.net/jeps/378">Text Blocks</a> 文本块<br>379: <a href="https://openjdk.java.net/jeps/379">Shenandoah: A Low-Pause-Time Garbage Collector</a> Shenandoah:低暂停时间垃圾收集器<br>381: <a href="https://openjdk.java.net/jeps/381">Remove the Solaris and SPARC Ports</a> 移除 Solaris 和 SPARC 端口<br>383: <a href="https://openjdk.java.net/jeps/383">Foreign-Memory Access API (Second Incubator)</a> 外部存储器访问 API（第二次孵化版）<br>384: <a href="https://openjdk.java.net/jeps/384">Records (Second Preview)</a> Records（第二次预览）<br>385: <a href="https://openjdk.java.net/jeps/385">Deprecate RMI Activation for Removal</a> 废弃 RMI 激活机制</p></blockquote><h4 id="jdk-16"><a href="#jdk-16" class="headerlink" title="jdk 16"></a>jdk 16</h4><p><a href="https://openjdk.java.net/projects/jdk/16/">https://openjdk.java.net/projects/jdk/16/</a></p><blockquote><p>338: <a href="https://openjdk.java.net/jeps/338">Vector API (Incubator)</a> Vector API（孵化器）<br>347: <a href="https://openjdk.java.net/jeps/347">Enable C++14 Language Features</a> JDK C++的源码中允许使用C++14的语言特性<br>357: <a href="https://openjdk.java.net/jeps/357">Migrate from Mercurial to Git</a> OpenJDK源码的版本控制从Mercurial (hg) 迁移到git<br>369: <a href="https://openjdk.java.net/jeps/369">Migrate to GitHub</a> OpenJDK源码的版本控制迁移到github上<br>376: <a href="https://openjdk.java.net/jeps/376">ZGC: Concurrent Thread-Stack Processing</a> ZGC：并发线程处理<br>380: <a href="https://openjdk.java.net/jeps/380">Unix-Domain Socket Channels</a> Unix域套接字通道<br>386: <a href="https://openjdk.java.net/jeps/386">Alpine Linux Port</a> 将glibc的jdk移植到使用musl的alpine linux上<br>387: <a href="https://openjdk.java.net/jeps/387">Elastic Metaspace</a> 弹性元空间<br>388: <a href="https://openjdk.java.net/jeps/388">Windows&#x2F;AArch64 Port</a> 移植JDK到Windows&#x2F;AArch64<br>389: <a href="https://openjdk.java.net/jeps/389">Foreign Linker API (Incubator)</a> 提供jdk.incubator.foreign来简化native code的调用<br>390: <a href="https://openjdk.java.net/jeps/390">Warnings for Value-Based Classes</a> 提供基于值的类的警告<br>392: <a href="https://openjdk.java.net/jeps/392">Packaging Tool</a> jpackage打包工具转正<br>393: <a href="https://openjdk.java.net/jeps/393">Foreign-Memory Access API (Third Incubator)</a><br>394: <a href="https://openjdk.java.net/jeps/394">Pattern Matching for instanceof</a> Instanceof的模式匹配转正<br>395: <a href="https://openjdk.java.net/jeps/395">Records</a> Records转正<br>396: <a href="https://openjdk.java.net/jeps/396">Strongly Encapsulate JDK Internals by Default</a> 默认情况下，封装了JDK内部构件<br>397: <a href="https://openjdk.java.net/jeps/397">Sealed Classes (Second Preview)</a> 密封类</p></blockquote><h4 id="jdk-17"><a href="#jdk-17" class="headerlink" title="jdk 17"></a>jdk 17</h4><p><a href="https://openjdk.java.net/projects/jdk/17/">https://openjdk.java.net/projects/jdk/17/</a></p><blockquote><p>306: <a href="https://openjdk.java.net/jeps/306">Restore Always-Strict Floating-Point Semantics</a> 恢复始终严格的浮点语义</p><p>356: <a href="https://openjdk.java.net/jeps/356">Enhanced Pseudo-Random Number Generators</a> 增强型伪随机数生成器</p><p>382: <a href="https://openjdk.java.net/jeps/382">New macOS Rendering Pipeline</a> 新的macOS渲染管道</p><p>391: <a href="https://openjdk.java.net/jeps/391">macOS&#x2F;AArch64 Port</a> macOS&#x2F;AArch64端口</p><p>398: <a href="https://openjdk.java.net/jeps/398">Deprecate the Applet API for Removal</a> 弃用Applet API后续将进行删除</p><p>403: <a href="https://openjdk.java.net/jeps/403">Strongly Encapsulate JDK Internals</a> 强封装JDK的内部API</p><p>406: <a href="https://openjdk.java.net/jeps/406">Pattern Matching for switch (Preview)</a> switch模式匹配（预览）</p><p>407: <a href="https://openjdk.java.net/jeps/407">Remove RMI Activation</a> 删除RMI激活机制</p><p>409: <a href="https://openjdk.java.net/jeps/409">Sealed Classes</a> 密封类转正</p><p>410: <a href="https://openjdk.java.net/jeps/410">Remove the Experimental AOT and JIT Compiler</a> 删除实验性的AOT和JIT编译器</p><p>411: <a href="https://openjdk.java.net/jeps/411">Deprecate the Security Manager for Removal</a> 弃用即将删除的安全管理器</p><p>412: <a href="https://openjdk.java.net/jeps/412">Foreign Function &amp; Memory API (Incubator)</a> 外部函数和内存API（孵化特性）</p><p>414: <a href="https://openjdk.java.net/jeps/414">Vector API (Second Incubator)</a> Vector API（第二次孵化特性）</p><p>415: <a href="https://openjdk.java.net/jeps/415">Context-Specific Deserialization Filters</a> 上下文特定的反序列化过滤器</p></blockquote><h3 id="1-5-JDK各版本下载链接"><a href="#1-5-JDK各版本下载链接" class="headerlink" title="1.5 JDK各版本下载链接"></a>1.5 JDK各版本下载链接</h3><pre class="line-numbers language-http" data-language="http"><code class="language-http">https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;archive&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="../images/image-20220525200441935.png" alt="image-20220525200441935" style="zoom:80%;" /><blockquote><p>链接：<a href="https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg">https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg</a><br>提取码：yyds </p></blockquote><p><img src="/../images/image-20221213235332866.png" alt="image-20221213235332866"></p><h3 id="1-6-如何学习新特性"><a href="#1-6-如何学习新特性" class="headerlink" title="1.6 如何学习新特性"></a>1.6 如何学习新特性</h3><p>对于新特性，我们应该从哪几个角度学习新特性呢？</p><ul><li><p>语法层面：</p><ul><li>比如JDK5中的自动拆箱、自动装箱、enum、泛型</li><li>比如JDK8中的lambda表达式、接口中的默认方法、静态方法</li><li>比如JDK10中局部变量的类型推断</li><li>比如JDK12中的switch</li><li>比如JDK13中的文本块</li></ul></li><li><p>API层面：</p><ul><li>比如JDK8中的Stream、Optional、新的日期时间、HashMap的底层结构</li><li>比如JDK9中String的底层结构</li><li>新的 &#x2F; 过时的 API</li></ul></li><li><p>底层优化</p><ul><li><p>比如JDK8中永久代被元空间替代、新的JS执行引擎</p></li><li><p>比如新的垃圾回收器、GC参数、JVM的优化</p></li></ul></li></ul><h2 id="2-Java8新特性：Lambda表达式"><a href="#2-Java8新特性：Lambda表达式" class="headerlink" title="2. Java8新特性：Lambda表达式"></a>2. Java8新特性：Lambda表达式</h2><h3 id="2-1-关于Java8新特性简介"><a href="#2-1-关于Java8新特性简介" class="headerlink" title="2.1 关于Java8新特性简介"></a>2.1 关于Java8新特性简介</h3><p>Java 8 (又称为 JDK 8或JDK1.8) 是 Java 语言开发的一个主要版本。 Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p><img src="../images/image-20220525201653599.png" alt="image-20220525201653599" style="zoom:80%;" /><ul><li><p>速度更快</p></li><li><p>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</p></li><li><p>强大的 <strong>Stream API</strong></p></li><li><p>便于并行</p><ul><li><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</li></ul></li><li><p>最大化减少空指针异常：Optional</p></li><li><p>Nashorn引擎，允许在JVM上运行JS应用</p><ul><li>发音“nass-horn”，是德国二战时一个坦克的命名</li><li>javascript运行在jvm已经不是新鲜事了，Rhino早在jdk6的时候已经存在。现在替代Rhino，官方的解释是Rhino相比其他JavaScript引擎（比如google的V8）实在太慢了，改造Rhino还不如重写。所以Nashorn的性能也是其一个亮点。</li><li>Nashorn 项目在 JDK 9 中得到改进；在JDK11 中<code>Deprecated</code>，后续JDK15版本中<code>remove</code>。在JDK11中取以代之的是GraalVM。（GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。）</li></ul></li></ul><h3 id="2-2-冗余的匿名内部类"><a href="#2-2-冗余的匿名内部类" class="headerlink" title="2.2 冗余的匿名内部类"></a>2.2 冗余的匿名内部类</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.fp;public class UseFunctionalProgramming &#123;    public static void main(String[] args) &#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;多线程任务执行！&quot;);            &#125;        &#125;).start(); &#x2F;&#x2F; 启动线程    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><p><strong>代码分析：</strong></p><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h3 id="2-3-好用的lambda表达式"><a href="#2-3-好用的lambda表达式" class="headerlink" title="2.3 好用的lambda表达式"></a>2.3 好用的lambda表达式</h3><img src="../images/lambda表达式.jpg" alt="lambda表达式" style="zoom:67%;" /><p><img src="/../images/image-20221111213355625.png" alt="image-20221111213355625"></p><h3 id="2-4-Lambda-及其使用举例"><a href="#2-4-Lambda-及其使用举例" class="headerlink" title="2.4 Lambda 及其使用举例"></a>2.4 Lambda 及其使用举例</h3><p>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p><ul><li>从匿名类到 Lambda 的转换举例1</li></ul><img src="../images/image-20220527101737072.png" alt="image-20220527101737072" style="zoom:67%;" /><ul><li>从匿名类到 Lambda 的转换举例2</li></ul><img src="../images/image-20220527101814203.png" alt="image-20220527101814203" style="zoom:80%;" /><h3 id="2-5-语法"><a href="#2-5-语法" class="headerlink" title="2.5 语法"></a>2.5 语法</h3><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “<code>-&gt;</code>” ， 该操作符被称为 <code>Lambda 操作符</code>或<code>箭头操作符</code>。它将 Lambda 分为两个部分：</p><ul><li>左侧：指定了 Lambda 表达式需要的参数列表</li><li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</li></ul><p><strong>语法格式一：</strong>无参，无返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test1()&#123;    &#x2F;&#x2F;未使用Lambda表达式    Runnable r1 &#x3D; new Runnable() &#123;        @Override        public void run() &#123;            System.out.println(&quot;我爱北京天安门&quot;);        &#125;    &#125;;    r1.run();    System.out.println(&quot;***********************&quot;);    &#x2F;&#x2F;使用Lambda表达式    Runnable r2 &#x3D; () -&gt; &#123;        System.out.println(&quot;我爱北京故宫&quot;);    &#125;;    r2.run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法格式二：</strong>Lambda 需要一个参数，但是没有返回值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test2()&#123;    &#x2F;&#x2F;未使用Lambda表达式    Consumer&lt;String&gt; con &#x3D; new Consumer&lt;String&gt;() &#123;        @Override        public void accept(String s) &#123;            System.out.println(s);        &#125;    &#125;;    con.accept(&quot;谎言和誓言的区别是什么？&quot;);    System.out.println(&quot;*******************&quot;);    &#x2F;&#x2F;使用Lambda表达式    Consumer&lt;String&gt; con1 &#x3D; (String s) -&gt; &#123;        System.out.println(s);    &#125;;    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法格式三：</strong>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test3()&#123;    &#x2F;&#x2F;语法格式三使用前    Consumer&lt;String&gt; con1 &#x3D; (String s) -&gt; &#123;        System.out.println(s);    &#125;;    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);    System.out.println(&quot;*******************&quot;);    &#x2F;&#x2F;语法格式三使用后    Consumer&lt;String&gt; con2 &#x3D; (s) -&gt; &#123;        System.out.println(s);    &#125;;    con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法格式四：</strong>Lambda 若只需要一个参数时，参数的小括号可以省略</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test4()&#123;    &#x2F;&#x2F;语法格式四使用前    Consumer&lt;String&gt; con1 &#x3D; (s) -&gt; &#123;        System.out.println(s);    &#125;;    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);    System.out.println(&quot;*******************&quot;);    &#x2F;&#x2F;语法格式四使用后    Consumer&lt;String&gt; con2 &#x3D; s -&gt; &#123;        System.out.println(s);    &#125;;    con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法格式五：</strong>Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test5()&#123;    &#x2F;&#x2F;语法格式五使用前    Comparator&lt;Integer&gt; com1 &#x3D; new Comparator&lt;Integer&gt;() &#123;        @Override        public int compare(Integer o1, Integer o2) &#123;            System.out.println(o1);            System.out.println(o2);            return o1.compareTo(o2);        &#125;    &#125;;    System.out.println(com1.compare(12,21));    System.out.println(&quot;*****************************&quot;);    &#x2F;&#x2F;语法格式五使用后    Comparator&lt;Integer&gt; com2 &#x3D; (o1,o2) -&gt; &#123;        System.out.println(o1);        System.out.println(o2);        return o1.compareTo(o2);    &#125;;    System.out.println(com2.compare(12,6));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法格式六：</strong>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test6()&#123;    &#x2F;&#x2F;语法格式六使用前    Comparator&lt;Integer&gt; com1 &#x3D; (o1,o2) -&gt; &#123;        return o1.compareTo(o2);    &#125;;    System.out.println(com1.compare(12,6));    System.out.println(&quot;*****************************&quot;);    &#x2F;&#x2F;语法格式六使用后    Comparator&lt;Integer&gt; com2 &#x3D; (o1,o2) -&gt; o1.compareTo(o2);    System.out.println(com2.compare(12,21));&#125;@Testpublic void test7()&#123;    &#x2F;&#x2F;语法格式六使用前    Consumer&lt;String&gt; con1 &#x3D; s -&gt; &#123;        System.out.println(s);    &#125;;    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);    System.out.println(&quot;*****************************&quot;);    &#x2F;&#x2F;语法格式六使用后    Consumer&lt;String&gt; con2 &#x3D; s -&gt; System.out.println(s);    con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-关于类型推断"><a href="#2-6-关于类型推断" class="headerlink" title="2.6 关于类型推断"></a>2.6 关于类型推断</h3><p>在语法格式三 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“<code>类型推断</code>”。</p><img src="../images/image-20220527103215741.png" alt="image-20220527103215741" style="zoom:67%;" /><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test() &#123;    &#x2F;&#x2F;类型推断1    ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F;类型推断2    int[] arr &#x3D; &#123;1, 2, 3&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Java8新特性：函数式-Functional-接口"><a href="#3-Java8新特性：函数式-Functional-接口" class="headerlink" title="3. Java8新特性：函数式(Functional)接口"></a>3. Java8新特性：函数式(Functional)接口</h2><h3 id="3-1-什么是函数式接口"><a href="#3-1-什么是函数式接口" class="headerlink" title="3.1 什么是函数式接口"></a>3.1 什么是函数式接口</h3><ul><li>只包含<code>一个抽象方法</code>（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。</li><li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</li><li>我们可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li><li>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口</li></ul><h3 id="3-2-如何理解函数式接口"><a href="#3-2-如何理解函数式接口" class="headerlink" title="3.2 如何理解函数式接口"></a>3.2 如何理解函数式接口</h3><p><img src="/images/03-Overview.png"></p><ul><li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，即Java不但可以支持OOP还可以支持OOF（面向函数编程）<ul><li>Java8引入了Lambda表达式之后，Java也开始支持函数式编程。</li><li>Lambda表达式不是Java最早使用的。目前C++，C#，Python，Scala等均支持Lambda表达式。</li></ul></li><li>面向对象的思想：<ul><li>做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。</li></ul></li><li>函数式编程思想：<ul><li>只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。</li></ul></li><li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</li><li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li></ul><h3 id="3-3-举例"><a href="#3-3-举例" class="headerlink" title="3.3 举例"></a>3.3 举例</h3><p>举例1：</p><img src="../images/image-20220527111442115.png" alt="image-20220527111442115" style="zoom: 80%;" /><p>举例2：</p><img src="../images/image-20220527111621424.png" alt="image-20220527111621424" style="zoom:80%;" /><p>作为参数传递 Lambda 表达式：</p><img src="../images/image-20220527111751485.png" alt="image-20220527111751485" style="zoom:80%;" /><blockquote><p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p></blockquote><h3 id="3-4-Java-内置函数式接口"><a href="#3-4-Java-内置函数式接口" class="headerlink" title="3.4 Java 内置函数式接口"></a>3.4 Java 内置函数式接口</h3><h4 id="3-4-1-之前的函数式接口"><a href="#3-4-1-之前的函数式接口" class="headerlink" title="3.4.1 之前的函数式接口"></a>3.4.1 之前的函数式接口</h4><p>之前学过的接口，有些就是函数式接口，比如：</p><ul><li>java.lang.Runnable<ul><li>public void run()</li></ul></li><li>java.lang.Iterable<T><ul><li>public Iterator<T> iterate()</li></ul></li><li>java.lang.Comparable<T><ul><li>public int compareTo(T t)</li></ul></li><li>java.util.Comparator<T><ul><li>public int compare(T t1, T t2)</li></ul></li></ul><h4 id="3-4-2-四大核心函数式接口"><a href="#3-4-2-四大核心函数式接口" class="headerlink" title="3.4.2 四大核心函数式接口"></a>3.4.2 四大核心函数式接口</h4><table><thead><tr><th>函数式接口</th><th>称谓</th><th>参数类型</th><th>用途</th></tr></thead><tbody><tr><td><code>Consumer&lt;T&gt;  </code></td><td>消费型接口</td><td>T</td><td>对类型为T的对象应用操作，包含方法：  <code>void accept(T t)  </code></td></tr><tr><td><code>Supplier&lt;T&gt;  </code></td><td>供给型接口</td><td>无</td><td>返回类型为T的对象，包含方法：<code>T get()  </code></td></tr><tr><td><code>Function&lt;T, R&gt;  </code></td><td>函数型接口</td><td>T</td><td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)  </code></td></tr><tr><td><code>Predicate&lt;T&gt;  </code></td><td>判断型接口</td><td>T</td><td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)  </code></td></tr></tbody></table><h4 id="3-4-3-其它接口"><a href="#3-4-3-其它接口" class="headerlink" title="3.4.3 其它接口"></a>3.4.3 其它接口</h4><p><strong>类型1：消费型接口</strong></p><p>消费型接口的抽象方法特点：有形参，但是返回值类型是void</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>BiConsumer&lt;T,U&gt;</td><td>void accept(T t, U u)</td><td>接收两个对象用于完成功能</td></tr><tr><td>DoubleConsumer</td><td>void accept(double value)</td><td>接收一个double值</td></tr><tr><td>IntConsumer</td><td>void accept(int value)</td><td>接收一个int值</td></tr><tr><td>LongConsumer</td><td>void accept(long value)</td><td>接收一个long值</td></tr><tr><td>ObjDoubleConsumer<T></td><td>void accept(T t, double value)</td><td>接收一个对象和一个double值</td></tr><tr><td>ObjIntConsumer<T></td><td>void accept(T t, int value)</td><td>接收一个对象和一个int值</td></tr><tr><td>ObjLongConsumer<T></td><td>void accept(T t, long value)</td><td>接收一个对象和一个long值</td></tr></tbody></table><p><strong>类型2：供给型接口</strong></p><p>这类接口的抽象方法特点：无参，但是有返回值</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>BooleanSupplier</td><td>boolean getAsBoolean()</td><td>返回一个boolean值</td></tr><tr><td>DoubleSupplier</td><td>double getAsDouble()</td><td>返回一个double值</td></tr><tr><td>IntSupplier</td><td>int getAsInt()</td><td>返回一个int值</td></tr><tr><td>LongSupplier</td><td>long getAsLong()</td><td>返回一个long值</td></tr></tbody></table><p><strong>类型3：函数型接口</strong></p><p>这类接口的抽象方法特点：既有参数又有返回值</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>UnaryOperator<T></td><td>T apply(T t)</td><td>接收一个T类型对象，返回一个T类型对象结果</td></tr><tr><td>DoubleFunction<R></td><td>R apply(double value)</td><td>接收一个double值，返回一个R类型对象</td></tr><tr><td>IntFunction<R></td><td>R apply(int value)</td><td>接收一个int值，返回一个R类型对象</td></tr><tr><td>LongFunction<R></td><td>R apply(long value)</td><td>接收一个long值，返回一个R类型对象</td></tr><tr><td>ToDoubleFunction<T></td><td>double applyAsDouble(T value)</td><td>接收一个T类型对象，返回一个double</td></tr><tr><td>ToIntFunction<T></td><td>int applyAsInt(T value)</td><td>接收一个T类型对象，返回一个int</td></tr><tr><td>ToLongFunction<T></td><td>long applyAsLong(T value)</td><td>接收一个T类型对象，返回一个long</td></tr><tr><td>DoubleToIntFunction</td><td>int applyAsInt(double value)</td><td>接收一个double值，返回一个int结果</td></tr><tr><td>DoubleToLongFunction</td><td>long applyAsLong(double value)</td><td>接收一个double值，返回一个long结果</td></tr><tr><td>IntToDoubleFunction</td><td>double applyAsDouble(int value)</td><td>接收一个int值，返回一个double结果</td></tr><tr><td>IntToLongFunction</td><td>long applyAsLong(int value)</td><td>接收一个int值，返回一个long结果</td></tr><tr><td>LongToDoubleFunction</td><td>double applyAsDouble(long value)</td><td>接收一个long值，返回一个double结果</td></tr><tr><td>LongToIntFunction</td><td>int applyAsInt(long value)</td><td>接收一个long值，返回一个int结果</td></tr><tr><td>DoubleUnaryOperator</td><td>double applyAsDouble(double operand)</td><td>接收一个double值，返回一个double</td></tr><tr><td>IntUnaryOperator</td><td>int applyAsInt(int operand)</td><td>接收一个int值，返回一个int结果</td></tr><tr><td>LongUnaryOperator</td><td>long applyAsLong(long operand)</td><td>接收一个long值，返回一个long结果</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>R apply(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td></tr><tr><td>BinaryOperator<T></td><td>T apply(T t, T u)</td><td>接收两个T类型对象，返回一个T类型对象结果</td></tr><tr><td>ToDoubleBiFunction&lt;T,U&gt;</td><td>double applyAsDouble(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个double</td></tr><tr><td>ToIntBiFunction&lt;T,U&gt;</td><td>int applyAsInt(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个int</td></tr><tr><td>ToLongBiFunction&lt;T,U&gt;</td><td>long applyAsLong(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个long</td></tr><tr><td>DoubleBinaryOperator</td><td>double applyAsDouble(double left, double right)</td><td>接收两个double值，返回一个double结果</td></tr><tr><td>IntBinaryOperator</td><td>int applyAsInt(int left, int right)</td><td>接收两个int值，返回一个int结果</td></tr><tr><td>LongBinaryOperator</td><td>long applyAsLong(long left, long right)</td><td>接收两个long值，返回一个long结果</td></tr></tbody></table><p><strong>类型4：判断型接口</strong></p><p>这类接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>BiPredicate&lt;T,U&gt;</td><td>boolean test(T t, U u)</td><td>接收两个对象</td></tr><tr><td>DoublePredicate</td><td>boolean test(double value)</td><td>接收一个double值</td></tr><tr><td>IntPredicate</td><td>boolean test(int value)</td><td>接收一个int值</td></tr><tr><td>LongPredicate</td><td>boolean test(long value)</td><td>接收一个long值</td></tr></tbody></table><h4 id="3-4-4-内置接口代码演示"><a href="#3-4-4-内置接口代码演示" class="headerlink" title="3.4.4 内置接口代码演示"></a>3.4.4 内置接口代码演示</h4><p>举例1：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;import java.util.Arrays;import java.util.List;public class TestConsumer &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list &#x3D; Arrays.asList(&quot;java&quot;,&quot;c&quot;,&quot;python&quot;,&quot;c++&quot;,&quot;VB&quot;,&quot;C#&quot;);        &#x2F;&#x2F;遍历Collection集合，并将传递给action参数的操作代码应用在每一个元素上。        list.forEach(s -&gt; System.out.println(s));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例2：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;import java.util.function.Supplier;public class TestSupplier &#123;    public static void main(String[] args) &#123;        Supplier&lt;String&gt; supplier &#x3D; () -&gt; &quot;尚硅谷&quot;;        System.out.println(supplier.get());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例3：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;import java.util.ArrayList;public class TestPredicate &#123;    public static void main(String[] args) &#123;        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;hello&quot;);        list.add(&quot;java&quot;);        list.add(&quot;atguigu&quot;);        list.add(&quot;ok&quot;);        list.add(&quot;yes&quot;);        System.out.println(&quot;删除之前：&quot;);        list.forEach(t-&gt; System.out.println(t));        &#x2F;&#x2F;用于删除集合中满足filter指定的条件判断的。        &#x2F;&#x2F;删除包含o字母的元素        list.removeIf(s -&gt; s.contains(&quot;o&quot;));        System.out.println(&quot;删除包含o字母的元素之后：&quot;);        list.forEach(t-&gt; System.out.println(t));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例4：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;import java.util.function.Function;public class TestFunction &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;使用Lambda表达式实现Function&lt;T,R&gt;接口，可以实现将一个字符串首字母转为大写的功能。        Function&lt;String,String&gt; fun &#x3D; s -&gt; s.substring(0,1).toUpperCase() + s.substring(1);        System.out.println(fun.apply(&quot;hello&quot;));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-5-练习"><a href="#3-4-5-练习" class="headerlink" title="3.4.5 练习"></a>3.4.5 练习</h4><p><strong>练习1：无参无返回值形式</strong></p><p>假如有自定义函数式接口Call如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Call &#123;    void shout();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在测试类中声明一个如下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void callSomething(Call call)&#123;call.shout();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestLambda &#123;public static void main(String[] args) &#123;callSomething(()-&gt;System.out.println(&quot;回家吃饭&quot;));callSomething(()-&gt;System.out.println(&quot;我爱你&quot;));callSomething(()-&gt;System.out.println(&quot;滚蛋&quot;));callSomething(()-&gt;System.out.println(&quot;回来&quot;));&#125;public static void callSomething(Call call)&#123;call.shout();&#125;&#125;interface Call &#123;    void shout();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习2：消费型接口</strong></p><p>代码示例：Consumer<T>接口</p><p>在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法：</p><p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p><p>在JDK1.8中Map集合接口中增加了一个默认方法：</p><p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p><p>案例：</p><p>（1）创建一个Collection系列的集合，添加一些字符串，调用forEach方法遍历查看</p><p>（2）创建一个Map系列的集合，添加一些(key,value)键值对，调用forEach方法遍历查看</p><p>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test1()&#123;List&lt;String&gt; list &#x3D; Arrays.asList(&quot;hello&quot;,&quot;java&quot;,&quot;lambda&quot;,&quot;atguigu&quot;);list.forEach(s -&gt; System.out.println(s));   &#125;@Testpublic void test2()&#123;HashMap&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(1, &quot;hello&quot;);map.put(2, &quot;java&quot;);map.put(3, &quot;lambda&quot;);map.put(4, &quot;atguigu&quot;);map.forEach((k,v) -&gt; System.out.println(k+&quot;-&gt;&quot;+v));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习3：供给型接口</strong></p><p>代码示例：Supplier<T>接口</p><p>在JDK1.8中增加了StreamAPI，java.util.stream.Stream<T>是一个数据流。这个类型有一个静态方法：</p><p><code>public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code>可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：<code>public void forEach(Consumer&lt;? super T&gt; action)</code>。</p><p>案例：</p><p>现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test2()&#123;Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习4：功能型接口</strong></p><p>代码示例：Function&lt;T,R&gt;接口</p><p>在JDK1.8时Map接口增加了很多方法，例如：</p><p><code>public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function) </code>按照function指定的操作替换map中的value。</p><p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p><p>案例：</p><p>（1）声明一个Employee员工类型，包含编号、姓名、薪资。</p><p>（2）添加n个员工对象到一个HashMap&lt;Integer,Employee&gt;集合中，其中员工编号为key，员工对象为value。</p><p>（3）调用Map的forEach遍历集合</p><p>（4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。</p><p>（5）再次调用Map的forEach遍历集合查看结果</p><p>Employee类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee&#123;private int id;private String name;private double salary;public Employee(int id, String name, double salary) &#123;super();this.id &#x3D; id;this.name &#x3D; name;this.salary &#x3D; salary;&#125;public Employee() &#123;super();&#125;public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id &#x3D; id;&#125;public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;public double getSalary() &#123;return salary;&#125;public void setSalary(double salary) &#123;this.salary &#x3D; salary;&#125;@Overridepublic String toString() &#123;return &quot;Employee [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, salary&#x3D;&quot; + salary + &quot;]&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.HashMap;public class TestLambda &#123;public static void main(String[] args) &#123;HashMap&lt;Integer,Employee&gt; map &#x3D; new HashMap&lt;&gt;();Employee e1 &#x3D; new Employee(1, &quot;张三&quot;, 8000);Employee e2 &#x3D; new Employee(2, &quot;李四&quot;, 9000);Employee e3 &#x3D; new Employee(3, &quot;王五&quot;, 10000);Employee e4 &#x3D; new Employee(4, &quot;赵六&quot;, 11000);Employee e5 &#x3D; new Employee(5, &quot;钱七&quot;, 12000);map.put(e1.getId(), e1);map.put(e2.getId(), e2);map.put(e3.getId(), e3);map.put(e4.getId(), e4);map.put(e5.getId(), e5);map.forEach((k,v) -&gt; System.out.println(k+&quot;&#x3D;&quot;+v));System.out.println();map.replaceAll((k,v)-&gt;&#123;if(v.getSalary()&lt;10000)&#123;v.setSalary(10000);&#125;return v;&#125;);map.forEach((k,v) -&gt; System.out.println(k+&quot;&#x3D;&quot;+v));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习5：判断型接口</strong></p><p>代码示例：Predicate<T>接口</p><p>JDK1.8时，Collecton<E>接口增加了一下方法，其中一个如下：</p><p><code>public default boolean removeIf(Predicate&lt;? super E&gt; filter)</code> 用于删除集合中满足filter指定的条件判断的。</p><p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p><p>案例：</p><p>（1）添加一些字符串到一个Collection集合中</p><p>（2）调用forEach遍历集合</p><p>（3）调用removeIf方法，删除其中字符串的长度&lt;5的</p><p>（4）再次调用forEach遍历集合</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;public class TestLambda &#123;public static void main(String[] args) &#123;ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);list.add(&quot;java&quot;);list.add(&quot;atguigu&quot;);list.add(&quot;ok&quot;);list.add(&quot;yes&quot;);list.forEach(str-&gt;System.out.println(str));System.out.println();list.removeIf(str-&gt;str.length()&lt;5);list.forEach(str-&gt;System.out.println(str));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习6：判断型接口</strong></p><p>案例：</p><p>（1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。</p><p>（2）声明一个EmployeeSerice员工管理类，包含一个ArrayList<Employee>集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。</p><p>（3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList<Employee> get(Predicate<Employee> p)，即将满足p指定的条件的员工，添加到一个新的ArrayList<Employee> 集合中返回。</p><p>（4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取：</p><ul><li>所有员工对象</li><li>所有年龄超过35的员工</li><li>所有薪资高于15000的女员工</li><li>所有编号是偶数的员工</li><li>名字是“张三”的员工</li><li>年龄超过25，薪资低于10000的男员工</li></ul><p>示例代码：</p><p>Employee类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;private int id;private String name;private char gender;private int age;private double salary;public Employee(int id, String name, char gender, int age, double salary) &#123;super();this.id &#x3D; id;this.name &#x3D; name;this.gender &#x3D; gender;this.age &#x3D; age;this.salary &#x3D; salary;&#125;public Employee() &#123;super();&#125;public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id &#x3D; id;&#125;public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;public double getSalary() &#123;return salary;&#125;public void setSalary(double salary) &#123;this.salary &#x3D; salary;&#125;@Overridepublic String toString() &#123;return &quot;Employee [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, gender&#x3D;&quot; + gender + &quot;, age&#x3D;&quot; + age + &quot;, salary&#x3D;&quot; + salary+ &quot;]&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>员工管理类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class EmployeeService&#123;private ArrayList&lt;Employee&gt; all;public EmployeeService()&#123;all &#x3D; new ArrayList&lt;Employee&gt;();all.add(new Employee(1, &quot;张三&quot;, &#39;男&#39;, 33, 8000));all.add(new Employee(2, &quot;翠花&quot;, &#39;女&#39;, 23, 18000));all.add(new Employee(3, &quot;无能&quot;, &#39;男&#39;, 46, 8000));all.add(new Employee(4, &quot;李四&quot;, &#39;女&#39;, 23, 9000));all.add(new Employee(5, &quot;老王&quot;, &#39;男&#39;, 23, 15000));all.add(new Employee(6, &quot;大嘴&quot;, &#39;男&#39;, 23, 11000));&#125;public ArrayList&lt;Employee&gt; get(Predicate&lt;Employee&gt; p)&#123;ArrayList&lt;Employee&gt; result &#x3D; new ArrayList&lt;Employee&gt;();for (Employee emp : result) &#123;if(p.test(emp))&#123;result.add(emp);&#125;&#125;return result;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestLambda &#123;public static void main(String[] args) &#123;EmployeeService es &#x3D; new EmployeeService();es.get(e -&gt; true).forEach(e-&gt;System.out.println(e));System.out.println();es.get(e -&gt; e.getAge()&gt;35).forEach(e-&gt;System.out.println(e));System.out.println();es.get(e -&gt; e.getSalary()&gt;15000 &amp;&amp; e.getGender()&#x3D;&#x3D;&#39;女&#39;).forEach(e-&gt;System.out.println(e));System.out.println();es.get(e -&gt; e.getId()%2&#x3D;&#x3D;0).forEach(e-&gt;System.out.println(e));System.out.println();es.get(e -&gt; &quot;张三&quot;.equals(e.getName())).forEach(e-&gt;System.out.println(e));System.out.println();es.get(e -&gt; e.getAge()&gt;25 &amp;&amp; e.getSalary()&lt;10000 &amp;&amp; e.getGender()&#x3D;&#x3D;&#39;男&#39;).forEach(e-&gt;System.out.println(e));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Java8新特性：方法引用与构造器引用"><a href="#4-Java8新特性：方法引用与构造器引用" class="headerlink" title="4. Java8新特性：方法引用与构造器引用"></a>4. Java8新特性：方法引用与构造器引用</h2><p>Lambda表达式是可以简化函数式接口的变量或形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。</p><h3 id="4-1-方法引用"><a href="#4-1-方法引用" class="headerlink" title="4.1 方法引用"></a>4.1 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p><p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p><blockquote><p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法<code>对语言的功能并没有影响，但是更方便程序员使用</code>。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p></blockquote><h4 id="4-1-1-方法引用格式"><a href="#4-1-1-方法引用格式" class="headerlink" title="4.1.1 方法引用格式"></a>4.1.1 方法引用格式</h4><ul><li><p>格式：使用方法引用操作符 “<code>::</code>” 将类(或对象) 与 方法名分隔开来。</p><ul><li>两个:中间不能有空格，而且必须英文状态下半角输入</li></ul></li><li><p>如下三种主要使用情况：</p><ul><li>情况1：<code>对象 :: 实例方法名</code></li><li>情况2：<code>类 :: 静态方法名</code></li><li>情况3：<code>类 :: 实例方法名</code></li></ul></li></ul><h4 id="4-1-2-方法引用使用前提"><a href="#4-1-2-方法引用使用前提" class="headerlink" title="4.1.2 方法引用使用前提"></a>4.1.2 方法引用使用前提</h4><p><strong>要求1：</strong>Lambda体只有一句语句，并且是通过调用一个对象的&#x2F;类现有的方法来完成的</p><p>例如：System.out对象，调用println()方法来完成Lambda体</p><p>​           Math类，调用random()静态方法来完成Lambda体</p><p><strong>要求2：</strong></p><p>针对情况1：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p><p>针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p><p>针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以）</p><p>例如：t-&gt;System.out.println(t)</p><p>​        () -&gt; Math.random() 都是无参</p><h4 id="4-1-3-举例"><a href="#4-1-3-举例" class="headerlink" title="4.1.3 举例"></a>4.1.3 举例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MethodRefTest &#123;&#x2F;&#x2F; 情况一：对象 :: 实例方法&#x2F;&#x2F;Consumer中的void accept(T t)&#x2F;&#x2F;PrintStream中的void println(T t)@Testpublic void test1() &#123;Consumer&lt;String&gt; con1 &#x3D; str -&gt; System.out.println(str);con1.accept(&quot;北京&quot;);System.out.println(&quot;*******************&quot;);PrintStream ps &#x3D; System.out;Consumer&lt;String&gt; con2 &#x3D; ps::println;con2.accept(&quot;beijing&quot;);&#125;&#x2F;&#x2F;Supplier中的T get()&#x2F;&#x2F;Employee中的String getName()@Testpublic void test2() &#123;Employee emp &#x3D; new Employee(1001,&quot;Tom&quot;,23,5600);Supplier&lt;String&gt; sup1 &#x3D; () -&gt; emp.getName();System.out.println(sup1.get());System.out.println(&quot;*******************&quot;);Supplier&lt;String&gt; sup2 &#x3D; emp::getName;System.out.println(sup2.get());&#125;&#x2F;&#x2F; 情况二：类 :: 静态方法&#x2F;&#x2F;Comparator中的int compare(T t1,T t2)&#x2F;&#x2F;Integer中的int compare(T t1,T t2)@Testpublic void test3() &#123;Comparator&lt;Integer&gt; com1 &#x3D; (t1,t2) -&gt; Integer.compare(t1,t2);System.out.println(com1.compare(12,21));System.out.println(&quot;*******************&quot;);Comparator&lt;Integer&gt; com2 &#x3D; Integer::compare;System.out.println(com2.compare(12,3));&#125;&#x2F;&#x2F;Function中的R apply(T t)&#x2F;&#x2F;Math中的Long round(Double d)@Testpublic void test4() &#123;Function&lt;Double,Long&gt; func &#x3D; new Function&lt;Double, Long&gt;() &#123;@Overridepublic Long apply(Double d) &#123;return Math.round(d);&#125;&#125;;System.out.println(&quot;*******************&quot;);Function&lt;Double,Long&gt; func1 &#x3D; d -&gt; Math.round(d);System.out.println(func1.apply(12.3));System.out.println(&quot;*******************&quot;);Function&lt;Double,Long&gt; func2 &#x3D; Math::round;System.out.println(func2.apply(12.6));&#125;&#x2F;&#x2F; 情况三：类 :: 实例方法  (有难度)&#x2F;&#x2F; Comparator中的int comapre(T t1,T t2)&#x2F;&#x2F; String中的int t1.compareTo(t2)@Testpublic void test5() &#123;Comparator&lt;String&gt; com1 &#x3D; (s1,s2) -&gt; s1.compareTo(s2);System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));System.out.println(&quot;*******************&quot;);Comparator&lt;String&gt; com2 &#x3D; String :: compareTo;System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));&#125;&#x2F;&#x2F;BiPredicate中的boolean test(T t1, T t2);&#x2F;&#x2F;String中的boolean t1.equals(t2)@Testpublic void test6() &#123;BiPredicate&lt;String,String&gt; pre1 &#x3D; (s1,s2) -&gt; s1.equals(s2);System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;));System.out.println(&quot;*******************&quot;);BiPredicate&lt;String,String&gt; pre2 &#x3D; String :: equals;System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;));&#125;&#x2F;&#x2F; Function中的R apply(T t)&#x2F;&#x2F; Employee中的String getName();@Testpublic void test7() &#123;Employee employee &#x3D; new Employee(1001, &quot;Jerry&quot;, 23, 6000);Function&lt;Employee,String&gt; func1 &#x3D; e -&gt; e.getName();System.out.println(func1.apply(employee));System.out.println(&quot;*******************&quot;);Function&lt;Employee,String&gt; func2 &#x3D; Employee::getName;System.out.println(func2.apply(employee));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-构造器引用"><a href="#4-2-构造器引用" class="headerlink" title="4.2 构造器引用"></a>4.2 构造器引用</h3><p>当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。</p><p>格式：<code>类名::new</code></p><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ConstructorRefTest &#123;&#x2F;&#x2F;构造器引用    &#x2F;&#x2F;Supplier中的T get()    &#x2F;&#x2F;Employee的空参构造器：Employee()    @Test    public void test1()&#123;        Supplier&lt;Employee&gt; sup &#x3D; new Supplier&lt;Employee&gt;() &#123;            @Override            public Employee get() &#123;                return new Employee();            &#125;        &#125;;        System.out.println(&quot;*******************&quot;);        Supplier&lt;Employee&gt;  sup1 &#x3D; () -&gt; new Employee();        System.out.println(sup1.get());        System.out.println(&quot;*******************&quot;);        Supplier&lt;Employee&gt;  sup2 &#x3D; Employee :: new;        System.out.println(sup2.get());    &#125;&#x2F;&#x2F;Function中的R apply(T t)    @Test    public void test2()&#123;        Function&lt;Integer,Employee&gt; func1 &#x3D; id -&gt; new Employee(id);        Employee employee &#x3D; func1.apply(1001);        System.out.println(employee);        System.out.println(&quot;*******************&quot;);        Function&lt;Integer,Employee&gt; func2 &#x3D; Employee :: new;        Employee employee1 &#x3D; func2.apply(1002);        System.out.println(employee1);    &#125;&#x2F;&#x2F;BiFunction中的R apply(T t,U u)    @Test    public void test3()&#123;        BiFunction&lt;Integer,String,Employee&gt; func1 &#x3D; (id,name) -&gt; new Employee(id,name);        System.out.println(func1.apply(1001,&quot;Tom&quot;));        System.out.println(&quot;*******************&quot;);        BiFunction&lt;Integer,String,Employee&gt; func2 &#x3D; Employee :: new;        System.out.println(func2.apply(1002,&quot;Tom&quot;));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.java2;&#x2F;** * @author 尚硅谷-宋红康 邮箱：shkstart@126.com *&#x2F;public class Employee &#123;private int id;private String name;private int age;private double salary;public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id &#x3D; id;&#125;public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;public int getAge() &#123;return age;&#125;public void setAge(int age) &#123;this.age &#x3D; age;&#125;public double getSalary() &#123;return salary;&#125;public void setSalary(double salary) &#123;this.salary &#x3D; salary;&#125;public Employee() &#123;System.out.println(&quot;Employee().....&quot;);&#125;public Employee(int id) &#123;this.id &#x3D; id;System.out.println(&quot;Employee(int id).....&quot;);&#125;public Employee(int id, String name) &#123;this.id &#x3D; id;this.name &#x3D; name;&#125;public Employee(int id, String name, int age, double salary) &#123;this.id &#x3D; id;this.name &#x3D; name;this.age &#x3D; age;this.salary &#x3D; salary;&#125;@Overridepublic String toString() &#123;return &quot;Employee&#123;&quot; + &quot;id&#x3D;&quot; + id + &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age&#x3D;&quot; + age + &quot;, salary&#x3D;&quot; + salary + &#39;&#125;&#39;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-数组构造引用"><a href="#4-3-数组构造引用" class="headerlink" title="4.3 数组构造引用"></a>4.3 数组构造引用</h3><p>当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。</p><p>格式：<code>数组类型名::new</code></p><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;数组引用&#x2F;&#x2F;Function中的R apply(T t)@Testpublic void test4()&#123;    Function&lt;Integer,String[]&gt; func1 &#x3D; length -&gt; new String[length];    String[] arr1 &#x3D; func1.apply(5);    System.out.println(Arrays.toString(arr1));    System.out.println(&quot;*******************&quot;);    Function&lt;Integer,String[]&gt; func2 &#x3D; String[] :: new;    String[] arr2 &#x3D; func2.apply(10);    System.out.println(Arrays.toString(arr2));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-Java8新特性：强大的Stream-API"><a href="#5-Java8新特性：强大的Stream-API" class="headerlink" title="5. Java8新特性：强大的Stream API"></a>5. Java8新特性：强大的Stream API</h2><h3 id="5-1-说明"><a href="#5-1-说明" class="headerlink" title="5.1 说明"></a>5.1 说明</h3><ul><li>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</li><li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库<code>最好的补充</code>，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li><li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li></ul><h3 id="5-2-为什么要使用Stream-API"><a href="#5-2-为什么要使用Stream-API" class="headerlink" title="5.2 为什么要使用Stream API"></a>5.2 为什么要使用Stream API</h3><p>实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</p><h3 id="5-3-什么是Stream"><a href="#5-3-什么是Stream" class="headerlink" title="5.3 什么是Stream"></a>5.3 什么是Stream</h3><p>Stream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p><p>Stream 和 Collection 集合的区别：<strong>Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。</strong>前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p><p>注意：</p><p>①Stream 自己不会存储元素。</p><p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p><p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。</p><p>④ Stream一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。</p><h3 id="5-4-Stream的操作三个步骤"><a href="#5-4-Stream的操作三个步骤" class="headerlink" title="5.4 Stream的操作三个步骤"></a>5.4 Stream的操作三个步骤</h3><p><strong>1- 创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p><p><strong>2- 中间操作</strong><br>每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个<code>操作链</code>，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</p><p><strong>3- 终止操作(终端操作)</strong><br>终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</p><img src="../images/image-20220514180803311.png" alt="image-20220514180803311" style="zoom: 50%;" /><h4 id="5-4-1-创建Stream实例"><a href="#5-4-1-创建Stream实例" class="headerlink" title="5.4.1 创建Stream实例"></a>5.4.1 创建Stream实例</h4><p><strong>方式一：通过集合</strong></p><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p><ul><li><p>default Stream<E> stream() : 返回一个顺序流</p></li><li><p>default Stream<E> parallelStream() : 返回一个并行流</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test01()&#123;    List&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5);    &#x2F;&#x2F;JDK1.8中，Collection系列集合增加了方法    Stream&lt;Integer&gt; stream &#x3D; list.stream();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式二：通过数组</strong></p><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p><ul><li>static <T> Stream<T> stream(T[] array): 返回一个流</li><li>public static IntStream stream(int[] array)</li><li>public static LongStream stream(long[] array)</li><li>public static DoubleStream stream(double[] array)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test02()&#123;    String[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;&#125;;    Stream&lt;String&gt; stream &#x3D; Arrays.stream(arr); &#125;@Testpublic void test03()&#123;    int[] arr &#x3D; &#123;1,2,3,4,5&#125;;    IntStream stream &#x3D; Arrays.stream(arr);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式三：通过Stream的of()</strong></p><p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个流</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test04()&#123;    Stream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5);    stream.forEach(System.out::println);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式四：创建无限流(了解)</strong></p><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li><p>迭代<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) </p></li><li><p>生成<br>public static<T> Stream<T> generate(Supplier<T> s)</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 方式四：创建无限流@Testpublic void test05() &#123;&#x2F;&#x2F; 迭代&#x2F;&#x2F; public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final&#x2F;&#x2F; UnaryOperator&lt;T&gt; f)Stream&lt;Integer&gt; stream &#x3D; Stream.iterate(0, x -&gt; x + 2);stream.limit(10).forEach(System.out::println);&#x2F;&#x2F; 生成&#x2F;&#x2F; public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)Stream&lt;Double&gt; stream1 &#x3D; Stream.generate(Math::random);stream1.limit(10).forEach(System.out::println);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2-一系列中间操作"><a href="#5-4-2-一系列中间操作" class="headerlink" title="5.4.2 一系列中间操作"></a>5.4.2 一系列中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p><p>1-筛选与切片</p><table><thead><tr><th><strong>方   法</strong></th><th><strong>描   述</strong></th></tr></thead><tbody><tr><td><strong>filter(Predicatep)</strong></td><td>接收  Lambda ， 从流中排除某些元素</td></tr><tr><td><strong>distinct()</strong></td><td>筛选，通过流所生成元素的  hashCode() 和 equals() 去除重复元素</td></tr><tr><td><strong>limit(long maxSize)</strong></td><td>截断流，使其元素不超过给定数量</td></tr><tr><td><strong>skip(long n)</strong></td><td>跳过元素，返回一个扔掉了前  n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td></tr></tbody></table><p>2-映 射</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>map(Function f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr><td><strong>mapToDouble(ToDoubleFunction f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td></tr><tr><td><strong>mapToInt(ToIntFunction  f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  IntStream。</td></tr><tr><td><strong>mapToLong(ToLongFunction  f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  LongStream。</td></tr><tr><td><strong>flatMap(Function  f)</strong></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table><p>3-排序</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>sorted()</strong></td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td><strong>sorted(Comparator</strong> <strong>com)</strong></td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><p>代码举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stream;import org.junit.Test;import java.util.Arrays;import java.util.stream.Stream;public class StreamMiddleOperate &#123;@Test    public void test01()&#123;        &#x2F;&#x2F;1、创建Stream        Stream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5,6);        &#x2F;&#x2F;2、加工处理        &#x2F;&#x2F;过滤：filter(Predicate p)        &#x2F;&#x2F;把里面的偶数拿出来        &#x2F;*         * filter(Predicate p)         * Predicate是函数式接口，抽象方法：boolean test(T t)         *&#x2F;        stream &#x3D; stream.filter(t -&gt; t%2&#x3D;&#x3D;0);        &#x2F;&#x2F;3、终结操作：例如：遍历        stream.forEach(System.out::println);    &#125;    @Test    public void test02()&#123;        Stream.of(1,2,3,4,5,6)                .filter(t -&gt; t%2&#x3D;&#x3D;0)                .forEach(System.out::println);    &#125;    @Test    public void test03()&#123;        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)                .distinct()                .forEach(System.out::println);    &#125;    @Test    public void test04()&#123;        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)                .limit(3)                .forEach(System.out::println);    &#125;    @Test    public void test05()&#123;        Stream.of(1,2,2,3,3,4,4,5,2,3,4,5,6,7)                .distinct()  &#x2F;&#x2F;(1,2,3,4,5,6,7)                .filter(t -&gt; t%2!&#x3D;0) &#x2F;&#x2F;(1,3,5,7)                .limit(3)                .forEach(System.out::println);    &#125;    @Test    public void test06()&#123;        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)                .skip(5)                .forEach(System.out::println);    &#125;    @Test    public void test07()&#123;        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)                .skip(5)                .distinct()                .filter(t -&gt; t%3&#x3D;&#x3D;0)                .forEach(System.out::println);    &#125;    @Test    public void test08()&#123;        long count &#x3D; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)                .distinct()                .peek(System.out::println)  &#x2F;&#x2F;Consumer接口的抽象方法  void accept(T t)                .count();        System.out.println(&quot;count&#x3D;&quot;+count);    &#125;    @Test    public void test09()&#123;        &#x2F;&#x2F;希望能够找出前三个最大值，前三名最大的，不重复        Stream.of(11,2,39,4,54,6,2,22,3,3,4,54,54)                .distinct()                .sorted((t1,t2) -&gt; -Integer.compare(t1, t2))&#x2F;&#x2F;Comparator接口  int compare(T t1, T t2)                .limit(3)                .forEach(System.out::println);    &#125;    @Test    public void test10()&#123;        Stream.of(1,2,3,4,5)                .map(t -&gt; t+&#x3D;1)&#x2F;&#x2F;Function&lt;T,R&gt;接口抽象方法 R apply(T t)                .forEach(System.out::println);    &#125;    @Test    public void test11()&#123;        String[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;        Arrays.stream(arr)                .map(t-&gt;t.toUpperCase())                .forEach(System.out::println);    &#125;    @Test    public void test12()&#123;        String[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;        Arrays.stream(arr)                .flatMap(t -&gt; Stream.of(t.split(&quot;|&quot;)))&#x2F;&#x2F;Function&lt;T,R&gt;接口抽象方法 R apply(T t)  现在的R是一个Stream                .forEach(System.out::println);    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-3-终止操作"><a href="#5-4-3-终止操作" class="headerlink" title="5.4.3 终止操作"></a>5.4.3 终止操作</h4><ul><li><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p></li><li><p>流进行了终止操作后，不能再次使用。</p></li></ul><p>1-匹配与查找</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>allMatch(Predicate  p)</strong></td><td>检查是否匹配所有元素</td></tr><tr><td>**anyMatch(Predicate  p)  **</td><td>检查是否至少匹配一个元素</td></tr><tr><td><strong>noneMatch(Predicate</strong>  <strong>p)</strong></td><td>检查是否没有匹配所有元素</td></tr><tr><td><strong>findFirst()</strong></td><td>返回第一个元素</td></tr><tr><td><strong>findAny()</strong></td><td>返回当前流中的任意元素</td></tr><tr><td><strong>count()</strong></td><td>返回流中元素总数</td></tr><tr><td><strong>max(Comparator c)</strong></td><td>返回流中最大值</td></tr><tr><td><strong>min(Comparator c)</strong></td><td>返回流中最小值</td></tr><tr><td><strong>forEach(Consumer c)</strong></td><td>内部迭代(使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了)</td></tr></tbody></table><p>2-归约</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>reduce(T  identity, BinaryOperator b)</strong></td><td>可以将流中元素反复结合起来，得到一个值。返回  T</td></tr><tr><td><strong>reduce(BinaryOperator  b)</strong></td><td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td></tr></tbody></table><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p><p>3-收集</p><table><thead><tr><th><strong>方   法</strong></th><th><strong>描   述</strong></th></tr></thead><tbody><tr><td><strong>collect(Collector  c)</strong></td><td>将流转换为其他形式。接收一个  Collector接口的实现，<br>用于给Stream中元素做汇总的方法</td></tr></tbody></table><p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p><p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>toList</strong></td><td>Collector&lt;T, ?, List<T>&gt;</td><td>把流中元素收集到List</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Employee&gt; emps&#x3D; list.stream().collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>toSet</strong></td><td>Collector&lt;T, ?, Set<T>&gt;</td><td>把流中元素收集到Set</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">Set&lt;Employee&gt; emps&#x3D; list.stream().collect(Collectors.toSet());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>toCollection</strong></td><td>Collector&lt;T, ?, C&gt;</td><td>把流中元素收集到创建的集合</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection&lt;Employee&gt; emps &#x3D;list.stream().collect(Collectors.toCollection(ArrayList::new));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>counting</strong></td><td>Collector&lt;T, ?, Long&gt;</td><td>计算流中元素的个数</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">long count &#x3D; list.stream().collect(Collectors.counting());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>summingInt</strong></td><td>Collector&lt;T, ?, Integer&gt;</td><td>对流中元素的整数属性求和</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">int total&#x3D;list.stream().collect(Collectors.summingInt(Employee::getSalary));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>averagingInt</strong></td><td>Collector&lt;T, ?, Double&gt;</td><td>计算流中元素Integer属性的平均值</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">double avg &#x3D; list.stream().collect(Collectors.averagingInt(Employee::getSalary));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>summarizingInt</strong></td><td>Collector&lt;T, ?, IntSummaryStatistics&gt;</td><td>收集流中Integer属性的统计值。如：平均值</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">int SummaryStatisticsiss&#x3D; list.stream().collect(Collectors.summarizingInt(Employee::getSalary));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>joining</strong></td><td>Collector&lt;CharSequence, ?, String&gt;</td><td>连接流中每个字符串</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str&#x3D; list.stream().map(Employee::getName).collect(Collectors.joining());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>maxBy</strong></td><td>Collector&lt;T, ?, Optional<T>&gt;</td><td>根据比较器选择最大值</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional&lt;Emp&gt;max&#x3D; list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>minBy</strong></td><td>Collector&lt;T, ?, Optional<T>&gt;</td><td>根据比较器选择最小值</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional&lt;Emp&gt; min &#x3D; list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>reducing</strong></td><td>Collector&lt;T, ?, Optional<T>&gt;</td><td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">int total&#x3D;list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>collectingAndThen</strong></td><td>Collector&lt;T,A,RR&gt;</td><td>包裹另一个收集器，对其结果转换函数</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">int how&#x3D; list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>groupingBy</strong></td><td>Collector&lt;T, ?, Map&lt;K, List<T>&gt;&gt;</td><td>根据某属性值对流分组，属性为K，结果为V</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map&#x3D; list.stream().collect(Collectors.groupingBy(Employee::getStatus));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>partitioningBy</strong></td><td>Collector&lt;T, ?, Map&lt;Boolean, List<T>&gt;&gt;</td><td>根据true或false进行分区</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd &#x3D; list.stream().collect(Collectors.partitioningBy(Employee::getManage));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stream;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;import java.util.stream.Stream;import org.junit.Test;public class StreamEndding &#123;    @Test    public void test01()&#123;        Stream.of(1,2,3,4,5)                .forEach(System.out::println);    &#125;    @Test    public void test02()&#123;        long count &#x3D; Stream.of(1,2,3,4,5)                .count();        System.out.println(&quot;count &#x3D; &quot; + count);    &#125;    @Test    public void test03()&#123;        boolean result &#x3D; Stream.of(1,3,5,7,9)                .allMatch(t -&gt; t%2!&#x3D;0);        System.out.println(result);    &#125;@Test    public void test04()&#123;        boolean result &#x3D; Stream.of(1,3,5,7,9)                .anyMatch(t -&gt; t%2&#x3D;&#x3D;0);        System.out.println(result);    &#125;@Test    public void test05()&#123;        Optional&lt;Integer&gt; opt &#x3D; Stream.of(1,3,5,7,9).findFirst();        System.out.println(opt);    &#125;@Test    public void test06()&#123;        Optional&lt;Integer&gt; opt &#x3D; Stream.of(1,2,3,4,5,7,9)                .filter(t -&gt; t%3&#x3D;&#x3D;0)                .findFirst();        System.out.println(opt);    &#125;@Test    public void test07()&#123;        Optional&lt;Integer&gt; opt &#x3D; Stream.of(1,2,4,5,7,8)                .filter(t -&gt; t%3&#x3D;&#x3D;0)                .findFirst();        System.out.println(opt);    &#125;    @Test    public void test08()&#123;        Optional&lt;Integer&gt; max &#x3D; Stream.of(1,2,4,5,7,8)                .max((t1,t2) -&gt; Integer.compare(t1, t2));        System.out.println(max);    &#125;    @Test    public void test09()&#123;        Integer reduce &#x3D; Stream.of(1,2,4,5,7,8)                .reduce(0, (t1,t2) -&gt; t1+t2);&#x2F;&#x2F;BinaryOperator接口   T apply(T t1, T t2)        System.out.println(reduce);    &#125;    @Test    public void test10()&#123;        Optional&lt;Integer&gt; max &#x3D; Stream.of(1,2,4,5,7,8)                .reduce((t1,t2) -&gt; t1&gt;t2?t1:t2);&#x2F;&#x2F;BinaryOperator接口   T apply(T t1, T t2)        System.out.println(max);    &#125;    @Test    public void test11()&#123;        List&lt;Integer&gt; list &#x3D; Stream.of(1,2,4,5,7,8)                .filter(t -&gt; t%2&#x3D;&#x3D;0)                .collect(Collectors.toList());        System.out.println(list);    &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5-Java9新增API"><a href="#5-5-Java9新增API" class="headerlink" title="5.5 Java9新增API"></a>5.5 Java9新增API</h3><p><strong>新增1：Stream实例化方法</strong></p><p>ofNullable()的使用：</p><p>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;报NullPointerException&#x2F;&#x2F;Stream&lt;Object&gt; stream1 &#x3D; Stream.of(null);&#x2F;&#x2F;System.out.println(stream1.count());&#x2F;&#x2F;不报异常，允许通过Stream&lt;String&gt; stringStream &#x3D; Stream.of(&quot;AA&quot;, &quot;BB&quot;, null);System.out.println(stringStream.count());&#x2F;&#x2F;3&#x2F;&#x2F;不报异常，允许通过List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;AA&quot;);list.add(null);System.out.println(list.stream().count());&#x2F;&#x2F;2&#x2F;&#x2F;ofNullable()：允许值为nullStream&lt;Object&gt; stream1 &#x3D; Stream.ofNullable(null);System.out.println(stream1.count());&#x2F;&#x2F;0Stream&lt;String&gt; stream &#x3D; Stream.ofNullable(&quot;hello world&quot;);System.out.println(stream.count());&#x2F;&#x2F;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>iterator()重载的使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;原来的控制终止方式：Stream.iterate(1,i -&gt; i + 1).limit(10).forEach(System.out::println);&#x2F;&#x2F;现在的终止方式：Stream.iterate(1,i -&gt; i &lt; 100,i -&gt; i + 1).forEach(System.out::println);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-练习"><a href="#5-6-练习" class="headerlink" title="5.6 练习"></a>5.6 练习</h3><p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以<br>下若干操作步骤：</p><ol><li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li><li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li><li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li><li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li><li>将两个队伍合并为一个队伍；存储到一个新集合中。</li><li>根据姓名创建 Person 对象；存储到一个新集合中。</li><li>打印整个队伍的Person对象信息。</li></ol><p>Person 类的代码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;    private String name;    public Person() &#123;&#125;    public Person(String name) &#123;        this.name &#x3D; name;    &#125;        public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;name&#x3D;&#39;&quot; + name + &quot;&#39;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个队伍（集合）的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;       &#x2F;&#x2F;第一支队伍        ArrayList&lt;String&gt; one &#x3D; new ArrayList&lt;&gt;();        one.add(&quot;迪丽热巴&quot;);        one.add(&quot;宋远桥&quot;);        one.add(&quot;苏星河&quot;);        one.add(&quot;石破天&quot;);        one.add(&quot;石中玉&quot;);        one.add(&quot;老子&quot;);        one.add(&quot;庄子&quot;);        one.add(&quot;洪七公&quot;);        &#x2F;&#x2F;第二支队伍        ArrayList&lt;String&gt; two &#x3D; new ArrayList&lt;&gt;();        two.add(&quot;古力娜扎&quot;);        two.add(&quot;张无忌&quot;);        two.add(&quot;赵丽颖&quot;);        two.add(&quot;张三丰&quot;);        two.add(&quot;尼古拉斯赵四&quot;);        two.add(&quot;张天爱&quot;);        two.add(&quot;张二狗&quot;);    &#x2F;&#x2F; ....编写代码完成题目要求     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考答案：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;       &#x2F;&#x2F;第一支队伍        ArrayList&lt;String&gt; one &#x3D; new ArrayList&lt;&gt;();        one.add(&quot;迪丽热巴&quot;);        one.add(&quot;宋远桥&quot;);        one.add(&quot;苏星河&quot;);        one.add(&quot;石破天&quot;);        one.add(&quot;石中玉&quot;);        one.add(&quot;老子&quot;);        one.add(&quot;庄子&quot;);        one.add(&quot;洪七公&quot;);            &#x2F;&#x2F;第二支队伍        ArrayList&lt;String&gt; two &#x3D; new ArrayList&lt;&gt;();        two.add(&quot;古力娜扎&quot;);        two.add(&quot;张无忌&quot;);        two.add(&quot;赵丽颖&quot;);        two.add(&quot;张三丰&quot;);        two.add(&quot;尼古拉斯赵四&quot;);        two.add(&quot;张天爱&quot;);        two.add(&quot;张二狗&quot;);        &#x2F;&#x2F; 第一个队伍只要名字为3个字的成员姓名；        &#x2F;&#x2F; 第一个队伍筛选之后只要前3个人；        Stream&lt;String&gt; streamOne &#x3D; one.stream().filter(s ‐&gt; s.length() &#x3D;&#x3D; 3).limit(3);            &#x2F;&#x2F; 第二个队伍只要姓张的成员姓名；        &#x2F;&#x2F; 第二个队伍筛选之后不要前2个人；        Stream&lt;String&gt; streamTwo &#x3D; two.stream().filter(s ‐&gt; s.startsWith(&quot;张&quot;)).skip(2);            &#x2F;&#x2F; 将两个队伍合并为一个队伍；        &#x2F;&#x2F; 根据姓名创建Person对象；        &#x2F;&#x2F; 打印整个队伍的Person对象信息。        Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA快捷键</title>
      <link href="/2023/02/10/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/02/10/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-IDEA-的日常快捷键"><a href="#1-IDEA-的日常快捷键" class="headerlink" title="1. IDEA 的日常快捷键"></a>1. IDEA 的日常快捷键</h1><blockquote><p>通用型</p></blockquote><table><thead><tr><th align="center">说明</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">复制代码-copy</td><td align="center">ctrl + c</td></tr><tr><td align="center">粘贴-paste</td><td align="center">ctrl + v</td></tr><tr><td align="center">剪切-cut</td><td align="center">ctrl + x</td></tr><tr><td align="center">撤销-undo</td><td align="center">ctrl + z</td></tr><tr><td align="center">反撤销-redo</td><td align="center">ctrl + shift + z</td></tr><tr><td align="center">保存-save all</td><td align="center">ctrl + s</td></tr><tr><td align="center">全选-select all</td><td align="center">ctrl + a</td></tr></tbody></table><blockquote><p>提高编写速度(上)</p></blockquote><table><thead><tr><th align="center">说明</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">智能提示-edit</td><td align="center">alt + enter</td></tr><tr><td align="center">提示代码模板-insert live template</td><td align="center">ctrl+j</td></tr><tr><td align="center">使用xx块环绕-surround with …</td><td align="center">ctrl+alt+t</td></tr><tr><td align="center">调出生成getter&#x2F;setter&#x2F;构造器等结构-generate …</td><td align="center">alt+insert</td></tr><tr><td align="center">自动生成返回值变量-introduce variable …</td><td align="center">ctrl+alt+v</td></tr><tr><td align="center">复制指定行的代码-duplicate line or selection</td><td align="center">ctrl+d</td></tr><tr><td align="center">删除指定行的代码-delete line</td><td align="center">ctrl+y</td></tr><tr><td align="center">切换到下一行代码空位-start new line</td><td align="center">shift + enter</td></tr><tr><td align="center">切换到上一行代码空位-start new line before current</td><td align="center">ctrl +alt+ enter</td></tr><tr><td align="center">向上移动代码-move statement up</td><td align="center">ctrl+shift+↑</td></tr><tr><td align="center">向下移动代码-move statement down</td><td align="center">ctrl+shift+↓</td></tr><tr><td align="center">向上移动一行-move line up</td><td align="center">alt+shift+↑</td></tr><tr><td align="center">向下移动一行-move line down</td><td align="center">alt+shift+↓</td></tr><tr><td align="center">方法的形参列表提醒-parameter info</td><td align="center">ctrl+p</td></tr></tbody></table><blockquote><p>提高编写速度(下)</p></blockquote><table><thead><tr><th align="center">说明</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">批量修改指定的变量名、方法名、类名等-rename</td><td align="center">shift+f6</td></tr><tr><td align="center">抽取代码重构方法-extract method …</td><td align="center">ctrl+alt+m</td></tr><tr><td align="center">重写父类的方法-override methods …</td><td align="center">ctrl+o</td></tr><tr><td align="center">实现接口的方法-implements methods …</td><td align="center">ctrl+i</td></tr><tr><td align="center">选中的结构的大小写的切换-toggle case</td><td align="center">ctrl+shift+u</td></tr><tr><td align="center">批量导包-optimize imports</td><td align="center">ctrl+alt+o</td></tr></tbody></table><blockquote><p>类结构、查找和查看源码</p></blockquote><table><thead><tr><th align="center">说明</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">如何查看源码-go to class…</td><td align="center">ctrl + 选中指定的结构 或 ctrl+n</td></tr><tr><td align="center">显示当前类结构，支持搜索指定的方法、属性等-file structure</td><td align="center">ctrl+f12</td></tr><tr><td align="center">回到前一个编辑的页面-back</td><td align="center">ctrl+alt+←</td></tr><tr><td align="center">进入到下一个编辑的页面-forward</td><td align="center">ctrl+alt+→</td></tr><tr><td align="center">打开的类文件之间切换-select previous&#x2F;next tab</td><td align="center">alt+←&#x2F;→</td></tr><tr><td align="center">光标选中指定的类，查看继承树结构-Type Hierarchy</td><td align="center">ctrl+h</td></tr><tr><td align="center">查看方法文档-quick documentation</td><td align="center">ctrl+q</td></tr><tr><td align="center">类的UML关系图-show uml popup</td><td align="center">ctrl+alt+u</td></tr><tr><td align="center">定位某行-go to line&#x2F;column</td><td align="center">ctrl+g</td></tr><tr><td align="center">回溯变量或方法的来源-go to implementation(s)</td><td align="center">ctrl+alt+b</td></tr><tr><td align="center">折叠方法实现-collapse all</td><td align="center">ctrl+shift+ -</td></tr><tr><td align="center">展开方法实现-expand all</td><td align="center">ctrl+shift+ +</td></tr></tbody></table><blockquote><p>查找、替换与关闭</p></blockquote><table><thead><tr><th align="center">说明</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">查找指定的结构</td><td align="center">ctlr+f</td></tr><tr><td align="center">快速查找：选中的Word快速定位到下一个-find next</td><td align="center">ctrl+l</td></tr><tr><td align="center">查找与替换-replace</td><td align="center">ctrl+r</td></tr><tr><td align="center">直接定位到当前行的首位-move caret to line start</td><td align="center">home</td></tr><tr><td align="center">直接定位到当前行的末位 -move caret to line end</td><td align="center">end</td></tr><tr><td align="center">查询当前元素在当前文件中的引用，然后按 F3 可以选择</td><td align="center">ctrl+f7</td></tr><tr><td align="center">全项目搜索文本-find in path …</td><td align="center">ctrl+shift+f</td></tr><tr><td align="center">关闭当前窗口-close</td><td align="center">ctrl+f4</td></tr></tbody></table><blockquote><p>调整格式</p></blockquote><table><thead><tr><th align="center">说明</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">格式化代码-reformat code</td><td align="center">ctrl+alt+l</td></tr><tr><td align="center">使用单行注释-comment with line comment</td><td align="center">ctrl + &#x2F;</td></tr><tr><td align="center">使用&#x2F;取消多行注释-comment with block comment</td><td align="center">ctrl + shift + &#x2F;</td></tr><tr><td align="center">选中数行，整体往后移动-tab</td><td align="center">tab</td></tr><tr><td align="center">选中数行，整体往前移动-prev tab</td><td align="center">shift + tab</td></tr></tbody></table><h1 id="2-Debug快捷键"><a href="#2-Debug快捷键" class="headerlink" title="2. Debug快捷键"></a>2. Debug快捷键</h1><table><thead><tr><th align="center">说明</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">单步调试（不进入函数内部）- step over</td><td align="center">F8</td></tr><tr><td align="center">单步调试（进入函数内部）- step into</td><td align="center">F7</td></tr><tr><td align="center">强制单步调试（进入函数内部） - force step into</td><td align="center">alt+shift+f7</td></tr><tr><td align="center">选择要进入的函数 - smart step into</td><td align="center">shift + F7</td></tr><tr><td align="center">跳出函数 - step out</td><td align="center">shift + F8</td></tr><tr><td align="center">运行到断点 - run to cursor</td><td align="center">alt + F9</td></tr><tr><td align="center">继续执行，进入下一个断点或执行完程序 - resume program</td><td align="center">F9</td></tr><tr><td align="center">停止 - stop</td><td align="center">Ctrl+F2</td></tr><tr><td align="center">查看断点 - view breakpoints</td><td align="center">Ctrl+Shift+F8</td></tr><tr><td align="center">关闭 - close</td><td align="center">Ctrl+F4</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/02/09/Git/"/>
      <url>/2023/02/09/Git/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><blockquote><p>优势</p></blockquote><ul><li>大部分操作在本地完成</li><li>完整性保证</li><li>尽可能添加数据而不是删除或修改数据</li><li>分支操作非常快捷流畅</li><li>与 Linux 命令全面兼容</li></ul><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><h1 id="2-Git的安装"><a href="#2-Git的安装" class="headerlink" title="2. Git的安装"></a>2. Git的安装</h1><p>Git 各平台安装包下载地址为：<a href="http://git-scm.com![image-20201019142729630](C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019142729630.png)">http://git-scm.com![image-20201019142729630](C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019142729630.png)</a></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019142815118.png" alt="image-20201019142815118"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019142851974.png" alt="image-20201019142851974"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019142910638.png" alt="image-20201019142910638"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019143008030.png" alt="image-20201019143008030"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019143032595.png" alt="image-20201019143032595"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019143054669.png" alt="image-20201019143054669"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019143108158.png" alt="image-20201019143108158"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019143119699.png" alt="image-20201019143119699"></p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019143138813.png" alt="image-20201019143138813"></p><h1 id="3-Git-配置"><a href="#3-Git-配置" class="headerlink" title="3. Git 配置"></a>3. Git 配置</h1><p>配置个人的用户名称和电子邮件地址（这里的设置的签名和登录的远程仓库的账号、密码没有任何关系，只是为了区分是谁写的）：</p><ul><li>项目级别 &#x2F; 仓库级别：仅在当前本地仓库范围有效（保存位置：.&#x2F;git&#x2F;config 文件）<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config user.name &quot;rqq&quot; # 用户名$ git config user.email test@qq.com# 邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>系统用户级别：登录当前操作系统的用户范围（保存位置在：~&#x2F;.gitconfig文件）<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config --global user.name &quot;rqq&quot; # 用户名$ git config --global user.email test@qq.com# 邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>查看配置信息</strong></p><p>要检查已有的配置信息，可以使用 git config –list 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config --global --list # 查看系统用户级别的配置...user.name&#x3D;rqquser.email&#x3D;test@qq.com$ git config --list# 项目级别...user.name&#x3D;rqquser.email&#x3D;test@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-Git-基本操作"><a href="#4-Git-基本操作" class="headerlink" title="4. Git 基本操作"></a>4. Git 基本操作</h1><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong>，后面我们会详细介绍。</p><p><img src="C:\Users\dawncoody\AppData\Roaming\Typora\typora-user-images\image-20201019153835539.png" alt="image-20201019153835539"></p><p><strong>说明：</strong></p><ul><li>workspace：工作区</li><li>staging area：暂存区&#x2F;缓存区</li><li>local repository：或本地仓库</li><li>remote repository：远程仓库</li></ul><h2 id="4-1创建本地仓库和提交"><a href="#4-1创建本地仓库和提交" class="headerlink" title="4.1创建本地仓库和提交"></a>4.1创建本地仓库和提交</h2><p>一个简单的操作步骤：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git init  # 本地库初始化$ git add [file name]  #指定文件$ git add . #所有$ git commit -m &quot;commit message&quot; [file name] # 提交暂存区内容到仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>git init - 初始化仓库。</li><li>git add . - 添加文件到暂存区。</li><li>git add [file name] -指定文件添加到暂存区</li><li>git commit - 将暂存区内容添加到仓库中</li></ul><p>查看状态工作区、暂存区状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-2查看-commit-历史记录"><a href="#4-2查看-commit-历史记录" class="headerlink" title="4.2查看 commit 历史记录"></a>4.2查看 commit 历史记录</h2><p><code>git log</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git logcommit e851d3991f39a5d11e173c3d4ca2f82dc838d08b (HEAD -&gt; master)Author: dawncoody &lt;dawntruecool@gmail.com&gt;Date:   Mon Oct 19 18:29:55 2020 +0800    三次啦commit 5f37a69eafcf6fa593bc1009eed167e81ce8fd75Author: dawncoody &lt;dawntruecool@gmail.com&gt;Date:   Mon Oct 19 18:25:12 2020 +0800    第二次提交commit ed22de35469f0199298d3e1189f6004bb597b796Author: dawncoody &lt;dawntruecool@gmail.com&gt;Date:   Mon Oct 19 18:22:12 2020 +0800    第一次提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为用 git log 显示的东西太多，所以很容易经常需要多屏显示</p><p>多屏显示的控制方式：</p><p><strong>空格向下翻页 b向上翻页 q退出</strong></p><p>可以对 log 简洁显示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git log --pretty&#x3D;onelinee851d3991f39a5d11e173c3d4ca2f82dc838d08b (HEAD -&gt; master) 三次啦5f37a69eafcf6fa593bc1009eed167e81ce8fd75 第二次提交ed22de35469f0199298d3e1189f6004bb597b796 第一次提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更简洁的方式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git log --onelinee851d39 (HEAD -&gt; master) 三次啦5f37a69 第二次提交ed22de3 第一次提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看到移动到当前版本所需要的步数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># HEAD@&#123;移动到当前版本所需要的步数&#125;  $ git refloge851d39 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: 三次啦5f37a69 HEAD@&#123;1&#125;: commit: 第二次提交ed22de3 HEAD@&#123;2&#125;: commit: 第一次提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-前进和后退"><a href="#4-3-前进和后退" class="headerlink" title="4.3 前进和后退"></a>4.3 前进和后退</h2><ul><li><p>基于索引值<code>推荐</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git reset --hard 指针位置# 例子：git reset --hard e851d39 #回到这个状态(hash值)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <strong>^</strong> 符号<code>只能后退</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git reset --hard HEAD^# 例子：git reset --hard HEAD^^# 注意：几个 ^ 表示后退几步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用 <strong>~</strong> 符号<code>只能后退</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git reset --hard HEAD~n # 一个 ^ 表示后退一步，n 个表示后退 n 步# 例子：git reset --hard HEAD~3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p>reset 的三个参数比较</p></blockquote><pre class="line-numbers language-none"><code class="language-none">--soft 参数:- 仅仅本地仓库移动 HEAD 指针--mixed 参数:- 在本地仓库移动 HEAD 指针- 重置暂存区--hard 参数- 在本地仓库移动 HEAD 指针- 重置暂存区- 重置工作区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-删除文件并找回"><a href="#4-4-删除文件并找回" class="headerlink" title="4.4 删除文件并找回"></a>4.4 删除文件并找回</h2><ul><li>前提：删除前，文件存存在时的状态提交到了本地库</li><li>操作：<code>git reset --hard [指针位置]</code><ul><li>删除操作已近提交到本地库：指针指向历史记录</li><li>删除操作尚未提交到本地库：指针使用 HEAD</li></ul></li></ul><p>撤销错误添加到暂存区里的文件，可以输入以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git rm --cache 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-5-比较文件差异"><a href="#4-5-比较文件差异" class="headerlink" title="4.5 比较文件差异"></a>4.5 比较文件差异</h2><ul><li><p>将工作区走中的文件和暂存区进行比较</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git diff [文件名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将工作区中的文件和本地库历史记录比较</p></li></ul>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git diff [本地仓库历史版本] [文件名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>不带文件名比较多个文件</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git diff [本地仓库历史版本]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="4-6-分支管理"><a href="#4-6-分支管理" class="headerlink" title="4.6 分支管理"></a>4.6 分支管理</h2><blockquote><p>什么是分支管理</p></blockquote><ul><li>在版本控制过程中，使用多条线同时推动多个任务</li></ul><blockquote><p>分支的好处</p></blockquote><ul><li>同时推进多个功能的开始，提高开发效率</li><li>各个分支在开发过程中如果某一个分支开发失败，不会对其他分支有任何影响</li></ul><blockquote><p>分支操作</p></blockquote><ul><li><p>创建分支</p><p>&#x3D;&#x3D;<code>git branch</code>&#x3D;&#x3D;</p></li><li><p>查看分支</p></li></ul><p>  &#x3D;&#x3D;<code>git branch -v</code>&#x3D;&#x3D;</p><ul><li><p>切换分支</p><p>&#x3D;&#x3D;<code>git checkout [分支名]</code>&#x3D;&#x3D;</p></li><li><p>合并分支</p><ul><li><p>第一步：切换到接受修改的分支（被合并，增加新内容）上</p><p><code>git checkout[被合并的分支名]</code></p></li><li><p>第二步：执行 <strong>merge</strong></p><p>&#x3D;&#x3D;<code>git merge [有新内容的分支名]</code>&#x3D;&#x3D;</p></li><li><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git checkout -b 分支名 # 创建分支并直接切换到该分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>删除分支</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git branch -d 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>解决冲突(当两个人对都对这个文件有修改的时候，就需要手动解决了)</p></li><li><p>第一步：编辑文件，删除特殊符号</p></li><li><p>第二步：把文件修改到满意程度，保存退出</p></li><li><p>第三步：git add [文件名]</p></li><li><p>第四步：git commit -m “日志信息”(&#x3D;&#x3D;<strong>注意：此时commit一定不能带文件名</strong>&#x3D;&#x3D;)</p></li></ul><h1 id="5-将本地仓库推送到远程仓库-Github"><a href="#5-将本地仓库推送到远程仓库-Github" class="headerlink" title="5 将本地仓库推送到远程仓库(Github)"></a>5 将本地仓库推送到远程仓库(Github)</h1><blockquote><p>创建远程库地址别名</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git remote -v # 查看远程地址别名$ git remote add 别名(一般用origin) 远程地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>删除指定的远程仓库</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>修改远程仓库地址</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git remote set-url origin &lt;remote-url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>推送</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git push 别名 分支名$ git push -u 别名 分支名# -u指定默认主机<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>克隆</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git clone [远程地址]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>完整的把远程库下载到本地</li><li>创建 origin 远程地址别名</li><li>初始化本地库</li></ul><blockquote><p>拉取</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git pull[远程仓库地址] [远程分支名]$ git fetch[远程仓库地址别名] [远程分支名]$ git merge[远程库地址别名&#x2F;远程分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>pull &#x3D; fetch + merge</li></ul><blockquote><p>解决冲突</p></blockquote><p>经常团队开发的时候都会对远程仓库进行修改，如果两个都对该仓库有修改，会发生冲突，需要解决冲突。</p><ul><li>如果不是基于 GitHub 远程库的最新版本，不能推送，必须先拉取。</li><li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word常用快捷键</title>
      <link href="/2023/02/09/Word%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/02/09/Word%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="对段落进行对齐和格式设置"><a href="#对段落进行对齐和格式设置" class="headerlink" title="对段落进行对齐和格式设置"></a>对段落进行对齐和格式设置</h3><table><thead><tr><th align="left">若要</th><th align="left">按</th></tr></thead><tbody><tr><td align="left">将段落居中。</td><td align="left">Ctrl+E</td></tr><tr><td align="left">使段落两端对齐。</td><td align="left">Ctrl+J</td></tr><tr><td align="left">将段落左对齐。</td><td align="left">Ctrl+L</td></tr><tr><td align="left">将段落右对齐。</td><td align="left">Ctrl+R</td></tr><tr><td align="left">缩进段落。</td><td align="left">Ctrl+M</td></tr><tr><td align="left">删除段落缩进。</td><td align="left">Ctrl+Shift+M</td></tr><tr><td align="left">创建悬挂缩进。</td><td align="left">Ctrl+T</td></tr><tr><td align="left">删除悬挂缩进。</td><td align="left">Ctrl+Shift+T</td></tr><tr><td align="left">删除段落格式。</td><td align="left">Ctrl+Q</td></tr><tr><td align="left">对段落应用单倍行距。</td><td align="left">Ctrl+1</td></tr><tr><td align="left">对段落应用双倍行距。</td><td align="left">Ctrl+2</td></tr><tr><td align="left">对段落应用 1.5 行距。</td><td align="left">Ctrl+5</td></tr><tr><td align="left">在段落之前添加或删除空格。</td><td align="left">Ctrl+0（零）</td></tr><tr><td align="left">启用自动格式。</td><td align="left">Ctrl+Alt+K</td></tr><tr><td align="left">应用” <strong>普通”</strong> 样式。</td><td align="left">Ctrl+Shift+N</td></tr><tr><td align="left">应用” <strong>标题 1”</strong> 样式。</td><td align="left">Ctrl+Alt+1</td></tr><tr><td align="left">应用” <strong>标题 2”</strong> 样式。</td><td align="left">Ctrl+Alt+2</td></tr><tr><td align="left">应用” <strong>标题 3”</strong> 样式。</td><td align="left">Ctrl+Alt+3</td></tr><tr><td align="left">显示” <strong>应用样式”</strong> 任务窗格。</td><td align="left">Ctrl+Shift+S</td></tr><tr><td align="left">显示” <strong>样式”</strong> 任务窗格。</td><td align="left">Ctrl+Alt+Shift+S</td></tr></tbody></table><h3 id="设置字符格式"><a href="#设置字符格式" class="headerlink" title="设置字符格式"></a>设置字符格式</h3><table><thead><tr><th align="left">若要</th><th align="left">按</th></tr></thead><tbody><tr><td align="left">显示<strong>“字体”</strong>对话框。</td><td align="left">Ctrl+D Ctrl+Shift+F</td></tr><tr><td align="left">增大字号。</td><td align="left">Ctrl+Shift+右尖括号 (&gt;)</td></tr><tr><td align="left">减小字号。</td><td align="left">Ctrl+Shift+左尖括号 (&lt;)</td></tr><tr><td align="left">逐磅增大字号。</td><td align="left">Ctrl+右方括号 (])</td></tr><tr><td align="left">逐磅减小字号。</td><td align="left">Ctrl+左中括号 ([)</td></tr><tr><td align="left">在大写、小写和标题大小写之间切换文本。</td><td align="left">Shift+F3</td></tr><tr><td align="left">将文本更改为全部大写。</td><td align="left">Ctrl+Shift+A</td></tr><tr><td align="left">隐藏所选文本。</td><td align="left">Ctrl+Shift+H</td></tr><tr><td align="left">应用加粗格式。</td><td align="left">Ctrl+B</td></tr><tr><td align="left">应用下划线格式。</td><td align="left">Ctrl+U</td></tr><tr><td align="left">对单词应用下划线格式，但不应用空格。</td><td align="left">Ctrl+Shift+W</td></tr><tr><td align="left">应用双下划线格式。</td><td align="left">Ctrl+Shift+D</td></tr><tr><td align="left">应用倾斜格式。</td><td align="left">Ctrl+I</td></tr><tr><td align="left">应用小型大写格式。</td><td align="left">Ctrl+Shift+K</td></tr><tr><td align="left">应用下标格式。</td><td align="left">Ctrl+等号 ( &#x3D; )</td></tr><tr><td align="left">应用上标格式。</td><td align="left">Ctrl+Shift+加号 (+)</td></tr><tr><td align="left">删除手动设置的字符格式。</td><td align="left">Ctrl+Spacebar</td></tr><tr><td align="left">将所选文本更改为”符号”字体。</td><td align="left">Ctrl+Shift+Q</td></tr></tbody></table><h3 id="创建文档大纲"><a href="#创建文档大纲" class="headerlink" title="创建文档大纲"></a>创建文档大纲</h3><p>这些快捷方式仅在文档位于”大纲”视图中 <strong>时</strong> 适用。</p><table><thead><tr><th align="left">执行的操作</th><th align="left">按</th></tr></thead><tbody><tr><td align="left">提升段落级别。</td><td align="left">Alt+Shift+向左键</td></tr><tr><td align="left">降低段落级别。</td><td align="left">Alt+Shift+向右键</td></tr><tr><td align="left">将段落降级为正文文本。</td><td align="left">Ctrl+Shift+N</td></tr><tr><td align="left">上移所选段落。</td><td align="left">Alt+Shift+向上箭头键</td></tr><tr><td align="left">下移所选段落。</td><td align="left">Alt+Shift+向下键</td></tr><tr><td align="left">展开标题下的文本。</td><td align="left">Alt+Shift+加号 (+)</td></tr><tr><td align="left">折叠标题下的文本。</td><td align="left">Alt+Shift+减号 (-)</td></tr><tr><td align="left">扩展或折叠所有文本或标题。</td><td align="left">Alt+Shift+A</td></tr><tr><td align="left">隐藏或显示字符格式。</td><td align="left">数字键盘 (上的正斜) (&#x2F;)</td></tr><tr><td align="left">在显示第一行正文文本和显示所有正文文本之间切换。</td><td align="left">Alt+Shift+L</td></tr><tr><td align="left">显示具有”标题 <strong>1”样式的所有</strong> 标题。</td><td align="left">Alt+Shift+1</td></tr><tr><td align="left">显示具有指定标题级别的所有标题。</td><td align="left">Alt+Shift+标题级别编号</td></tr><tr><td align="left">插入制表符。</td><td align="left">Ctrl+Tab</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> word </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2023/02/09/Java/"/>
      <url>/2023/02/09/Java/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-Java程序设计概述"><a href="#第1章-Java程序设计概述" class="headerlink" title="第1章 Java程序设计概述"></a>第1章 Java程序设计概述</h1><p>Java是sun公司开发的一门编程语言,目前被Oracle公司收购，编程语言就是用来编写软件的。</p><h3 id="Java的应用"><a href="#Java的应用" class="headerlink" title="Java的应用"></a>Java的应用</h3><ul><li><p>开发QQ、迅雷程序(桌面应用软件)</p></li><li><p>淘宝、京东(互联网应用软件)</p></li><li><p>安卓应用程序</p></li></ul><h3 id="Java的擅长"><a href="#Java的擅长" class="headerlink" title="Java的擅长"></a>Java的擅长</h3><ul><li><p><strong>跨平台&#x2F;可移植性</strong></p><p>  这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。</p></li><li><p><strong>安全性</strong></p><p>  Java适合于网络&#x2F;分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。</p></li><li><p><strong>面向对象</strong></p><p>  面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！Java则是完全的面向对象语言。</p></li><li><p><strong>简单性</strong></p><p>  Java就是C++语法的简化版，我们也可以将Java称之为“C++-”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，由于语法基于C语言，因此学习起来完全不费力。</p></li><li><p><strong>高性能</strong></p><p>  Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，某些代码甚至接待C++的效率。</p><p>  因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。</p></li><li><p><strong>分布式</strong></p><p>  Java是为Internet的分布式环境设计的，因为它能够处理TCP&#x2F;IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，使程序能够通过网络调用方法。</p></li><li><p><strong>多线程</strong></p><p>  多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。</p></li><li><p><strong>健壮性</strong></p><p>  Java是一种健壮的语言，吸收了C&#x2F;C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。</p></li></ul><h3 id="Java语言平台"><a href="#Java语言平台" class="headerlink" title="Java语言平台"></a>Java语言平台</h3><ul><li>JavaSE（标准版）部分,JavaSE并不能开发大型项目。</li><li>JavaEE（企业版）部分,学习完JavaEE部分就可以开发各种大型项目了。</li></ul><hr><h1 id="第2章-Java程序设计环境"><a href="#第2章-Java程序设计环境" class="headerlink" title="第2章 Java程序设计环境"></a>第2章 Java程序设计环境</h1><h2 id="JDK的配置"><a href="#JDK的配置" class="headerlink" title="JDK的配置"></a>JDK的配置</h2><p>1、<a href="https://www.oracle.com/java/technologies/javase-downloads.html">&#x3D;&#x3D;点击进入JDK下载地址&#x3D;&#x3D;</a></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105245657-1810252397.png" alt="image-20200713130132169"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105244916-884552383.png" alt="image-20200713130232306"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105244136-124842773.png" alt="image-20200713130318194"></p><p>进入后翻到页面最下面</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105243631-1516109822.png" alt="image-20200713130736086"></p><p>下载之后，双击运行，安装时直接下一步即可，安装位置要记住。</p><p>2、配置环境变量</p><p><code>右击此电脑，选择属性</code></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105243119-200041282.png" alt="image-20200713131208585"></p><p><code>点击高级系统设置</code></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105242545-901402900.png" alt="image-20200713131315453"></p><p><code>点击环境变量</code></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105242087-932074706.png" alt="image-20200713131414182"></p><p>&#x3D;&#x3D;单击新建按钮，新建JAVA_HOME变量，注意填写目录是你安装好的JDK目录&#x3D;&#x3D;</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105241656-1383144458.png" alt="image-20200713132047022"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105240895-1405861717.png" alt="image-20200713132705811"></p><p>&#x3D;&#x3D;新建 CLASSPATH 变量&#x3D;&#x3D;</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105239886-2137624019.png" alt="image-20200713133007122"></p><p>&#x3D;&#x3D;检查 打开 cmd，输入 <strong>java -version</strong>，出现一连串的指令提示，说明配置成功了:&#x3D;&#x3D;</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105239525-1002306388.png" alt="image-20200713133145040"></p><h2 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h2><ol><li><p><a href="https://www.eclipse.org/">点击进入eclipse官网</a></p></li><li><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105238885-334487611.png" alt="image-20200713133833599"></p></li><li><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105237495-437266965.png" alt="image-20200713133909158"></p></li><li><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105236791-1628623197.png" alt="image-20200713133718355"></p></li><li><p>启动时会先出现设置工作空间界面，如图所示。工作空间指Java项目存储的目录，一般采用默认工作空间目录即可。</p><p> <img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494841793427012.png" alt="2.png"></p></li><li><p>点击OK后，会进入欢迎界面</p><p> <img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494841803281437.png" alt="3.png"></p></li></ol><p>也可以用另一款集成开发环境IntelliJ IDEA   <a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a></p><ol><li>进入官网下载</li></ol><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135040273-574379639.png" alt="image-20200718114847556"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135039325-910961947.png" alt="image-20200718115200884"></p><ol start="2"><li>下载好了之后双击安装</li></ol><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135038752-786784021.png" alt="image-20200718120428359"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135038025-701268700.png" alt="image-20200718120612382"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135037472-1292047777.png" alt="image-20200718120654990"></p><ol start="3"><li>等待安装</li><li><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135036896-1735558350.png" alt="image-20200718120900034"><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135036359-1775904885.png" alt="image-20200718120951730"></li></ol><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135035732-1462846355.png" alt="image-20200718121052654"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135034903-201172696.png" alt="image-20200718121324000"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135033717-578002151.png" alt="image-20200718121436479"></p><p>5.好了是时候该破解了。</p><p>补丁的下载地址：<a href="https://matthew.lanzous.com/iaXdxdwowhi%EF%BC%8C%E5%AF%86%E7%A0%81%EF%BC%9A3nu6">https://matthew.lanzous.com/iaXdxdwowhi，密码：3nu6</a></p><p>将补丁解压</p><p>解压后</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135032883-1790937390.png" alt="image-20200718121834494"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135032529-878203032.png" alt="image-20200718121853156"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135032185-313292389.png" alt="image-20200718121951254"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135031671-594388591.png" alt="image-20200718122155158"></p><hr><p>重启后</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135030398-2142273129.png" alt="image-20200718122319709"></p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200718135029510-270289526.png" alt="image-20200718122412190"></p><h1 id="第3章-Java的基本程序结构"><a href="#第3章-Java的基本程序结构" class="headerlink" title="第3章 Java的基本程序结构"></a>第3章 Java的基本程序结构</h1><blockquote><p>JDK、JRE、JVM三者之间的关系</p></blockquote><p>JDK：Java开发工具箱</p><p>JRE：Java运行环境</p><p>JVM：Java虚拟机</p><p>JDK包括JRE，JRE包括JVM。</p><p>如图所示：</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105235866-1748348170.png" alt="image-20200713143358821"></p><p><strong>JVM是不能独立安装的</strong></p><p><strong>JRE和JDK都是可以独立安装的。</strong></p><p>有单独的JDK安装包，也有单独的JRE安装包，没有单独的JVM安装包。安装JDK的时候：JRE就自动安装了，同时JRE内部的JVM就自动安装了。安装JRE的时候：JVM也就自动安装了。</p><blockquote><p>假设你在软件公式开发了一个新的软件，现在要去客户那边给客户把项目部署一下，把项目跑起来，你需要安装JDK吗？</p></blockquote><p>不需要，只需要安装JRE就行了，JRE体积很小，安装非常便捷快速。</p><blockquote><p>为什么安装JDK的时候自带一个JRE</p></blockquote><p>因为Java程序员开发完程序后，要测试这个程序，让这个程序运行起来，需要JRE。所以JDK安装的时候内部自带一个JRE。</p><h2 id="3-1-第一个程序Hello-World"><a href="#3-1-第一个程序Hello-World" class="headerlink" title="3.1 第一个程序Hello World"></a>3.1 第一个程序Hello World</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*1、在Java中任何有效的代码必须写到“类体”当中，最外层必须是一个类的定义。2、public表示公开的，class表示定义一个类，HelloWorld是一个类名。类名后面必须是一对大括号，这一对大括号被称为“类体” *&#x2F;public class HelloWorld&#123;&#x2F;&#x2F; 声明&#x2F;定义一个公开的类，起名叫HelloWorld&#x2F;&#x2F; 类体&#x2F;&#x2F; 整个这一块代码被称为main方法（程序的入口）&#x2F;&#x2F; 也就是说：JVM在执行程序的时候，会主动去找这样一个方法。&#x2F;&#x2F; main方法也可以叫做主方法（在c语言中叫函数）&#x2F;&#x2F; 方法必须放到“类体”中，不能放到类体外面。public static void main(String[] args) &#123;System.out.println(&quot;Hello World!&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于<code>System.out.println();</code></p></blockquote><p>这行代码的作用就是向控制台输出一句话</p><p>如果println后面小括号的内容是个字符串，就必须使用英文双引号括起来。</p><p>也可以是**System.out.print(); **不过加了ln打印输出就换行了 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test1&#123;public static void main(Sring[] args)&#123;&#x2F;&#x2F; 对于数字可以不加双引号System.out.println(100);&#x2F;&#x2F; 也可以加双引号System.out.println(&quot;100&quot;);&#x2F;&#x2F; 但是性质不一样，第一个是数字，第二个是字符串&#x2F;&#x2F; 但是输出到控制台上是一样&#x2F;&#x2F; 但是对于数字可以加减乘除&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>public static void main(String[] args)</p></blockquote><p>args可以随意该，其他位置不能动</p><h2 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h2><p>在Java中共有8种基本类型，其中有4种整形（int，short，long，byte）、2种浮点类型（float、double）、1种字符类型char和一种表示真值的boolean类型、String字符串类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class VarTest01&#123;public static void main(String[] args) &#123;System.out.println(100);System.out.println(3.14);System.out.println(true);System.out.println(false);System.out.println(&#39;a&#39;);System.out.println(&#39;中&#39;);System.out.println(&quot;abc&quot;);System.out.println(&quot;国&quot;);&#x2F;&#x2F; 编译报错。ab是一个字符串，不是字符型，不能用单引号。&#x2F;&#x2F;System.out.println(&#39;ab&#39;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-1-整形"><a href="#3-2-1-整形" class="headerlink" title="3.2.1 整形"></a>3.2.1 整形</h3><table><thead><tr><th>类型</th><th>存储需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td>int</td><td>4个字节</td><td align="center">-2 147 483 648 ~ 2 147 483 647（刚刚超过20亿）</td></tr><tr><td>short</td><td>2个字节</td><td align="center">-32 768 ~ 32 767</td></tr><tr><td>long</td><td>8个字节</td><td align="center">-9 223 372 036 854 775 808  ~ 9 223 372 036 854 775 807</td></tr><tr><td>byte</td><td>1个字节</td><td align="center">-128 ~ 127</td></tr></tbody></table><p>​在通常情况下，int类型最常用。当如果数据很大就要使用long类型了。byte和short类型主要用于特定的应用场合。</p><p>​长整型有个后缀 L 或 l（如 4000000L）。十六进制数值有一个前缀0X 或 0x。八进制前有个 0。</p><p>（注：Java种没有无符号unsigned类型）</p><h3 id="3-2-2-浮点类型"><a href="#3-2-2-浮点类型" class="headerlink" title="3.2.2 浮点类型"></a>3.2.2 浮点类型</h3><p>​</p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4个字节</td><td>有效小数位6~7位</td></tr><tr><td>double</td><td>8个字节</td><td>有效小数位数为15位</td></tr></tbody></table><p>​浮点数类型就是指的小数</p><p>float类型数值后有个后缀 F 或 f（例如，3.1415F）。没有后缀默认为double类型。</p><p><code>double是双精度的，float是单精度的，比如说</code>：</p><p>​10.0 &#x2F; 3 如果采用float来存储的结果可能是3.33333</p><p>​10.0 &#x2F; 3 如果采用double来存储的结果可能是3.3333333333333</p><p>但是需要注意的是，如果用在银行方面或者使用在财务方面，double也是远远不够的，在Java中提供了一种精度更高的类型：<strong>java.math.BigDecimal</strong>(不是基本数据类型，属于应用数据类型。)</p><p><code>任何一个浮点型都比整数型空间大。</code></p><h3 id="3-2-3-char类型"><a href="#3-2-3-char类型" class="headerlink" title="3.2.3 char类型"></a>3.2.3 char类型</h3><p>​char类型表示要用单括号括起来。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">char c &#x3D; &#39;a&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-4-boolean类型"><a href="#3-2-4-boolean类型" class="headerlink" title="3.2.4 boolean类型"></a>3.2.4 boolean类型</h3><p>boolean类型只有两个值：false 和 true，用来判定逻辑条件。不像c或者c++，c语言中1和0也可以表示布尔类型。</p><h3 id="3-2-5-String类型"><a href="#3-2-5-String类型" class="headerlink" title="3.2.5 String类型"></a>3.2.5 String类型</h3><p>Sting表示字符串类型，这个不是基本数据类型，是引用类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String name &#x3D; &quot;lishi&quot;;System.out.println(name);&#x2F;&#x2F;输出结果是lishi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-3-变量与常量"><a href="#3-3-变量与常量" class="headerlink" title="3.3 变量与常量"></a>3.3 变量与常量</h2><p> <strong>变量</strong></p><p>变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。</p><p>那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。</p><p><strong>定义变量</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">数据类型  变量名  &#x3D;  数据值；int         a    &#x3D;  100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;在java语言中有个规定，变量必须先声明，赋值才能访问。&#x3D;&#x3D;</p><p><strong>常量</strong></p><p>常量就是不变的数据量, 在程序执行的过程中其值不可以发生改变。</p><p>在Java中，利用关键词final指示常量。如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Constants&#123;    public static void main(String[] args)    &#123;        final double CM_PER_INCH &#x3D; 2.54;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​关键词final表示这个变量只能被赋值一次。一旦赋值后，就不能更改了。一般，常量名使用全大写。</p><p><strong>枚举类型（关键词enum）</strong></p><p>​枚举类型包括有限个命名的值。例如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">enum Size &#123;SMALL, MEDIUM, LARGE,EXTRA_LARGE&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，可以声明这种类型的变量了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Size s &#x3D; Size.MEDIUM;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 枚举编译之后也是生成class文件</p><h2 id="3-4运算符"><a href="#3-4运算符" class="headerlink" title="3.4运算符"></a>3.4运算符</h2><table><thead><tr><th>二元运算符</th><th>+，-，*，&#x2F;，%</th></tr></thead><tbody><tr><td>一元运算符</td><td>++，–</td></tr><tr><td>赋值运算符</td><td>&#x3D;</td></tr><tr><td>扩展运算符</td><td>+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</td></tr><tr><td>关系运算符</td><td>&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;  instanceof</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp;，||，!，^</td></tr><tr><td>位运算符</td><td>&amp;，|，^，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt;</td></tr><tr><td>条件运算符</td><td>? :</td></tr><tr><td>字符串连接符</td><td>+</td></tr></tbody></table><h3 id="3-4-1-算术运算符"><a href="#3-4-1-算术运算符" class="headerlink" title="3.4.1 算术运算符"></a>3.4.1 算术运算符</h3><p> • 注意：</p><ol><li><p>&#x2F; :除 6&#x2F;4&#x3D;1 6&#x2F;4.0&#x3D;1.5 2</p></li><li><p>% :取模(求余) 6%4&#x3D;2 </p></li><li><p>+: 6+‘a’&#x3D;103 </p></li><li><p>++: a&#x3D;2;b&#x3D;++a+9; a&#x3D;2;b&#x3D;a+++9; </p></li><li><p>+：字符串相加，只要有一个操作数是字符串，自动变为字符串相连</p><p> 二元运算符类型提升：</p><ul><li>整数运算： </li><li>如果两个操作数有一个为Long, 则结果也为long </li><li>没有long时，结果为int。即使操作数全为shot,byte，结果也是int. </li><li>浮点运算：</li><li>如果两个操作数有一个为double, 则结果为double. </li><li>只有两个操作数都是float, 则结果才为float.</li></ul></li></ol><ul><li>一元运算符(++, –)： <ul><li>int a &#x3D; 3; </li><li>int b &#x3D; a++; &#x2F;&#x2F;执行完后,b&#x3D;3。先给b赋值，再自增。</li><li>int c &#x3D; ++a; &#x2F;&#x2F;执行完后,c&#x3D;5。先自增,再给b赋值</li></ul></li></ul><h3 id="3-4-2-赋值运算符"><a href="#3-4-2-赋值运算符" class="headerlink" title="3.4.2 赋值运算符"></a>3.4.2 赋值运算符</h3><ul><li>基本赋值运算符 </li><li>扩展赋值运算符 </li><li>算术运算符和赋值运算符结合</li></ul><table><thead><tr><th>运算符</th><th>运算</th><th>规范</th><th>结果</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td><td>a &#x3D; 3; b &#x3D; 2</td><td>a &#x3D; 3; b &#x3D; 2;</td></tr><tr><td>+&#x3D;</td><td>加等于</td><td>a &#x3D; 3;  a +&#x3D; 4;</td><td>a &#x3D; 7;</td></tr><tr><td>-&#x3D;</td><td>减等于</td><td>a &#x3D; 3;  a -&#x3D;2;</td><td>a &#x3D; 1;</td></tr><tr><td>*&#x3D;</td><td>乘等于</td><td>a &#x3D; 3; a *&#x3D;2;</td><td>a &#x3D; 6;</td></tr><tr><td>&#x2F;&#x3D;</td><td>除等于</td><td>a &#x3D; 3; a &#x2F;&#x3D; 2;</td><td>a &#x3D;1;</td></tr><tr><td>%&#x3D;</td><td>模等于</td><td>a &#x3D; 3; a %&#x3D; 2</td><td>a &#x3D; 1;</td></tr></tbody></table><h3 id="3-4-3关系运算符"><a href="#3-4-3关系运算符" class="headerlink" title="3.4.3关系运算符"></a>3.4.3关系运算符</h3><ul><li>关系运算符用来进行比较运算 </li><li>关系运算的结果是布尔值：true&#x2F;false </li><li>注意 ：<ul><li>区分&#x3D;&#x3D;和&#x3D; </li><li>不等于是 !&#x3D; 不是&lt;&gt;</li></ul></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td><td align="center">a&#x3D;&#x3D;b</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不等于</td><td align="center">a!&#x3D;b</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">a&gt;b</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">a&lt;b</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于或等于</td><td align="center">a&gt;&#x3D;b</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于或等于</td><td align="center">a&lt;&#x3D;b</td></tr></tbody></table><h3 id="3-4-4-逻辑运算符"><a href="#3-4-4-逻辑运算符" class="headerlink" title="3.4.4 逻辑运算符"></a>3.4.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>说明</th><th></th></tr></thead><tbody><tr><td>逻辑与</td><td>&amp;( 与)</td><td>两个操作数为true，结果才是true，否则是false</td></tr><tr><td>逻辑或</td><td>|(或)</td><td>两个操作数有一个是true，结果就是true</td></tr><tr><td>短路与</td><td>&amp;&amp;( 与)</td><td>只要有一个为false，则直接返回false</td></tr><tr><td>短路或</td><td>||(或)</td><td>只要有一个为true， 则直接返回true</td></tr><tr><td>逻辑非</td><td>!（非）</td><td>取反：!false为true，!true为false</td></tr><tr><td>逻辑异或</td><td>^（异或）</td><td>相同为false，不同为true</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;1&gt;2的结果为false，那么整个表达式的结果即为false，将不再计算2&gt;(3&#x2F;0)boolean c &#x3D; 1&gt;2 &amp;&amp; 2&gt;(3&#x2F;0);System.out.println(c);&#x2F;&#x2F;1&gt;2的结果为false，那么整个表达式的结果即为false，还要计算2&gt;(3&#x2F;0)，0不能做除数，&#x2F;&#x2F;会输出异常信息boolean d &#x3D; 1&gt;2 &amp; 2&gt;(3&#x2F;0);System.out.println(d);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-5-位运算符"><a href="#3-4-5-位运算符" class="headerlink" title="3.4.5 位运算符"></a>3.4.5 位运算符</h3><table><thead><tr><th align="center">位运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">~</td><td align="center">取反</td></tr><tr><td align="center">&amp;</td><td align="center">按位与</td></tr><tr><td align="center">|</td><td align="center">按位或</td></tr><tr><td align="center">^</td><td align="center">按位异或</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移运算符，左移1位相当于乘2</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移运算符，右移1位相当于除2取商</td></tr></tbody></table><p><strong>左移运算和右移运算</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a &#x3D; 3*2*2;int b &#x3D; 3&lt;&lt;2; &#x2F;&#x2F;相当于：3*2*2;int c &#x3D; 12&#x2F;2&#x2F;2;int d &#x3D; 12&gt;&gt;2; &#x2F;&#x2F;相当于12&#x2F;2&#x2F;2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-6-条件运算符"><a href="#3-4-6-条件运算符" class="headerlink" title="3.4.6 条件运算符"></a>3.4.6 条件运算符</h3><ul><li>语法格式 <ul><li>x ? y : z </li><li>唯一的三目运算符</li></ul></li><li>执行过程 <ul><li>其中 x 为 boolean 类型表达式，先计算 x 的值，若为true，则整个三目运算的结果为表达式 y 的 值，否则整个运算结果为表达式 z 的值。</li></ul></li><li>经常用来代替简单的if-else判断！</li></ul><h3 id="3-4-7-字符串连接符"><a href="#3-4-7-字符串连接符" class="headerlink" title="3.4.7 字符串连接符"></a>3.4.7 字符串连接符</h3><p>“+”运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。&#x3D;&#x3D;字符串拼接完之后的结果还是一个字符串&#x3D;&#x3D;。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a&#x3D;12;System.out.println(&quot;a&#x3D;&quot;+a);&#x2F;&#x2F;输出结果: a&#x3D;12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当一个表达式当中有多个加号时。遵循<strong>自左向右</strong>的顺序依次执行。（除非额外添加了小括号，小括号优先级最高）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a &#x3D; 100;int b &#x3D; 200;&#x2F;&#x2F;先a  + b求和等于300 ，然后300 与 110 拼接形成字符串，所以输出结果一定是一个字符串300110.System.out.println(a + b + &quot;110&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-8-自动类型转换"><a href="#3-4-8-自动类型转换" class="headerlink" title="3.4.8 自动类型转换"></a>3.4.8 自动类型转换</h3><p>自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。如图所示，<strong>红色的实线表示无数据丢失的自动类型转换，而虚线表示在转换时可能会有精度的损失</strong>。</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105235130-1683627826.png" alt="image-20200713221857912"></p><p>​当用一个二元运算符连接两个值时（例如 n + f，n是整数，f是浮点数），先要将两个操作数转换为同一种类型，然后再进行计算。</p><ul><li>如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。</li><li>否则，如果其中一个操作数是float类型，另一个操作数就会转换为float类型。</li><li>否则，如果其中一个操作数是long类型，另一个操作数就会转换为long类型。</li><li>否则，两个操作数都将被转换为int类型。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class intTest&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F; 不存在类型转换        &#x2F;&#x2F; 100L是long类型，x是long类型        long x &#x3D; 100L;                &#x2F;&#x2F; x是long类型，占用8个字节，而y变量是int类型占用4个字节        &#x2F;&#x2F; 在java语言中，大容量不能直接赋值给小容量,从long转换到int可能会有损失        int y &#x3D; x;                &#x2F;&#x2F; 定义变量a int类型，赋值100        int a &#x3D; 100;        System.out.println(a);                int b &#x3D; a; &#x2F;&#x2F; 将变量a中保存的值100赋值给b变量。        System.out.println(b);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-9-强制类型转换"><a href="#3-4-9-强制类型转换" class="headerlink" title="3.4.9 强制类型转换"></a>3.4.9 强制类型转换</h3><p>​在上一小节中，在必要的时候，int类型的值将会自动地转换为long类型。但另一方面，有时候也需要将long转换为ing。在Java中，允许进行这种数值之间的类型转换，当然，有可能会丢失一些信息。这种可能损失信息的转换要通过强制类型转换。强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">long a &#x3D; 31415;int b &#x3D; (int)x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​这样long类型成功转换为int类型了。</p><p>如果long值过大，超过了int类型的范围，&#x3D;&#x3D;会自动将前面的数字砍掉。&#x3D;&#x3D;</p><p><strong>byte、char、short做混合运算的时候，各自向转换成int在做运算</strong></p><h2 id="3-5-输入与输出"><a href="#3-5-输入与输出" class="headerlink" title="3.5 输入与输出"></a>3.5 输入与输出</h2><p>​为了熟悉java程序语言设计，因此我们要使用基本的控制台实现输入和输出。</p><h3 id="3-5-1-读取输入"><a href="#3-5-1-读取输入" class="headerlink" title="3.5.1 读取输入"></a>3.5.1 读取输入</h3><p>​前面已经看懂，将输出打印到“标准输出流”（即控制台窗口）是一件非常简单的事，只要调用System.out.println即可。然而，读取”标准输入流“System.in就没那么简单了。要想通过控制台进行输入，首先需要构建一个与”标准输入流“System.in关联的Scanner对象。</p><p>​<code>Scanner in = new Scanner(System.in); // 这里有面向对象的知识了，后面会详细介绍</code></p><p>​现在，我们就可以使用Scanner类的各种方法读取输入了。例如，nextLine方法将读取一行输入<code>String name = in.nextLine();</code></p><p>​在这里，使用nextLine方法是因为在输入行有可能包含空格。要想读取一一个单词（以空格符作分隔符），可调用<code>String name = in.next();</code></p><p>​要想读取一个整数，就要调用<code>String name = in.nextInt();</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import  java.util.Scanner;&#x2F;&#x2F; 这个是导包public class TestScanner &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建键盘扫描器对象        Scanner   scanner &#x3D;  new Scanner(System.in); &#x2F;&#x2F;这行代码写一次就行了        System.out.println(&quot;请输入名字：&quot;);        String   name &#x3D;  scanner.nextLine();        System.out.println(&quot;请输入你的爱好：&quot;);        String  favor &#x3D; scanner.nextLine();        System.out.println(&quot;请输入你的年龄：&quot;);        int   age &#x3D; scanner.nextInt();                 System.out.println(&quot;###############&quot;);        System.out.println(name);        System.out.println(favor);        System.out.println(&quot;来到地球的天数：&quot;+age*365);          &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-2-格式化输出"><a href="#3-5-2-格式化输出" class="headerlink" title="3.5.2 格式化输出"></a>3.5.2 格式化输出</h3><p>​在早期的Java中，格式化数值曾经引起过一些争议。不过Java5沿用了c语言函数库中的printf方法。例如，调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">double x &#x3D; 3.1415926;System.out.printf(&quot;%8.1f&quot;,x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个会打印8个字符，精度是小数点后1个字符。</p><h2 id="3-6-控制语句"><a href="#3-6-控制语句" class="headerlink" title="3.6 控制语句"></a>3.6 控制语句</h2><p>控制语句的出现可以让我们的程序具有逻辑性 &#x2F; 条理性，可以使用控制语句来实现一个”业务”了；控制语句包含&#x3D;&#x3D;选择语句，循环语句，转向语句&#x3D;&#x3D;</p><h3 id="3-6-1-选择语句"><a href="#3-6-1-选择语句" class="headerlink" title="3.6 .1 选择语句"></a>3.6 .1 选择语句</h3><p>选择语句包含if语句，switch语句</p><p> <strong>if语句</strong></p><p>if语句是指如果满足某种条件，就进行某种处理。</p><p>在Java中，if语句的具体语法格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (条件语句)&#123;执行语句;……&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该语法的的小括号结果是true，这执行大括号中的程序，负责大括号不执行。在Java中if语句小括号里面只能是布尔类型不能是数值等其它类型（在c语言中可以是数值）</p><blockquote><p>还有第二种写法</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(布尔表达式)&#123;&#x2F;&#x2F;分支1    java语句;&#125;else&#123;&#x2F;&#x2F;分支2    Java语句;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行原理：如果布尔表达式结果是true，则执行分支1，分支2不执行。如果布尔表达式的结果false，则分支1不执行，执行分支2.</p><blockquote><p>第三种写法</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(布尔表达式1)&#123;&#x2F;&#x2F;分支1    java语句;&#125;else if(布尔表达式2)&#123;&#x2F;&#x2F;分支2    java语句;&#125;else if(布尔表达式3)&#123;&#x2F;&#x2F;分支3    java语句;&#125;else&#123;    java语句;&#x2F;&#x2F; 以上条件没有一个成立的。这个else就执行了。&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行原理：</p><p>​先判断布尔表达式1，如果布尔表达式1为true，则执行分支1，然后if语句结束了。当”布尔表达式1”结果是false，那么会继续判断表达式2的结果，如果布尔表达式2的结果是true，则执行分支2。</p><p> <strong>switch语句</strong></p><p>根据一个整数表达式的值， switch 语句可从一系列代码选出一段执行。它的格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">switch(整数选择因子或者字符串或者枚举) &#123;　　case 值 1 : 语句; break;　　case 值 2 : 语句; break;　　case 值 3 : 语句; break;　　case 值 4 : 语句; break;　　case 值 5 : 语句; break;　　&#x2F;&#x2F;..　　default:语句;92&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>switch 能将整数选择因子的结果与每个值比较。若发现相符的，就执行对应的语句（简单或复合语句）。若没有发现相符的，就执行default 语句。</p><p>在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test6 &#123;    public static void main(String[] args) &#123;        char c &#x3D; &#39;a&#39;;        int rand &#x3D; (int) (26 * Math.random());        char c2 &#x3D; (char) (c + rand);        System.out.print(c2 + &quot;: &quot;);        switch (c2) &#123;        case &#39;a&#39;:        case &#39;e&#39;:        case &#39;i&#39;:        case &#39;o&#39;:        case &#39;u&#39;:            System.out.println(&quot;元音&quot;);            break;        case &#39;y&#39;:        case &#39;w&#39;:            System.out.println(&quot;半元音&quot;);            break;        default:            System.out.println(&quot;辅音&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-2-循环语句"><a href="#3-6-2-循环语句" class="headerlink" title="3.6.2 循环语句"></a>3.6.2 循环语句</h3><p>在现实世界中，有很多事情都是需要反复重复去做。对应到程序当中，如果有一块代码需要重复执行，此时为了减少代码量，我们使用循环语句。</p><p><strong>while循环</strong></p><p>while循环语句和选择结构if语句有些相似，都是根据条件判断来决定是否执行大括号内的执行语句。区别在于，while语句会反复地进行条件判断，只要条件成立，{}内的执行语句就会执行，直到条件不成立，while循环结束。while循环语句的语法结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">while(循环条件)&#123;    执行语句    ………&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>while循环结构：求1到100之间的累加和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;  public static void main(String[] args) &#123;    int i &#x3D; 0;    int sum &#x3D; 0;    &#x2F;&#x2F; 1+2+3+…+100&#x3D;?    while (i &lt;&#x3D; 100) &#123;      sum +&#x3D; i;&#x2F;&#x2F;相当于sum &#x3D; sum+i;      i++;    &#125;    System.out.println(&quot;Sum&#x3D; &quot; + sum);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>do-while循环</strong></p><p>do…while循环语句和while循环语句功能类似，其语法结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">do &#123;    执行语句    ………&#125; while(循环条件);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>do-while循环结构：1-100之间的累加和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;    public static void main(String[] args) &#123;        int i &#x3D; 0;        int sum &#x3D; 0;        do &#123;            sum +&#x3D; i; &#x2F;&#x2F; sum &#x3D; sum + i            i++;        &#125; while (i &lt;&#x3D; 100);&#x2F;&#x2F;此处的；不能省略        System.out.println(&quot;Sum&#x3D; &quot; + sum);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>while与do-while的区别</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test9 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;while循环：先判断再执行        int a &#x3D; 0;        while (a &lt; 0) &#123;            System.out.println(a);            a++;        &#125;        System.out.println(&quot;-----&quot;);        &#x2F;&#x2F;do-while循环：先执行再判断        a &#x3D; 0;        do &#123;            System.out.println(a);            a++;        &#125; while (a &lt; 0);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>&#x3D;&#x3D;循环语句for&#x3D;&#x3D;</strong></p><p>for循环语句是最常用的循环语句，一般用在循环次数已知的情况下。for循环语句的语法格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for（初始化表达式; 循环条件; 操作表达式）&#123;    执行语句    ………&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的语法结构中，for关键字后面()中包括了三部分内容：初始化表达式、循环条件和操作表达式，它们之间用“;”分隔，{}中的执行语句为循环体。</p><p>接下来分别用①表示初始化表达式、②表示循环条件、③表示操作表达式、④表示循环体，通过序号来具体分析for循环的执行流程。具体如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for（① ; ② ; ③）&#123;　　④&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>第一步，执行①</li><li>第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步</li><li>第三步，执行④</li><li>第四步，执行③，然后重复执行第二步</li><li>第五步，退出循环</li></ul><p>for循环结构：求1到100之间的累加和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ForDemo01 &#123;    public static void main(String[] args) &#123;        int sum &#x3D; 0; &#x2F;&#x2F; 定义变量sum，用于记住累加的和        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123; &#x2F;&#x2F; i的值会在1~100之间变化            sum +&#x3D; i; &#x2F;&#x2F; 实现sum与i的累加        &#125;        System.out.println(&quot;sum &#x3D; &quot; + sum); &#x2F;&#x2F; 打印累加的和    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-3-转向语句"><a href="#3-6-3-转向语句" class="headerlink" title="3.6.3 转向语句"></a>3.6.3 转向语句</h3><p><strong>break</strong>语句</p><p>​1、break; 语句比较特殊，特殊在：break语句是一个单词成为一个完整的java语句。另外：continue也是这样，他两个都是一个单词成为一条语句。</p><p>​2、break 翻译为折断、弄断。</p><p>​3、bread; 用在两个地方</p><p>​第一个位置：switch语句当中，用来终止switch语句的执行。</p><p>​第二个位置：break; 语句用在循环语句当中，用来终止循环的执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BreakTest&#123;    public static void main(String[] args)&#123;        for (int i &#x3D; 0; i &lt; 10; i++)&#123;            if (i &#x3D;&#x3D; 5)&#123;               &#x2F;&#x2F; break; 语句会让离他最近的循环终止结束掉。                break; &#x2F;&#x2F;break; 终止的不是if，不是针对if的，而是针对理他最近的循环或switch语句            &#125;            System.out.println(&quot;i &#x3D;&quot; + i);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一种语法很少用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">a:for (int k &#x3D; 0; k &lt; 2; k++)&#123;    b:for(int i &#x3D; 0; i &lt; 10; i++)&#123;        if (i &#x3D;&#x3D; 5)&#123;            break a;&#x2F;&#x2F; 结束a循环        &#125;        System.out.println(&quot;i &#x3D;&#x3D;&#x3D;&gt;&quot; + i);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>continue语句</strong></p><p>​1、continue翻译为继续</p><p>​2、continue语句和break语句要对比着学习</p><p>​3、continue语句的作用是：</p><p>​终止当前“本次”循环，直接进入下一次循环继续执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for()&#123;    if ()&#123;&#x2F;&#x2F; 当这个条件成立时，执行continue语句        continue; &#x2F;&#x2F;当continue语句执行时，continue下面的代码不执行，直接进入下次循环执行。    &#125;        &#x2F;&#x2F; 以上代码的continue一旦执行，该循环的以下代码不执行，直接下一次循环；    code1;    code2;    code3;    code4;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-7-方法"><a href="#3-7-方法" class="headerlink" title="3.7 方法"></a>3.7 方法</h2><p> 方法就是一段用来完成特定功能的代码片段，类似于c语言中的函数。</p><blockquote><p><strong>那么什么是方法呢？</strong></p></blockquote><p>方法（英语单词：method）是一段可以重复利用的代码片段，并且可以被重复利用的的代码片段。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><blockquote><p><strong>方法的优点</strong></p></blockquote><ul><li>\1. 使程序变得更简短而清晰。</li><li>\2. 有利于程序维护。</li><li>\3. 可以提高程序开发的效率。</li><li>\4. 提高了代码的重用性。</li></ul><blockquote><p><strong>方法的定义</strong></p></blockquote><p>一般情况下，定义一个方法包含以下语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;    ...    方法体    ...    return 返回值;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li><li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li></ul><p>如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int age(int birthday)&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数可以有多个：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">static float interest(float principal, int year)&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong> 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p><blockquote><p>实例</p></blockquote><p>下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** 返回两个整型变量数据的较大值 *&#x2F;public static int max(int num1, int num2) &#123;   int result;   if (num1 &gt; num2)      result &#x3D; num1;   else      result &#x3D; num2;    return result; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>方法调用</p></blockquote><p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p><p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p><p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int larger &#x3D; max(30, 40);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;欢迎访问&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>示例</p></blockquote><p>下面的例子演示了如何定义一个方法，以及如何调用它：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestMax &#123;   &#x2F;** 主方法 *&#x2F;   public static void main(String[] args) &#123;      int i &#x3D; 5;      int j &#x3D; 2;      int k &#x3D; max(i, j);      System.out.println( i + &quot; 和 &quot; + j + &quot; 比较，最大值是：&quot; + k);   &#125;    &#x2F;** 返回两个整数变量较大的值 *&#x2F;   public static int max(int num1, int num2) &#123;      int result;      if (num1 &gt; num2)         result &#x3D; num1;      else         result &#x3D; num2;       return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>void 关键字</p></blockquote><p>下面的例子声明了一个名为 printGrade 的方法，并且调用它来打印给定的分数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 输出结果为Cpublic class TestVoidMethod &#123;  public static void main(String[] args) &#123;    printGrade(78.5);  &#125;   public static void printGrade(double score) &#123;    if (score &gt;&#x3D; 90.0) &#123;       System.out.println(&#39;A&#39;);    &#125;    else if (score &gt;&#x3D; 80.0) &#123;       System.out.println(&#39;B&#39;);    &#125;    else if (score &gt;&#x3D; 70.0) &#123;       System.out.println(&#39;C&#39;);    &#125;    else if (score &gt;&#x3D; 60.0) &#123;       System.out.println(&#39;D&#39;);    &#125;    else &#123;       System.out.println(&#39;F&#39;);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 通过值传递参数</p></blockquote><p>调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。</p><p>下面的例子演示按值传递的效果。该程序创建一个方法，该方法用于交换两个变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 以下实例编译运行结果如下：&#x2F;*交换前 num1 的值为：1 ，num2 的值为：2    进入 swap 方法        交换前 n1 的值为：1，n2 的值：2        交换后 n1 的值为 2，n2 的值：1交换后 num1 的值为：1 ，num2 的值为：2*&#x2F;public class TestPassByValue &#123;  public static void main(String[] args) &#123;    int num1 &#x3D; 1;    int num2 &#x3D; 2;     System.out.println(&quot;交换前 num1 的值为：&quot; + num1 + &quot; ，num2 的值为：&quot; + num2);     &#x2F;&#x2F; 调用swap方法    swap(num1, num2);    System.out.println(&quot;交换后 num1 的值为：&quot; + num1 + &quot; ，num2 的值为：&quot; + num2);  &#125;  &#x2F;** 交换两个变量的方法 *&#x2F;   public static void swap(int n1, int n2) &#123;    System.out.println(&quot;\t进入 swap 方法&quot;);    System.out.println(&quot;\t\t交换前 n1 的值为：&quot; + n1 + &quot;，n2 的值：&quot; + n2);    &#x2F;&#x2F; 交换 n1 与 n2的值    int temp &#x3D; n1;    n1 &#x3D; n2;    n2 &#x3D; temp;     System.out.println(&quot;\t\t交换后 n1 的值为 &quot; + n1 + &quot;，n2 的值：&quot; + n2);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>return 语句和 break 语句的区别</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MethodTest06&#123;    public static void main(String[] args)&#123;        for (int i &#x3D; 0; i &lt; 10; i++)&#123;            &#x2F;&#x2F;break;&#x2F;&#x2F;终止for循环            &#x2F;&#x2F;return终止当前的方法和break不是一个级别。        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>方法重载</p></blockquote><p>Java允许在一个类中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。</p><p>使用方法重载机制的优点：</p><ol><li>代码整齐美观。</li><li>功能相似，可以让方法名字相同，更易于以后代码编写。</li></ol><p>在java语言中，首先java编译器会通过方法名进行区分。但是在java语言中允许方法名相同的情况出现。如果方法名相同的情况下，编译器会通过方法的参数类型进行方法区分。如用下面代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class OverloadTest&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F; 对于程序员来说，只需要记忆一个方法名即可。        System.out.println(sum(10,20));        System.out.println(sum(10L,20L));        System.out.println(sum(10.0,20.0));    &#125;    &#x2F;&#x2F; 定义一个计算int类型数据的求和方法    public static int sum(int a, int b)&#123;        System.out.println(&quot;int求和&quot;);        return a + b;    &#125;        &#x2F;&#x2F; 定义一个计算long类型数据的求和方法    public static long sum(long a, long b)&#123;        System.out.println(&quot;long求和&quot;);        return a + b;    &#125;        &#x2F;&#x2F; 定义一个计算double类型数据的求和方法    public static double sum(double a, double b)&#123;        System.out.println(&quot;double求和&quot;);        return a + b;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;那么什么时候考虑使用方法重载&#x3D;&#x3D;</p><p>​<em>在同一个类当中</em>，如果“功能1”和“功能2”它们的功能是相似的，那么可以考虑将它们的方法名一致，这样代码既美观，又便于后期的代码编写（减少记忆，方便使用）。</p><p>​<strong>注意</strong>：方法重载overload不能随便使用，如果两个功能压根不相干，此时两个方法使用重构机制的话，会导致编码更麻烦。</p><p>&#x3D;&#x3D;什么时候代码会发生方法重载？&#x3D;&#x3D;</p><p>​条件1：<strong>在同一个类当中</strong></p><p>​条件2：<strong>方法名相同</strong></p><p>​条件3：<strong>参数列表不同</strong>（参数的个数不同算不同，参数的类型不同算不同，参数的顺序不同算不同）</p><p>只要满足以上3个条件，那么我们可以认定方法和方法之间发生了重载机制。</p><p>​方法的重载和返回值类型无关，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 这个方法没有发生重载，这是方法重复了public static int m5()&#123;    return 1;&#125;public static double m5()&#123;    return 1.0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​方法重载和方法的修饰符列表无关 :</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;这不是重载，是重复了。void m6()&#123;    &#125;public static void m6()&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>方法的递归</p></blockquote><ol><li><p>什么是方法递归</p><p> 方法自己调用自己，这就是方法递归。</p></li><li><p>当递归时程序没有结束条件，一定会发生：</p><p> 栈内存溢出错误：StackOverflowError</p><p> 所以：&#x3D;&#x3D;递归必须要有结束条件。&#x3D;&#x3D;</p><p> JVM发生错误之后只有一个结果，就是退出JVM。</p></li><li><p>递归有结束条件，就一定会发生栈内存溢出错误吗？</p><p> 假设这个结束条件是对的，是合法的，递归有的时候也会出现栈内存溢出错误。</p><p> 因为有可能递归的太深，栈内存不够了。因为一直压栈。</p></li><li><p>在实际的开发中，不建议轻易的使用递归，能用循环代替的尽量用循环来代替。因为循环的效率高，耗费内存少。递归耗费的内存比较大，另外递归的使用不当，会导致JVM死掉。（但在极少数情况下，不用递归程序无法使用）</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RecursionTest&#123;    public static void main(String[] args)&#123;        doSome();    &#125;        public static void doSome()&#123;        doSome()    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用递归计算1~n的和</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class RecursionTest&#123;    public static void main(String[] args)&#123;        Scanner scanner &#x3D; new Scanner(System.in);        int n &#x3D; scanner.nextInt();        &#x2F;&#x2F; 1 ~ n 的和        int retValue &#x3D; sum(n);        System.out.println(retValue);    &#125;        public static int sum(int n)&#123;        if (n &#x3D;&#x3D; 1)&#123;            return 1;        &#125;        return n + sum(n-1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-8-数组"><a href="#3-8-数组" class="headerlink" title="3.8 数组"></a>3.8 数组</h2><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><p>你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，….，number99。</p><p>本教程将为大家介绍 Java 数组的声明、创建和初始化，并给出其对应的代码。</p><blockquote><p>声明数组变量</p></blockquote><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType[] arrayRefVar;   &#x2F;&#x2F; 首选的方法 或 dataType arrayRefVar[];  &#x2F;&#x2F; 效果相同，但不是首选方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>创建数组 </p></blockquote><p>Java语言使用new操作符来创建数组，语法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">arrayRefVar &#x3D; new dataType[arraySize];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的语法语句做了两件事：</p><ul><li>一、使用 dataType[arraySize] 创建了一个数组。</li><li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType[] arrayRefVar &#x3D; new dataType[arraySize];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，你还可以使用如下的方式创建数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType[] arrayRefVar &#x3D; &#123;value0, value1, ..., valuek&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>实例</p></blockquote><p>下面的语句首先声明了一个数组变量 myList，接着创建了一个包含 10 个 double 类型元素的数组，并且把它的引用赋值给 myList 变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 以下输出结果为：总和为： 11367.373public class TestArray &#123;   public static void main(String[] args) &#123;      &#x2F;&#x2F; 数组大小      int size &#x3D; 10;      &#x2F;&#x2F; 定义数组      double[] myList &#x3D; new double[size];      myList[0] &#x3D; 5.6;      myList[1] &#x3D; 4.5;      myList[2] &#x3D; 3.3;      myList[3] &#x3D; 13.2;      myList[4] &#x3D; 4.0;      myList[5] &#x3D; 34.33;      myList[6] &#x3D; 34.0;      myList[7] &#x3D; 45.45;      myList[8] &#x3D; 99.993;      myList[9] &#x3D; 11123;      &#x2F;&#x2F; 计算所有元素的总和      double total &#x3D; 0;      for (int i &#x3D; 0; i &lt; size; i++) &#123;         total +&#x3D; myList[i];      &#125;      System.out.println(&quot;总和为： &quot; + total);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>处理数组</p></blockquote><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。</p><p><strong>示例</strong></p><p>该实例完整地展示了如何创建、初始化和操纵数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 以下实例编译运行如下：&#x2F;*1.92.93.43.5Total is 11.7Max is 3.5*&#x2F;public class TestArray &#123;   public static void main(String[] args) &#123;      double[] myList &#x3D; &#123;1.9, 2.9, 3.4, 3.5&#125;;       &#x2F;&#x2F; 打印所有数组元素      for (int i &#x3D; 0; i &lt; myList.length; i++) &#123;         System.out.println(myList[i] + &quot; &quot;);      &#125;      &#x2F;&#x2F; 计算所有元素的总和      double total &#x3D; 0;      for (int i &#x3D; 0; i &lt; myList.length; i++) &#123;         total +&#x3D; myList[i];      &#125;      System.out.println(&quot;Total is &quot; + total);      &#x2F;&#x2F; 查找最大元素      double max &#x3D; myList[0];      for (int i &#x3D; 1; i &lt; myList.length; i++) &#123;         if (myList[i] &gt; max) max &#x3D; myList[i];      &#125;      System.out.println(&quot;Max is &quot; + max);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>for each循环（也就是for循环的增强）</p></blockquote><p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p><p>语法格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(type element: array)&#123;    System.out.println(element);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实例</strong></p><p>该实例用来显示数组 myList 中的所有元素：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestArray &#123;   public static void main(String[] args) &#123;      double[] myList &#x3D; &#123;1.9, 2.9, 3.4, 3.5&#125;;       &#x2F;&#x2F; 打印所有数组元素      for (double element: myList) &#123;         System.out.println(element);      &#125;   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>数组的拷贝</p></blockquote><p>System.arraycopy方法是一个本地的方法，源码里定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static native void arraycopy(Object src, int srcPos, Object dest, int desPos, int length)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其参数含义为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">（原数组， 原数组的开始位置， 目标数组， 目标数组的开始位置， 拷贝个数）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用法示例:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] a1 &#x3D; &#123;1, 2, 3, 4, 5&#125;;int[] a2 &#x3D; new int[10];&#x2F;&#x2F; 将a1的数组下标为1开始赋值给a2的下标为2开始，长度为3System.arraycopy(a1, 1, a2, 2, 3);for (int i &#x3D; 0; i &lt; a1.length; i++)&#123; System.out.println(a1[i]);&#x2F;&#x2F; [1, 2, 3, 4, 5]&#125;for (int i &#x3D; 0; i &lt; a2.length; i++)&#123;    System.out.println(a2[i]);&#x2F;&#x2F; [0, 0, 2, 3, 4, 0, 0, 0, 0, 0]&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 数组作为函数的参数</p></blockquote><p>数组可以作为参数传递给方法。</p><p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void printArray(int[] array) &#123;  for (int i &#x3D; 0; i &lt; array.length; i++) &#123;    System.out.print(array[i] + &quot; &quot;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>数组作为函数的返回值</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int[] reverse(int[] list) &#123;  int[] result &#x3D; new int[list.length];   for (int i &#x3D; 0, j &#x3D; result.length - 1; i &lt; list.length; i++, j--) &#123;    result[j] &#x3D; list[i];  &#125;  return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>多维数组</p></blockquote><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str[][] &#x3D; new String[3][4];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>多维数组的动态初始化（以二维数组为例）</strong></p><ol><li><p>直接为每一维分配空间，格式如下：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">type[][] typeName &#x3D; new type[typeLength1][typeLength2];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> type 可以为基本数据类型和复合数据类型，arraylength1 和 arraylength2 必须为正整数，arraylength1 为行数，arraylength2 为列数。</p><p> 例如：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">int a[][] &#x3D; new int[2][3];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 解析：</p><p> 二维数组 a 可以看成一个两行三列的数组。</p></li><li><p>从最高维开始，分别为每一维分配空间，例如：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">String s[][] &#x3D; new String[2][];s[0] &#x3D; new String[2];s[1] &#x3D; new String[3];s[0][0] &#x3D; new String(&quot;Good&quot;);s[0][1] &#x3D; new String(&quot;Luck&quot;);s[1][0] &#x3D; new String(&quot;to&quot;);s[1][1] &#x3D; new String(&quot;you&quot;);s[1][2] &#x3D; new String(&quot;!&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 解析：</p><p> <strong>s[0]&#x3D;new String[2]</strong> 和 <strong>s[1]&#x3D;new String[3]</strong> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <strong>s0&#x3D;new String(“Good”)</strong> 等操作。</p></li></ol><blockquote><p>java.util.Arrays工具类</p></blockquote><p>排序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Arrays.sort(数组名字);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>二分法查找：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Arrays.binarySearch(数组名,查找的数);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h1 id="第4章-面向对象"><a href="#第4章-面向对象" class="headerlink" title="第4章 面向对象"></a>第4章 面向对象</h1><h2 id="4-1-面向对象的概述"><a href="#4-1-面向对象的概述" class="headerlink" title="4.1  面向对象的概述"></a>4.1  面向对象的概述</h2><ol><li><p>面向过程和面向对象有什么区别？</p><p> 从语言来说：</p><p> ​对于c语言来说，是完全面向过程的。</p><p> ​对于c++来说，是一半面向过程，一半面向对象。</p><p> ​对于Java语言来说，是完全面向对象的。</p><p> <strong>什么是面向过程的开发方式？</strong></p><p> ​面向过程的开发方式主要的特点是：</p><p> ​注重步骤，注重的是实现这个功能的步骤。</p><p> <strong>什么是面向对象的开发式？</strong></p><p> ​采用面向对象的的方式进行开发，更符合人类的思维方法。人类就是以“对象”的方式去认识世界的。所以面向对象更容易让我们接受。面向对象就是将现实世界分隔成不同的单元，然后每个单元都实现成对象，然后驱动一下，让各个对象之间协作起来形成一个系统。采用面向对象的方式进行开发：耦合度低，扩展力强。</p></li><li><p>当我们采用面向对象的方式贯穿整个系统的话，设计到三个术语：</p><p> OOA：面向对象分析</p><p> OOD：面向对象设计</p><p> OOP：面向对象编程</p><p> 整个软件开发的过程，都是采用oo进行贯穿的。</p><p> 实现有一个软件的过程：</p><p> ​分析（A）–&gt; 设计（D）–&gt;编程（P）</p></li><li><p>面向对象包括三大特征</p><p> &#x3D;&#x3D;封装&#x3D;&#x3D;</p><p> &#x3D;&#x3D;继承&#x3D;&#x3D;</p><p> &#x3D;&#x3D;多态&#x3D;&#x3D;</p><p> 任何一个面向对象的编程语言都包括这三个特征</p><p> 例如：</p><p> ​python也有封装 继承 多态</p></li><li><p>类和对象的概念</p><p> 面向对象当中最主要“一词”是：对象。</p><p> 什么是类？</p><p> ​类实际上在现实世界中不存在的 是一个抽象的概念。是一个模板。是我们人类大脑进行思考、总结、抽象的一个结果。类本质上是现实世界中某些事物具有共同特征，将这些共同特征提取出来形成的概念就是一个”类“，”类“就是一个模板。</p><p> 什么是对象？</p><p> ​对象是实际存在的个体。（真实存在的个体）</p><p> 在java语言中，要想得到“对象”，必须先定义“类”，‘对象“是通过”类“这个模板创造出来的。</p><p> ​类就是一个模板：类中描述的是所有对象的”共同特征信息“</p><p> ​对象就是通过类创建出的个体。</p><p> 这几个术语你需要自己能够阐述出来：</p><p> ​类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征）</p><p> ​对象：实际存在的个体。</p><p> ​实例：对象还有另一个名字叫做实例。</p><p> ​实例化：通过类这个模板创建对象的过程，叫做：实例化。</p><p> ​抽象：多个对象具有共同特征，进行思考总结抽取的过程。</p><p> ​类——【实例化】——&gt; 对象（实例）</p><p> ​对象——【抽象】——&gt; 类</p></li><li><p>类的定义</p><p> <strong>怎么定义一个类</strong></p><p> [修饰符列表] class 类名 {</p><p> ​&#x2F;&#x2F; 类体 &#x3D; 属性 + 方法</p><p> ​&#x2F;&#x2F; 属性在代码上以”变量“的形式存在（描述状态）</p><p> ​&#x2F;&#x2F; 方法描述动作&#x2F;行为</p><p> }</p><p> <strong>为什么属性是”以“变量的形式存在的</strong></p><p> ​假设我们要描述一个学生：</p><p> ​学生包括那些属性：</p><p> ​学生：110</p><p> ​性别：’男’</p><p> ​姓名：”张三”</p><p> ​答案：是因为属性对于的是”数据“，数据在程序中只能放到变量中。</p></li><li><p>创建对象的格式：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">类名 对象名 &#x3D; new 类名(); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 汽车类</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Car &#123;    String color;    int number;    void run() &#123;        System.out.println(color + &quot;:&quot; + number);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 测试类:</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CarDemo &#123;    public static void main(String[] args) &#123; &#x2F;** 测试：Car类中的run方法。*&#x2F;&#x2F;&#x2F; 1,创建Car的对象。给对象起个名字。        Car c &#x3D; new Car();&#x2F;&#x2F; c是类类型的变量。c指向了一个具体的Car类型的对象。&#x2F;&#x2F; 2,通过已有的对象调用该对象的功能。格式：对象.对象成员;&#x2F;&#x2F; 3,可以该对象的属性赋值。        c.color &#x3D; &quot;red&quot;;        c.number &#x3D; 4;        c.run();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对象的内存图解:</p><p> <img src="https://images2015.cnblogs.com/blog/612774/201707/612774-20170705230504956-8743412.png" alt="img"></p></li></ol><h2 id="4-2-用户自定义类"><a href="#4-2-用户自定义类" class="headerlink" title="4.2 用户自定义类"></a>4.2 用户自定义类</h2><blockquote><p> 局部变量和成员变量区别</p></blockquote><p>类中定义的变量，和在方法定义的变量有啥差别呢？<br>区别一：定义的位置不同<br>定义在类中的变量是成员变量；定义在方法中或者{}语句里面的变量是局部变量<br>区别二：在内存中的位置不同<br>成员变量存储在对内存的对象中；局部变量存储在栈内存的方法中<br>区别三：声明周期不同<br>成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失；局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失<br>区别四：初始化不同<br>成员变量因为在堆内存中，所以有默认的初始化值；局部变量没有默认的初始化值，必须手动的给其赋值才可以使用。</p><blockquote><p>基本类型和引用类型作为参数传递</p></blockquote><p>引用类型数据和基本类型数据作为参数传递有没有差别呢？我们用如下代码进行说明：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Demo&#123;    public static void main(String[] args)    &#123;        int x &#x3D; 4;        show(x);        System.out.println(&quot;x&#x3D;&quot;+x);    &#125;    public static void show(int x)    &#123;        x &#x3D; 5;    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。</p><h2 id="4-3-方法参数"><a href="#4-3-方法参数" class="headerlink" title="4.3 方法参数"></a>4.3 方法参数</h2><p>java程序实际语言总是采用按值调用。也就是说，方法得到的就是所有参数值的一个副本。具体来讲方法不能修饰传递给他的任何参数变量的内容。</p><p>​例如，考虑下面的调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">double percent &#x3D; 10;harry.raiseSalary(percent);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不论这个方法如何实现，percent的值还是10。</p><p>下面在仔细研究一下这种情况。假定一个方法试图将一个参数增加至3倍：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void tripleValue(double x) &#123;    x &#x3D; 3 * x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后调用这个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">double percent &#x3D; 10;tripleValue(percent);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不过这样并不能起作用。调用这个方法之后，percent的值还是10。下面看一下具体的执行过程：</p><ol><li>x初始化为percent值的一个副本（也就是10）。</li><li>x乘以3之后等于30，但是percent仍然是10.</li><li>这个方法结束后，参数变量x不再使用。然而，有两种类型的方法参数：</li></ol><ul><li>基本数据类型（数字、布尔值）。</li><li>对象引用。</li></ul><p>你已经看到，一个方法不可能修改基本数据类型的参数，而对象引用作为参数就不同了，可以很容易地利用下面这个方法将一个员工的工资增加至三倍：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void trpleSalary(Employee x)&#123;    x.raiseSalary(200);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">harry &#x3D; new Employee(...);tripleSalary(harry);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>具体过程为：</p><ol><li>x初始化为harry值的一个副本，这里就是一个对象引用。</li><li>raiseSalary方法应用于这个对象引用。x 和 harry 同时引用的那个 Employee对象的工资提高了200%。</li><li>方法结束后，参数变量x不再使用。当然，对象harry继续引用那个工资增至3倍的员工对象。</li></ol><p>​可以看出，实现一个改变参数状态的方法是完全可以的，实际上也相当常见。方法得到的是对象引用的副本，原来的对象引用和这个副本都引用同一个对象。</p><p>​很多程序设计语言提供了两种参数传递的方式：按值调用和按引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以很有必要给出一个反例来-详细来说明一下这个问题。</p><p>​首先，编写一个交换两个Employee对象的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void swap(Employee x,Employee y)&#123;    Employee temp &#x3D; x;    x &#x3D; y;    y &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​这个过程说明：Java程序设计语言对对象采用的不是按引用调用，实际上，对象引用是按值传递的。</p><p>​下面总结一下再Java中对方法参数能做说明和不能做什么：</p><ul><li>方法不能修饰基本数据类型的参数（即数值型或布尔型）。</li><li>方法可以改变对象参数的状态。</li><li>方法不能让一个对象参数引用一个新对象。</li></ul><h2 id="4-4-构造方法（Constructor）"><a href="#4-4-构造方法（Constructor）" class="headerlink" title="4.4 构造方法（Constructor）"></a>4.4 构造方法（Constructor）</h2><ol><li><p>构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化。换句话说：构造方法使用来创建对象，并且同时个对象的属性赋值。（注意：实例变量系统会赋默认值。）</p></li><li><p>&#x3D;&#x3D;当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法。&#x3D;&#x3D;（而这个构造方法被称为缺省构造器。）</p></li><li><p>使用new运算来调用构造方法。</p></li><li><p>构造方法的语法结构是</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">[修饰符列表] 构造方法名(形式参数列表)&#123;    构造方法体;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 普通方法的语法构造是</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;    方法体;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 可以看出构造方法没有返回值类型</p><p> 注意：</p><p> ​<strong>第一：修饰符列表目前统一写：public。千万不要写public static。</strong></p><p> ​<strong>第二：构造方法名和类名必须一致。</strong></p><p> ​<strong>第三：构造方法不需要指定返回值类型，也不能写void，写上void就表示普通方法了。</strong></p><p> ​    <strong>第四：通常再构造方法体中给属性赋值，完成属性的初始化。</strong></p><p> 我们先写一个类测试</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Studnet&#123;int no;String name;int age;public Studnet()&#123;System.out.println(&quot;无参数的构造方法执行了！&quot;)&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 用另你个类来调用</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ConstrouctorTest01&#123;public static void main(String[] args) &#123;new Student();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 以上输出结果为:<code>无参数的构造方法执行了！</code></p></li><li><p>当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。这个无参构造方法叫做缺省构造器。</p><p> 当一个类中手动的提供了构造方法，那么系统将不再提供无参数构造方法。</p><p> 无参数构造方法，和有参数的构造方法都可以调用。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">Student x &#x3D; new Student();Student x &#x3D; new Student(123);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 从以上看出构造方法是支持方法重载的。</p><p> 再一个类中构造方法可以有多个。</p><p> 并且所有的构造名字都是一样的。</p><p> 方法重载特点：</p><p> ​在同一个类中，方法名相同，参数列表不同。</p></li><li><p>思考：实例变量没有手动赋值的时候，实际上系统会默认赋值，那么这个默认赋值操作是在什么时间进行的？</p><p> <strong>实例变量是在构造方法执行的过程中完成初始化的，完成赋值的。</strong></p><p> 也可以手动赋值：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Vip&#123;    long no;    String name;    String birth;    boolean sex;        &#x2F;&#x2F; 无参数构造方法    public Vip()&#123;        &#x2F;&#x2F;这里隐藏了四行代码(没有手动赋值系统都会默认赋值)        &#x2F;*        no &#x3D; 0L;        name &#x3D; null;        birth &#x3D; null;        boolean &#x3D; false;        *&#x2F;    &#125;    &#x2F;&#x2F; 有参数构造方法    public Vip(long huiYuanHao, String xingMing)&#123;        &#x2F;&#x2F; 给实例变量赋值【初始实例变量，初始化属性】        no &#x3D; huiyuanhao;        name &#x3D; xingMing;        &#x2F;&#x2F; 实际上这里还有两行代码(没有手动赋值系统都会默认赋值)        &#x2F;*        birth &#x3D; null;        sex &#x3D; false;        *&#x2F;    &#125;        &#x2F;&#x2F; 有参数的构造方法    public Vip(long huiYuanhao,String xingMing, String shengRi)&#123;        no &#x3D; huiYuanHao;        name &#x3D; xingMing;        birth &#x3D; shengRi;        &#x2F;&#x2F; 实际上这里还有一行代码(没有手动赋值系统都会默认赋值)        &#x2F;&#x2F; sex &#x3D; false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="4-5-封装"><a href="#4-5-封装" class="headerlink" title="4.5 封装"></a>4.5 封装</h2><ol><li><p>有人封装，才有继承，有人继承，才能说多态。</p></li><li><p>面向对象的首要特征：封装</p><p> 什么是封装？有什么用？</p><p> 现实生活中有很多实现的例子都是封装的，例如：</p><p> 手机，电视机，笔记本电脑，照相机，这些都是外部有一个坚硬的外壳。</p><p> 封装起来，保护内部的部件。保证内部的部件是安全的。另外封装之后，对于我们使用者来说，我们是看不见内部的复杂结构的，我们也不要关系内部有多复杂，我们只需要操作外壳儿上的几个按钮就可以完成操作。</p><p>  所以封装有两个作用：</p><p> ​第一个作用：保证内部结构的安全。</p><p> ​第二个作用：屏蔽复杂，暴露简单。</p><p> 在代码级别上，封装有什么用？</p><p> ​一个代码体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。另外类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。</p></li><li><p>不封装有什么缺点</p><p>实例变量是暴露的，在外部程序中可以随意访问。导致了不安全。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person&#123;    int age;&#x2F;&#x2F;age属性是暴露的，在外部程序中可以随意访问。导致了不安全。&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>怎么进行封装，代码怎么实现？</p><p> 第一步：属性私有化（使用private关键词进行修饰。）</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person&#123;    &#x2F;&#x2F; private 表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。    &#x2F;&#x2F; 出了这个类，age属性就无法访问了。私有的。    private int age;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 第二步：对外提供简单的操作入口。</p><p> 但是private外部彻底不能访问了。太过于安全。</p><p> 写一个方法专门来完成读。（get）</p><p> 写一个方法专门来完成写。（set）</p><p> <em>那么get和set方法需不需要带有static</em> ？</p><p> get和set方法都是操作一个对象的。所以不需要用带带有static</p><p> ​<em>java开发规范有要求，set方法和get方法要满足以下格式。</em></p><p> <em>get方法的要求</em></p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public  返回值类型 get+属性名（首字母大写，无参）&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <em>set方法的要求：</em></p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public void set+属性名(首字母大写，有一个参数)&#123;    xxx &#x3D; 参数;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> &#x3D;&#x3D;get方法&#x3D;&#x3D;</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public int getAge ()&#123;    return age;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> &#x3D;&#x3D;set方法&#x3D;&#x3D;</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public void setAge (int nianLing)&#123;    age &#x3D; nianLing;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <strong>读调用getAge()方法</strong></p><p> <strong>改调用setAge()方法</strong></p><p>  1个属性对外提供两个set和get方法。外部程序只能通过set方法修改，只能通过get方法读取，可以set方法种设立关卡来保证数据的安全性。</p></li></ol><h2 id="4-6-静态字段和静态方法"><a href="#4-6-静态字段和静态方法" class="headerlink" title="4.6 静态字段和静态方法"></a>4.6 静态字段和静态方法</h2><p><strong>&#x3D;&#x3D;static:&#x3D;&#x3D;</strong></p><ol><li>static 翻译为“静态”</li><li>所有static 关键字修饰的都是类相关，类级别的。</li><li>所有static修饰的，都是采用“类名.”的方式访问。</li><li>static 修饰的变量：静态变量</li><li>static修饰的方法：静态方法</li></ol><p>变量的分类：</p><p>​变量根据声明的位置进行划分：</p><p>​在方法体中声明的变量叫做：局部变量。</p><p>​在方法体外声明的变量叫做：成员变量。</p><p>​成员变量又可分为：</p><p>​实例变量</p><p>​静态变量</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class VarTest&#123;    &#x2F;&#x2F; 成员变量中的实例变量    int i;    &#x2F;&#x2F; 实例方法    public void m2()&#123;            &#125;       &#x2F;&#x2F; 成员变量中的静态变量    static int k;    &#x2F;&#x2F;静态方法public static void m1()&#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重：</p><p><strong>实例的，都是对象相关的，访问时采用“引用.”的方式。需要先new对象，才能访问，可能会出现空指针异常</strong></p><p><strong>静态的，都是类相关的，采用“类名.”的方式访问。不需要new对象。没有空指针异常的发生。</strong></p><p>什么时候变量声明为实例的，什么时候声明为静态的？</p><p>​如果这个类型的所有对象的莫个属性值都是一样的，不建议定义为实例变量，浪费内存空间。建议定义类级别特征，定义为静态变量，在方法区中只保留一份，节省内存开销。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StaticTest&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F; 访问中国人的国际        &#x2F;&#x2F; 静态变量应该使用类名.的方式访问        System.out.println(Chinese.country);        Chinese c1 &#x3D; new Chinese(&quot;1231456456456456&quot;,&quot;张三&quot;);        Chinese c1 &#x3D; new Chinese(&quot;7897897896748564&quot;,&quot;李四&quot;);    &#125;&#125;&#x2F;&#x2F; 定义一个类：中国人class Chinese&#123;    &#x2F;&#x2F; 身份证号，每个人的身份证号不同，所以身份证号应该时实例变量，一个对象一份。    String idCard;    &#x2F;&#x2F; 姓名，姓名也是一个人一个姓名，姓名也应该时实例变量。    String name;    &#x2F;&#x2F;国籍，对于“中国人”这个类来说，国籍都是“中国”，不会随着对象的改变而改变。    static String country &#x3D; &quot;中国&quot;;    public Chinese()&#123;            &#125;    public Chinese(String s1,String s2)&#123;        idCard &#x3D; s1;        name &#x3D; s2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码的内存图如下：</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200717105233604-1996303203.png" alt="image-20200716124934036"></p><blockquote><p><strong>静态方法</strong></p></blockquote><p>同样静态方法也不需要new对象，直接使用“类名.”来访问</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StaticTest04&#123;    public static void main(String[] args)&#123;       &#x2F;&#x2F; 调用静态方法        StaticTest04.doSome();        &#x2F;&#x2F; 调用实例方法        StaticTest04 st &#x3D; new StaticTest04();        st.doOther();    &#125;    public static void doSome()&#123;&#x2F;&#x2F;静态方法            &#125;    public void doOther()&#123;&#x2F;&#x2F; 实例方法            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>静态代码块</p></blockquote><ol><li><p>使用static关键词可以定义：静态代码块</p></li><li><p>静态代码块的语法</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">static &#123;    java语句;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>static 静态代码块在类加载时执行。并且只执行一次。静态代码块有这样的特征 &#x2F; 特点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;以下代码输出结果为&#x2F;*ABCHello World！*&#x2F;public class StaticTest06&#123;    &#x2F;&#x2F; 静态代码块    static &#123;        System.out.println(&quot;A&quot;);    &#125;    &#x2F;&#x2F; 一个类中可以编写多个静态代码块    static &#123;        System.out.println(&quot;B&quot;);    &#125;        public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;    static&#123;        System.out.println(&quot;C&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以可以看出静态代码块在类加载时执行，并且在main方法执行前执行。静态代码一般是按照自上而下执行。</p></li><li><p>静态代码块的作用：</p><p> 第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西）。</p><p> 第二：静态代码块这种语法实际上是SUN公司给我们java程序员的一个特殊的时刻 &#x2F; 时机。这个时机叫做：类加载时机。</p><p> 具体的业务：</p><p> 记录类加载的日志信息，<strong>这些日志信息写到静态代码块中。</strong></p></li><li><p>静态代码块也是之上而下执行的。</p></li></ol><blockquote><p>实例代码块</p></blockquote><p>除了静态代码块以外还有实例代码块</p><p>实例语句语法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#123;    java语句;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实例语块什么时候执行：</p><p>​只要是构造方法执行，必然在构造方法之前，自动执行“实例语块”中的代码。实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 以下代码执行结果为&#x2F;*main begin实例语句块执行！无参数构造方法实例语句块执行！无参数构造方法*&#x2F;public class InstanceCode&#123;&#x2F;&#x2F;入口public static void main(String[] args)&#123;System.out.println(&quot;main begin&quot;);new InstanceCode();new InstanceCode();&#125;&#x2F;&#x2F;实例语句块&#123;System.out.println(&quot;实例语句块执行！&quot;);&#125;&#x2F;&#x2F; Constructorpublic InstanceCode()&#123;System.out.println(&quot;无参数构造方法&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;this&#x3D;&#x3D;</p><ul><li>this的作用: <ul><li>this表示的是当前对象本身，</li><li>更准确地说，this代表当前对象的一个引用。 this保存当前对象的内存地址，指向自身。</li></ul></li><li>普通方法（实例方法）中使用this。<ul><li>区分类成员属性和方法的形参. </li><li>调用当前对象的其他方法（可以省略）</li><li>位置：任意</li></ul></li><li>构造方法中使用this。<ul><li>使用this来调用其它构造方法 </li><li>位置：必须是第一条语句</li></ul></li><li>this不能用于static方法。<ul><li>因为this代表的是当前对象，而静态方法的调用不需要对象。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThisTest01&#123;public static void main(String[] args)&#123;Customer c1 &#x3D; new Customer(&quot;张三&quot;);c1.shopping();Customer c2 &#x3D; new Customer(&quot;李四&quot;);c2.shopping();Customer.doSome();&#125;&#125;&#x2F;&#x2F; 顾客类class Customer&#123;&#x2F;&#x2F; 属性&#x2F;&#x2F; 实例变量（必须采用“引用.”的方式访问）String name;   &#x2F;&#x2F;构造方法public Customer()&#123;&#125;public Customer(String s)&#123;name &#x3D; s;&#125;&#x2F;&#x2F; 顾客购物的方法&#x2F;&#x2F; 实例方法public void shopping()&#123;&#x2F;&#x2F; 这里的this是谁？this是当前对象。&#x2F;&#x2F; c1调用shopping(),this是c1&#x2F;&#x2F; c2调用shopping(),this是c2&#x2F;&#x2F;System.out.println(this.name + &quot;正在购物!&quot;);&#x2F;&#x2F; this. 是可以省略的。&#x2F;&#x2F; this. 省略的话，还是默认访问“当前对象”的name。System.out.println(name + &quot;正在购物!&quot;);&#125;&#x2F;&#x2F; 静态方法public static void doSome()&#123;&#x2F;&#x2F; 错误: 无法从静态上下文中引用非静态 变量 this&#x2F;&#x2F;System.out.println(this);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>this关键字大部分情况下可以省略，什么时候不能省略呢？<br>    在实例方法中，或者构造方法中，为了区分局部变量和实例变量，<br>    这种情况下：this. 是不能省略的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThisTest03&#123;public static void main(String[] args)&#123;Student s &#x3D; new Student();s.setNo(111);s.setName(&quot;张三&quot;);System.out.println(&quot;学号：&quot; + s.getNo());System.out.println(&quot;姓名：&quot; + s.getName());Student s2 &#x3D; new Student(2222, &quot;李四&quot;);System.out.println(&quot;学号：&quot; + s2.getNo());System.out.println(&quot;姓名：&quot; + s2.getName());&#125;&#125;&#x2F;&#x2F; 分析一下：以下代码哪里写的不好。&#x2F;&#x2F; 学生类class Student&#123;&#x2F;&#x2F;学号private int no;&#x2F;&#x2F;姓名private String name;&#x2F;&#x2F;构造方法无参public Student()&#123;&#125;&#x2F;&#x2F;构造方法有参&#x2F;*public Student(int i, String s)&#123;no &#x3D; i;name &#x3D; s;&#125;*&#x2F;&#x2F;&#x2F; 上面的构造方法也增强以下可读性public Student(int no, String name)&#123;this.no &#x3D; no;this.name &#x3D; name;&#125;&#x2F;&#x2F; setter and getter方法&#x2F;*public void setNo(int i)&#123;no &#x3D; i;&#125;*&#x2F;&#x2F;*public void setNo(int no)&#123; &#x2F;&#x2F; 就近原则。no &#x3D; no; &#x2F;&#x2F;这两个no都是局部变量no，和实例变量no没关系。&#125;*&#x2F;public void setNo(int no)&#123; &#x2F;&#x2F;no是局部变量&#x2F;&#x2F;this.no 是指的实例变量。this.no &#x3D; no; &#x2F;&#x2F; this. 的作用是：区分局部变量和实例变量。&#125;public int getNo()&#123;return no;&#x2F;&#x2F;return this.no;&#125;&#x2F;*public void setName(String s)&#123;name &#x3D; s;&#125;*&#x2F;&#x2F;*public void setName(String name)&#123; &#x2F;&#x2F; 就近原则name &#x3D; name; &#x2F;&#x2F;这两个name都是局部变量name，和实例变量name没关系。&#125;*&#x2F;public void setName(String name)&#123;this.name &#x3D; name;&#125;public String getName()&#123;return name;&#x2F;&#x2F; 严格来说，这里是有一个 this. 的。只不过这个 this. 是可以省略的。&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>this用在构造方法中。</p><p>通过当前的构造方法去调用另一个本类的构造方法，可以使用以下语法格式：<br>        this(实际参数列表);<br>            <strong>通过一个构造方法1去调用构造方法2，可以做到代码复用</strong>。<br>            但需要注意的是：<strong>“构造方法1”和“构造方法2” 都是在同一个类当中。对于this()的调用只能出现在构造方法的第一行。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Date&#123;int year;int month;int day;&#x2F;&#x2F; 构造方法无参public Date()&#123;        &#x2F;&#x2F; 用该构造方法方法调用另一个构造方法this(2020, 7, 16);&#125;&#x2F;&#x2F; 构造方法有参数public Date(int year, int month, int day)&#123;this.year &#x3D; year;this.month &#x3D; month;this.day &#x3D; day;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="第5章-继-承"><a href="#第5章-继-承" class="headerlink" title="第5章 继  承"></a>第5章 继  承</h1><p>继承的基本思想是，可以基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使用新类能够适应新的情况。这是Java程序设计中的一项核心技术。</p><h2 id="5-1-继承的实现"><a href="#5-1-继承的实现" class="headerlink" title="5.1 继承的实现"></a>5.1 继承的实现</h2><p>java中继承的语法格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class 类名 extends 父类名&#123;    类体;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>① B类继承 A类，则称 A类为超类(superclass)、<strong>父类</strong>、基类，B类则称为子类(subclass)、 派生类、扩展类。 </p><p>② <strong>java 中的继承只支持单继承，不支持多继承</strong>，C++中支持多继承，这也是 java 体 现简单性的一点，换句话说，java 中不允许这样写代码：<code>class B extends A,C&#123; &#125;</code>。 </p><p>③ 虽然 java 中不支持多继承，<strong>但有的时候会产生间接继承的效果</strong>，例如：class C extends B，class B extends A，也就是说，C 直接继承 B，其实 C 还间接继承 A。 </p><p>④ java 中规定，<strong>子类继承父类，除构造方法，剩 下都可以继承</strong>，<strong>但是私有的属性（private）无法在子类中直接访问。</strong> </p><p>⑤ <strong>java 中的类没有显示的继承任何类，则默认继承 Object 类，Object 类是 java 语言 提供的根类</strong>（老祖宗类），也就是说，一个对象与生俱来就有 Object 类型中所有的特征。 </p><p>⑥ 继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的 耦合度非常高，Account 类发生改变之后会马上影响到 CreditAccount 类。（&#x3D;&#x3D;即父类修改，之类受牵连&#x3D;&#x3D;）</p><p>在实际开发中，凡是采用“is a”能描述的都可以继承。</p><blockquote><p>5.2.2 覆盖方法</p></blockquote><pre><code> 父类中的有些方法对之类并不一定适用。为此，需要提供一个新的方法来覆盖（override）父类中的这个方法。</code></pre><p><strong>【示例5-3】方法重写</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestOverride &#123;    public static void main(String[] args) &#123;        Vehicle v1 &#x3D; new Vehicle();        Vehicle v2 &#x3D; new Horse();        Vehicle v3 &#x3D; new Plane();        v1.run();        v2.run();        v3.run();    &#125;&#125; class Vehicle &#123; &#x2F;&#x2F; 父类，交通工具类    public void run() &#123;        System.out.println(&quot;跑....&quot;);    &#125;&#125;class Horse extends Vehicle &#123; &#x2F;&#x2F; 马也是交通工具    public void run() &#123; &#x2F;&#x2F; 重写父类方法        System.out.println(&quot;四蹄翻飞，嘚嘚嘚...&quot;);    &#125;&#125; class Plane extends Vehicle &#123;    public void run() &#123; &#x2F;&#x2F; 重写父类方法        System.out.println(&quot;天上飞！&quot;);    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;当我们代码怎么编写的时候，在代码级别上构成了方法覆盖呢？&#x3D;&#x3D;<br>        条件一：两个类必须要有继承关系。<br>        条件二：重写之后的方法和之前的方法具有：<br>                    <strong>相同的返回值类型、</strong><br>                    <strong>相同的方法名、</strong><br>                    <strong>相同的形式参数列表。</strong><br>        条件三：<strong>访问权限不能更低，可以更高</strong>。（这个先记住。）<br>        条件四：<strong>重写之后的方法不能比之前的方法抛出更多的异常，可以更少</strong>。（后面讲异常的时候解释）</p><p><strong>重要结论</strong>：<br>        当子类对父类继承过来的方法进行“方法覆盖”之后，<br>        子类对象调用该方法的时候，一定执行覆盖之后的方法。</p><p><strong>这里还有几个注意事项：</strong>（当学习了多态语法之后自然就明白了！）<br>        注意1：方法覆盖只是针对于方法，和属性无关。<br>        注意2：私有方法无法覆盖。<br>        注意3：构造方法不能被继承，所以构造方法也不能被覆盖。<br>        注意4：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。</p><h2 id="5-2-多态"><a href="#5-2-多态" class="headerlink" title="5.2 多态"></a>5.2 多态</h2><p> 多态指的是同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。如果没有多态，我们需要写很多重载的方法。</p><p>多态在开发可以降低耦合度，提高程序的扩展力。</p><p>​例如，可以将子类的对象赋给父类变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Animal &#123;    public void shout() &#123;        System.out.println(&quot;叫了一声！&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void shout() &#123;        System.out.println(&quot;旺旺旺！&quot;);    &#125;    public void seeDoor() &#123;        System.out.println(&quot;看门中....&quot;);    &#125;&#125;class Cat extends Animal &#123;    public void shout() &#123;        System.out.println(&quot;喵喵喵喵！&quot;);    &#125;    public void catchMouse()&#123;System.out.println(&quot;猫正在抓老鼠！！！！&quot;);&#125;&#125;public class TestPolym &#123;    public static void main(String[] args) &#123;        Animal a1 &#x3D; new Cat(); &#x2F;&#x2F; 向上可以自动转型        &#x2F;&#x2F;传的具体是哪一个类就调用哪一个类的方法。大大提高了程序的可扩展性。        animalCry(a1);        Animal a2 &#x3D; new Dog();        animalCry(a2);&#x2F;&#x2F;a2为编译类型，Dog对象才是运行时类型。                 &#x2F;&#x2F;编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。        &#x2F;&#x2F; 否则通不过编译器的检查。        Dog dog &#x3D; (Dog)a2;&#x2F;&#x2F;向下需要强制类型转换        dog.seeDoor();    &#125;     &#x2F;&#x2F; 有了多态，只需要让增加的这个类继承Animal类就可以了。    static void animalCry(Animal a) &#123;        a.shout();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多态的基础语法：<br>        1、学习多态基础语法之前，我们需要普及两个概念：<br>            第一个：<strong>向上转型</strong><br>                子 —&gt; 父（自动类型转换）<br>            第二个：<strong>向下转型</strong>(如果调用的是子类中特有的方法，就要进行向下转型)<br>                父 —&gt; 子（强制类型转换，需要加强制类型转换符）</p><pre class="line-numbers language-none"><code class="language-none">注意：java中允许向上转型，也允许向下转型。无论是向上转型，还是向下转型，两种类型之间必须有继承关系，没有继承关系编译器报错。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>多态表示多种形态：<br>                编译的时候一种形态。<br>                运行的时候另一种形态。</p><blockquote><p>instanceof运算符（运行阶段动态判断）</p></blockquote><p>  instanceof是二元运算符，左边是对象，右边是类</p><ol><li><p>instanceof 可以在运行阶段动态判断引用指向的对象的类型。</p></li><li><p>instanceof的语法：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">引用 instanceof 类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>instanceof运算符的运算结果只能是true &#x2F; false</p></li><li><p>假设（c instanceof b）为true：</p><p> ​c引用指向的堆内存中的java对象是一个b。</p><p> 假设（c instanceof b）为false表示：</p><p> ​c引用指向的堆内存中的java对象不是一个b。</p></li></ol><p>在多态的强制类型转换中容易出现风险</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Animal a6 &#x3D; new Dog();Cat y &#x3D; (Cat)a6;&#x2F;&#x2F; &#x2F;&#x2F;表面上a6是一个Animal，运行的时候实际上是一条狗。&#x2F;* 运行阶段，堆内存实际创建的对象是：Dog对象。在实际运行过程中，拿着Dog对象转换成Cat对象就不行了。因为Dog和Cat之间没有继承关系。运行是出现异常，这个异常和空指针异常一样非常重要，也非常经典：java.lang.ClassCastException：类型转换异常。   *&#x2F;y.catchMouse(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免这种异常，这里就用到了instanceof运算符：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (a6 instanceof cat)&#123;&#x2F;&#x2F; 如果a6是一只Cat，进行强制类型转换    Cat y &#x3D; (Cat)a6;    y.catchMouse();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>方法覆盖需要和多态机制联合起来才有意义。没有多态机制的话，方法覆盖可有可无。没有多态机制，方法覆盖也可以没有，如果父类的方法无法满足子类业务需求的时候，子类完全可以定义一个全新的方法。</p></li><li><p>静态方法存在方法覆盖吗？</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class OverrideTest05&#123;public static void main(String[] args)&#123;&#x2F;&#x2F; 静态方法可以使用“引用.”来调用吗？可以&#x2F;&#x2F; 虽然使用“引用.”来调用，但是和对象无关。Animal a &#x3D; new Cat(); &#x2F;&#x2F;多态&#x2F;&#x2F; 静态方法和对象无关。&#x2F;&#x2F; 虽然使用“引用.”来调用。但是实际运行的时候还是：Animal.doSome()a.doSome(); &#x2F;&#x2F; 输出为结果为：Animal的doSome方法执行！Animal.doSome();&#x2F;&#x2F; 输出为结果为：Animal的doSome方法执行！Cat.doSome();&#x2F;&#x2F; 输出结果为：Cat的doSome方法执行！&#125;&#125;class Animal&#123;&#x2F;&#x2F; 父类的静态方法public static void doSome()&#123;System.out.println(&quot;Animal的doSome方法执行！&quot;);&#125;&#125;class Cat extends Animal&#123;&#x2F;&#x2F; 尝试在子类当中对父类的静态方法进行重写public static void doSome()&#123;System.out.println(&quot;Cat的doSome方法执行！&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> ​多态自然就和对象有关系了。而静态方法的执行不需要对象。所以，一般情况下，我们会说静态方法“不存在”方法覆盖。不探讨静态方法的覆盖。</p><p> ​学习了多态之后：</p><p> ​返回值类型是基本类型来说，必须一致。</p><p> ​对于返回值类型是引用数据类型来说，重写之后返回值类型可以变得更小（但意义不大，实际开发中没有用）</p></li></ol><h2 id="5-3-super关键字"><a href="#5-3-super关键字" class="headerlink" title="5.3 super关键字"></a>5.3 super关键字</h2><p>super和this要对比这学习。</p><p>回顾一下this：</p><ol><li><p>this能出现在实例方法中和构造方法中。</p></li><li><p>this的语法是：”this.“、”this()“</p></li><li><p>this不能使用在静态方法中。</p></li><li><p>this. 大部分情况下可以省略的。</p></li><li><p>this. 在局部变量和实例变量的时候不能省略的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void setName(String name)&#123;    this.name &#x3D; name;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>this() 只能出现在构造方法第一行，通过当前的构造方法去调用”本类“中其他的构造方法，目的是：代码复用。</p></li></ol><p>&#x3D;&#x3D;super：&#x3D;&#x3D;</p><ol><li><p>super能出现在实例方法中和构造方法中。</p></li><li><p>super的语法是：”super.“、”super()“</p></li><li><p>super不能使用在静态方法中。</p></li><li><p>super. 大部分情况下可以省略的。</p></li><li><p>super() 只能出现在构造方法第一行，通过当前的构造方法去调用”父类“中其他的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。</p></li></ol><p> 3、super()<br>        表示通过子类的构造方法调用父类的构造方法。<br>        模拟现实世界中的这种场景：要想有儿子，需要先有父亲。</p><p>重要的结论：<br>    当一个构造方法第一行：<br>        既没有this()又没有super()的话，默认会有一个super();<br>        表示通过当前子类的构造方法调用父类的无参数构造方法。<br>        所以必须保证父类的无参数构造方法是存在的。</p><p>注意：<br>    this()和super() 不能共存，它们都是只能出现在构造方法第一行。无论是怎样折腾，父类的构造方法是一定会执行的。</p><p><strong>super关键字的使用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestSuper &#123;     public static void main(String[] args) &#123;        new ChildClass().f();public class SuperTest01&#123;public static void main(String[] args)&#123;&#x2F;&#x2F; 创建子类对象&#x2F;*A类的无参数构造方法！B类的无参数构造方法！*&#x2F;new B();&#125;&#125;class A extends Object&#123;&#x2F;&#x2F; 建议手动的将一个类的无参数构造方法写出来。public A()&#123;&#x2F;&#x2F;super(); &#x2F;&#x2F; 这里也是默认有这一行代码的。System.out.println(&quot;A类的无参数构造方法！&quot;);&#125;public A(int i)&#123;&#x2F;&#x2F;super();System.out.println(&quot;A类的有参数构造方法(int)&quot;);&#125;&#125;class B extends A&#123;public B()&#123;this(&quot;zhangsan&quot;);&#x2F;&#x2F; 调用父类中有参数的构造方法&#x2F;&#x2F;super(123);System.out.println(&quot;B类的无参数构造方法！&quot;);&#125;public B(String name)&#123;super();System.out.println(&quot;B类的有参数构造方法(String)&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><p><strong>重：父中有，子中又有，如果想在子中访问“父的特征”，super. 不能省略。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SuperTest05&#123;public static void main(String[] args)&#123;Vip v &#x3D; new Vip(&quot;张三&quot;);v.shopping();&#125;&#125;class Customer &#123;String name;public Customer()&#123;&#125;public Customer(String name)&#123;super();this.name &#x3D; name;&#125;public void doSome()&#123;System.out.println(this.name + &quot; do some!&quot;);System.out.println(name + &quot; do some!&quot;);&#x2F;&#x2F;错误: 找不到符号&#x2F;&#x2F;System.out.println(super.name + &quot; do some!&quot;);&#125;&#125;class Vip extends Customer&#123;&#x2F;&#x2F; 假设子类也有一个同名属性&#x2F;&#x2F; java中允许在子类中出现和父类一样的同名变量&#x2F;同名属性。String name; &#x2F;&#x2F; 实例变量public Vip()&#123;&#125;public Vip(String name)&#123;super(name);&#x2F;&#x2F; this.name &#x3D; null;&#125;public void shopping()&#123;&#x2F;*java是怎么来区分子类和父类的同名属性的？this.name：当前对象的name属性super.name：当前对象的父类型特征中的name属性。*&#x2F;System.out.println(this.name + &quot;正在购物!&quot;); &#x2F;&#x2F; null 正在购物System.out.println(super.name + &quot;正在购物!&quot;); &#x2F;&#x2F; 张三正在购物System.out.println(name + &quot;正在购物!&quot;); &#x2F;&#x2F;null 正在购物&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-final关键字"><a href="#5-4-final关键字" class="headerlink" title="5.4 final关键字"></a>5.4 final关键字</h2><p>继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。<strong>final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</strong></p><p>声明格式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class A&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样A类就不能被继承了</p><p>​类中的某个特定方法也可以被声明为final。如果这样做，子类就不能覆盖整个方法（final类中的所有方法自动地成为final方法）。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class C&#123;    public final void doSome() &#123;        System.out.println(&quot;C&#39;s doSome&quot;);    &#125;&#125;&#x2F;&#x2F; 子类继承父类class D extends C&#123;    &#x2F;&#x2F; 这样会报错，因为被覆盖的方法为final    public void doSome() &#123;        System.out.println(&quot;D&#39;s doSome&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​用final修饰局部变量，如果这样做，一旦赋值了就不能重新赋值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FinalTest&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F; 局部变量        final int k &#x3D; 100;                &#x2F;&#x2F; 重新赋值,错误，无法为最终变量k分配值        k &#x3D; 300    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><p>​final修饰引用变量，要记住final修饰的变量只能赋值一次值（万变不离其宗），并且在该方法执行过程中，该引用指向对象之后，该对象不会被垃圾回收器回收。直到当前方法结束，才会释放空间。<strong>虽然final的引用指向一个对象后，不能再重新指向另一个对象。但是该对象的数据可以被修改的。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FinalTest&#123;    public static void main(String[] args)&#123;        Person p1 &#x3D; new Person(20);        System.out.println(p1.age);                &#x2F;&#x2F; final修饰引用        final Person p &#x3D; new Person(30);        &#x2F;&#x2F; 编译报错         p &#x3D; new Person(30);    &#125;&#125;class Person&#123;    int age;    public Person()&#123;            &#125;    public Person(int age)&#123;        this.age &#x3D; age;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>final修饰实例变量，同样final修饰的变量只能赋值一次。但是我们以前的实例变量都是系统赋默认值，&#x3D;&#x3D;final修饰的实例变量，系统不赋默认值，要求程序员必须手动赋值。&#x3D;&#x3D;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FinalTest&#123;    public static void main(String[] args)&#123;            &#125;&#125;class User &#123;    &#x2F;&#x2F; 手动赋值    final double height &#x3D; 1.8;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修饰的实例变量一般添加static修饰。static final联合修饰的变量称为常量</strong>。常量名建议全部大写，每个单词之间用下划线衔接。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Chinese&#123;    static final String COUNTRY &#x3D; &quot;中国&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-5-抽象类"><a href="#5-5-抽象类" class="headerlink" title="5.5 抽象类"></a>5.5 抽象类</h2><p>​包含抽象方法的类就是抽象类。通过 <strong>abstract</strong> 方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。</p><p><strong>抽象类无法实例化，无法创建对象</strong>：</p><p>​因为抽象类是类和类之间共同特征的类再进一步抽象形成了抽象类。由于类本身是不存在的，所以抽象类无法创建对象。</p><p>抽象类和抽象类实际上可能还会有共同特征，还可以进一步抽象。</p><blockquote><p>抽象类属于声明类型？</p></blockquote><p>答：抽象类属于引用数据类型。</p><blockquote><p>抽象类的定义</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">修饰符列表 abstract class 类名&#123;    类体;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为抽象类是无法创建对象的，所以抽象类是用来被子类继承的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象类final abstract class Account&#123;    &#125;&#x2F;&#x2F; 子类继承抽象类，子类可以实例化对象class CreaditAccount extends Account&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为抽象类是用来被继承的所以 <strong>abstract</strong> 和 <strong>final</strong>  是死对头，不能同时用在一个类上。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 错误：非法的修饰符组合：abstract 和 finalfinal abstract class Account&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>抽象类的子类可以是抽象类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象类final abstract class Account&#123;    &#125;&#x2F;&#x2F; 子类 ,子类可以是抽象类abstract class CreaditAccount extends Account&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法供子类使用。</p><blockquote><p><strong>抽象方法</strong></p></blockquote><pre><code> 使用 abstract 修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract void doSome();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>抽象方法的特点：</p><ol><li>没有方法体（没有大括号），以分号结尾。</li><li>前面修饰符列表中有abstract关键字</li><li>抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中，抽象类中可以有非抽象方法。</li></ol><p>&#x3D;&#x3D;<strong>一个非抽象的类继承抽象类，必须将抽象类中的抽象方法实现（重写）。</strong>&#x3D;&#x3D;</p><h2 id="5-6-接口"><a href="#5-6-接口" class="headerlink" title="5.6 接口"></a>5.6 接口</h2><p>接口也是一种引用数据类型。接口时完全抽象的。（抽象类是半抽象的）或者说接口时特殊的抽象类。接口编译之后也是一个class字节码文件。</p><blockquote><p>接口的定义</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">修饰符列表 interface 接口名 &#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>接口支持多继承，一个接口可以继承多个接口。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 定义接口interface A&#123;    &#125;&#x2F;&#x2F; 定义接口interface B&#123;    &#125;&#x2F;&#x2F; 一个接口可以继承多个接口interface C extends A,B&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然一个接口可以继承多个接口，那么&#x3D;&#x3D;<strong>一个类也可同时继承多个接口</strong>&#x3D;&#x3D;，java中的接口弥补了单继承带来的缺陷例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface A&#123;&#125;interface B&#123;  &#125;class D implements A,B&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>接口中只包含两部分，一部分是：常量。另一部分是：抽象方法。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface MyMath&#123;    &#x2F;&#x2F; 抽象方法    public abstract int sum();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接口中所有的元素都是 <code>public</code> 修饰的。且接口中的抽象方法定义时 <code>public abstract</code>  修饰符可以省略。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 可以将以上代码这样写interface MyMath&#123;    int sum();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接口中的方法都是抽象方法，所以接口中的方法不能有方法体。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface MyMath&#123;    &#x2F;&#x2F; 这样时错误的，接口抽象方法不能带有方法体    int sum()&#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样接口中的常量的 <code>public static final</code>  也可以省略。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface MyMath&#123;    double PI &#x3D; 3.1415926;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类和接口直接进行实现，不过这里不再是 <code>extends</code> 实现用 <code>implements</code>关键字完成。&#x3D;&#x3D;<strong>当一个非抽象类实现接口，必须将接口中所有的抽象方法全部实现（重写、覆盖）</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 接口interface MyMath&#123;    double PI &#x3D; 3.1415926;    int sum(int a, int b);    int sub(int a, int b);&#125;&#x2F;&#x2F; 同样接口也需要重写接口中的方法，（通常叫实现）class MyMathImpl implements MyMath&#123;public int sum(int a , int b)&#123;        return a + b;    &#125;       public int sub(int a, int b)&#123;        return a - b;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口比较特殊：<strong>接口和接口之间进行强转的时候，没有继承关系，也可以强转</strong>。编译器不会报错。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test&#123;    public static void main(String[] args)&#123;        A a &#x3D; new D();        B b2 &#x3D; (B)a;        b2.m2();    &#125;&#125;interface A&#123;    void m1();&#125;interface B&#123;      void m2();&#125;interface C&#123;    void m3();&#125;&#x2F;&#x2F; 类多继承接口class D implements A,B&#123;    public void m1()&#123;        System.out.println();    &#125;    public void m2()&#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上继承和实现可以同时存在，<code>extends</code>  关键字在前，<code>implements</code>  关键字在后。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test04&#123;public static void main(String[] args)&#123;&#x2F;&#x2F; 创建对象Flyable f &#x3D; new Cat(); &#x2F;&#x2F;多态。f.fly();&#125;&#125;&#x2F;&#x2F; 动物类：父类class Animal&#123;&#125;&#x2F;&#x2F; 可飞翔的接口（是一对翅膀）interface Flyable&#123;void fly();&#125;&#x2F;&#x2F; 动物类子类：猫类class Cat extends Animal implements Flyable&#123;public void fly()&#123;System.out.println(&quot;飞猫起飞，翱翔太空的一只猫，很神奇，我想做一只猫！！&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没写 extends，默认继承Object。</p><blockquote><p>类型和类型之间的关系：</p></blockquote><p>is a（继承）、has a（关联）、like a（实现）</p><p>​is a：</p><p>​Cat is a Animal（猫是一个动物）</p><p>​凡是能够满足 is a 的表示“继承关系”</p><p>​A extends B</p><p>​has a:</p><p>​I has a Pen(我有一支笔)</p><p>​凡是能够满足has a 关系的表示“关联关系”</p><p>​关联关系通常以“属性”的形式存在。</p><p>​A{</p><p>​B b;</p><p>​}</p><p>​like a:</p><p>​Cooker like a FoodMenu（厨师像 一个菜单一样）</p><p>​凡是能够 like a 关系的表达“实现关系”</p><p>​实现关系通常是：类实现接口。</p><p>​A implements B</p><blockquote><p>抽象类和接口的区别。</p></blockquote><ol><li><p>抽象类是半抽象的。</p><p> 接口时完全抽象的。</p></li><li><p>抽象类中有构造方法。</p><p>接口中没有构造方法。</p></li><li><p>接口和接口之间支持多继承</p><p> 类和类之间只能单继承。</p></li><li><p>一个类可以同时实现多个接口。</p><p> 一个抽象类只能继承一个类（单继承）。</p></li><li><p>接口中只允许出现常量和抽象方法。</p></li></ol><hr><h1 id="第6章-内部类"><a href="#第6章-内部类" class="headerlink" title="第6章 内部类"></a>第6章 内部类</h1><h2 id="6-1-package-和-import"><a href="#6-1-package-和-import" class="headerlink" title="6.1 package 和 import"></a>6.1 package 和 import</h2><p>package 是 java 中包机制。包机制的作用是为了方便程序的管理。不同功能的类分别存放不同的包下。</p><blockquote><p>package的用法</p></blockquote><p><code>package</code> 是一个关键字，后面加包名。例如：</p><p>package com.baidu.javase;</p><p>注意：package语句只允许出现在java源代码的第一行。</p><blockquote><p>包机制的规范</p></blockquote><p>一般都采用公式域名倒叙的方式（因为公司域名具有全球唯一性。）</p><p>包名命名规范：</p><p>​公司域名倒叙 + 项目名 + 模块名 + 功能名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.baidu.javase;              &#x2F;&#x2F;指定生成的class文件位于com&#x2F;baidu&#x2F;javase目录下public class Test&#123;          public static void main(String args[])&#123;                  System.out.println(&quot;Hello World&quot;);         &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码里出现了<strong>package定义</strong>后,我们打包编译时,<strong>则必须制定路径</strong>才行,打包编译方式有<strong>以下两种</strong>:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">javac  -d  . Test.java                                &#x2F;&#x2F;&quot;-d .&quot;表示生成的包位于当前路径,所以会在当前路径下自动创建com&#x2F;baidu&#x2F;javase 目录,然后再在该目录下生成Test .class javac  -d  .  *.java                          &#x2F;&#x2F;如果当前目录有多个java文件,并且互相引用的时候,则用这个命令,*表示编译所有java文件.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>import导入包的使用</strong></p><p>之前我们学习了使用package包可以将编译出来的class进行分开保存,那么如果想不同包之间互相调用,则需要使用<strong>import关键字</strong>来声明包的入口位置.</p><blockquote><p>import 使用</p></blockquote><p>定义一个CallTest.java文件:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import  com.baidu.javase;  &#x2F;&#x2F;声明Test包类的位置,等价于import  com.baidu.javase.*;public class CallTest&#123;              public static void main(String args[])&#123;                  Test.main(args);                &#x2F;&#x2F;调用Test类的公共静态方法         &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：java.lang不需要导入包名。同包下不需要导入包名。其他一律都需要。</p><h2 id="6-2-访问权限"><a href="#6-2-访问权限" class="headerlink" title="6.2 访问权限"></a>6.2 访问权限</h2><p>前面我们学了三个访问权限是 private(私有的) 还有一个是什么都不加的（比如 <code>int a</code>）最后是 public</p><ol><li><p>访问权限有那些</p><ul><li>private 私有的</li><li>protected 受保护的</li><li>public 公开的</li><li>​             默认</li></ul></li><li><p>这些访问权限的控制范围</p><p> private 表示私有的，只能在本类中访问</p><p> public 表示公开的，在任何位置都可以访问</p><p> “默认”表示只能在本类，以及同包下访问。</p><p> protected 表示只能在本类、同包、子类中访问。</p><table><thead><tr><th>访问控制修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>任意位置</th><th>能修饰什么</th></tr></thead><tbody><tr><td><code>public</code></td><td>可以</td><td>可以</td><td>可以</td><td>可以</td><td>属性、方法、类、接口</td></tr><tr><td><code>protected</code></td><td>可以</td><td>可以</td><td>可以</td><td>不行</td><td>属性、方法</td></tr><tr><td>默认</td><td>可以</td><td>可以</td><td>不行</td><td>不行</td><td>属性、方法、类、接口</td></tr><tr><td><code>private</code></td><td>可以</td><td>不行</td><td>不行</td><td>不行</td><td>属性、方法</td></tr></tbody></table></li></ol><h2 id="6-3-Object：所有类的超类"><a href="#6-3-Object：所有类的超类" class="headerlink" title="6.3 Object：所有类的超类"></a>6.3 Object：所有类的超类</h2><p>​Object类是Java中所有类的祖先，在Java中每个了都扩展了Object。但是并不需要这样写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee extends Object&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-3-1-toString-方法"><a href="#6-3-1-toString-方法" class="headerlink" title="6.3.1 toString 方法"></a>6.3.1 toString 方法</h3><p>​toString方法，他会返回表示对象的一个字符串。Object类中toString方法的源码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String toString() &#123;    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据如上源码得知，默认会返回“类名+@+16进制的hashcode”。在打印输出或者用字符串连接对象时，会自动调用该对象的toString()方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExtendsTest &#123;&#x2F;&#x2F; ExtendsTest默认继承Object&#x2F;&#x2F; ExtendsTest类当中是有toString()方法&#x2F;&#x2F; 不过toString()方法是一个实例方法，需要创建对象才能调用。public static void main(String[] args)&#123;&#x2F;&#x2F; 先new对象ExtendsTest et &#x3D; new ExtendsTest();String retValue &#x3D; et.toString();&#x2F;&#x2F; 2f92e0f4 可以“等同”看做对象在堆内存当中的内存地址。&#x2F;&#x2F; 实际上是内存地址经过“哈希算法”得出的十六进制结果。System.out.println(retValue); &#x2F;&#x2F; ExtendsTest05@2f92e0f4&#x2F;&#x2F; 创建对象Product pro &#x3D; new Product();&#x2F;&#x2F; 调用toString方法System.out.println(pro.toString()); &#x2F;&#x2F;Product@5305068a&#x2F;&#x2F; 如果直接输出“引用”呢？？？？？？？System.out.println(pro); &#x2F;&#x2F; println方法会自动调用pro的toString()方法。&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们很多时候需要对toString方法进行重写，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class OverrideTest04&#123;public static void main(String[] args)&#123;&#x2F;&#x2F;创建学生对象Student s &#x3D; new Student(1111, &quot;zhangsan&quot;);&#x2F;&#x2F; 重写toString()方法之前&#x2F;&#x2F;System.out.println(s); &#x2F;&#x2F;Student@87aac27&#x2F;&#x2F; 重写toString()方法之后&#x2F;&#x2F; 输出一个学生对象的时候，可能更愿意看到学生的信息，不愿意看到对象的内存地址。System.out.println(s.toString());        &#x2F;&#x2F; 当输出一个引用的时候，println方法会自动调用引用的toString方法。System.out.println(s);&#125;&#125;class Student&#123;int no;String name;public Student(int no, String name)&#123;this.no &#x3D; no;this.name &#x3D; name;&#125;    &#x2F;&#x2F; 从Object类中继承过来的那个toString()方法已经无法满足我业务需求了。&#x2F;&#x2F; 我在子类MyDate中有必要对父类的toString()方法进行覆盖&#x2F;重写。public String toString() &#123;return &quot;学号：&quot; + no + &quot;，姓名：&quot; + name;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>强烈建议为自定义的每一个类添加toString方法。这样做不仅自己受益，所有使用这个类的程序员也会从这个日志记录支持中收益。</p><h3 id="6-3-2-equals方法"><a href="#6-3-2-equals方法" class="headerlink" title="6.3.2 equals方法"></a>6.3.2 equals方法</h3><p>​Object 类中的equals方法用于检测一个对象是否等于另一个对象。Object类中实现的equals方法将确定的两个对象引用是否相等。 “&#x3D;&#x3D;”代表比较双方是否相同，如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。</p><pre><code>  Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。比如，我们在公安系统中认为id相同的人就是同一个人、学籍系统中认为学号相同的人就是同一个人。     Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。</code></pre><p>​equals方法的源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean equals(Object obj) &#123;return (this &#x3D;&#x3D; obj);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在Object类中的equals方法当中，默认采用的是“&#x3D;&#x3D; ”判断两个java对象是否相等。而“&#x3D;&#x3D;”判断的是两个java对象的内存地址，我们应该判断两个java对象的内容是否相等。所以老祖宗的equals方法不够用，需要子类重写equals。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyTime &#123; &#x2F;&#x2F;extends Object&#123;int year;int month;int day;public MyTime()&#123;&#125;public MyTime(int year, int month, int day)&#123;this.year &#x3D; year;this.month &#x3D; month;this.day &#x3D; day;&#125;public boolean equals(Object obj) &#123;    &#x2F;&#x2F; 如果obj是空，obj不是一个MyTime，没必要比较了，直接返回falseif(obj &#x3D;&#x3D; null || !(obj instanceof MyTime))&#123;return false;&#125;    &#x2F;&#x2F; 如果this和obj保存的内存地址相同，没必要比较了，直接返回true。if(this &#x3D;&#x3D; obj)&#123;return true;&#125;    &#x2F;&#x2F; 程序能够执行到此处说明什么？&#x2F;&#x2F; 说明obj不是null，obj是MyTime类型。MyTime t &#x3D; (MyTime)obj;return this.year &#x3D;&#x3D; t.year &amp;&amp; this.month &#x3D;&#x3D; t.month &amp;&amp; this.day &#x3D;&#x3D; t.day;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-3-finalize方法（了解即可）"><a href="#6-3-3-finalize方法（了解即可）" class="headerlink" title="6.3.3 finalize方法（了解即可）"></a>6.3.3 finalize方法（了解即可）</h3><p>这个方法在Object类中这个方法的源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void finalize() throws Throwable &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方法只protected修饰的，只有方法体。这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法。当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用finalize()方法。finalize()方法实际上是SUN公司为java程序员准备的一个时机，垃圾销毁时机。如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法当中。</p><p>提示：<br>            java中的垃圾回收器不是轻易启动的，<br>            垃圾太少，或者时间没到，种种条件下，<br>            有可能启动，也有可能不启动。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test06&#123;public static void main(String[] args)&#123;for(int i &#x3D; 0; i &lt; 1000; i++)&#123;Person p &#x3D; new Person();p &#x3D; null;&#x2F;&#x2F; 这个代码可以建议垃圾回收器启动。System.gc(); &#x2F;&#x2F; 建议启动垃圾回收器。（只是建议，可能不启动，也可能启动。启动的概率高了一些。）&#125;&#125;&#125;&#x2F;&#x2F; 项目开发中有这样的业务需求：所有对象在JVM中被释放的时候，请记录一下释放时间！！！&#x2F;&#x2F; 记录对象被释放的时间点，这个负责记录的代码写到哪里？&#x2F;&#x2F; 写到finalize()方法中。class Person&#123;&#x2F;&#x2F; 重写finalize()方法&#x2F;&#x2F; Person类型的对象被垃圾回收器回收的时候，垃圾回收器负责调用：p.finalize();protected void finalize() throws Throwable &#123;        System.out.println(this + &quot;即将被销毁！&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-4-hashCode方法"><a href="#6-3-4-hashCode方法" class="headerlink" title="6.3.4 hashCode方法"></a>6.3.4 hashCode方法</h3><p>在Object中的hashCode的源代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public native int hashCode();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方法不是抽象方法，带有native关键字，底层调用C++程序。</p><p>hashCode()方法返回的是哈希码，实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test07&#123;public static void main(String[] args)&#123;Object o &#x3D; new Object();int hashCodeValue &#x3D; o.hashCode();&#x2F;&#x2F; 对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址。System.out.println(hashCodeValue); &#x2F;&#x2F;输出结果：798154996MyClass mc &#x3D; new MyClass();int hashCodeValue2 &#x3D; mc.hashCode();System.out.println(hashCodeValue2); &#x2F;&#x2F;输出结果：1392838282&#125;&#125;class MyClass&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-成员内部类"><a href="#6-4-成员内部类" class="headerlink" title="6.4 成员内部类"></a>6.4 成员内部类</h2><p>内部类分为成员内部类与局部内部类。<br>定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。<br>成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问<br>定义格</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class 外部类 &#123;    修饰符 class 内部类 &#123;    &#x2F;&#x2F;其他代码    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问方式： <code>外部类名.内部类名 变量名 = new 外部类名().new 内部类名();</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Body &#123;&#x2F;&#x2F;外部类，身体    private boolean life &#x3D; true; &#x2F;&#x2F;生命状态    public class Heart &#123; &#x2F;&#x2F;内部类，心脏        public void jump() &#123;            System.out.println(&quot;生命状态&quot; + life); &#x2F;&#x2F;访问外部类成员变量        &#125;    &#125;&#125;class Test&#123;   &#x2F;&#x2F;访问内部类    public static void main(String[] args) &#123;&#x2F;&#x2F;创建内部类对象        Body.Heart bh &#x3D; new Body().new Heart();&#x2F;&#x2F;调用内部类中的方法        bh.jump();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-局部内部类"><a href="#6-5-局部内部类" class="headerlink" title="6.5 局部内部类"></a>6.5 局部内部类</h2><p>局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class 外部类 &#123;    修饰符 返回值类型 方法名(参数) &#123;        class 内部类 &#123;        &#x2F;&#x2F;其他代码        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>局部内部类代码演示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;定义类class Party &#123;&#x2F;&#x2F;外部类，聚会    public void puffBall() &#123;&#x2F;&#x2F; 吹气球方法        class Ball &#123;&#x2F;&#x2F; 内部类，气球            public void puff() &#123;                System.out.println(&quot;气球膨胀了&quot;);            &#125;        &#125;    &#x2F;&#x2F;创建内部类对象，调用puff方法        new Ball().puff();    &#125;&#125;class &#123;    &#x2F;&#x2F;访问内部类    public static void main(String[] args) &#123;    &#x2F;&#x2F;创建外部类对象        Party p &#x3D; new Party();    &#x2F;&#x2F;调用外部类中的puffBall方法        p.puffBall();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-6-匿名内部类"><a href="#7-6-匿名内部类" class="headerlink" title="7.6 匿名内部类"></a>7.6 匿名内部类</h3><p>匿名内部类是局部内部类的一种，匿名内部类是创建某个类型子类对象的快捷方式。</p><p>格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">new 父类或接口()&#123;    &#x2F;&#x2F;进行方法重写&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>代码演示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;已经存在的父类：public abstract class Person&#123;    public abstract void eat();&#125;    &#x2F;&#x2F;定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量    Person p &#x3D; new Person()&#123;        public void eat() &#123;            System.out.println(&quot;我吃了&quot;);        &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li><p>匿名内部类没有访问修饰符。</p></li><li><p>匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。</p></li></ol><hr><h1 id="第7章-常用类"><a href="#第7章-常用类" class="headerlink" title="第7章 常用类"></a>第7章 常用类</h1><h2 id="7-1-String类"><a href="#7-1-String类" class="headerlink" title="7.1 String类"></a>7.1 String类</h2><p>String类是不可变类，也就是说String对象声明后，将不可修改</p><p>关于Java JDK中内置的一个类：java.lang.String<br>    1、String表示字符串类型，属于引用数据类型，不属于基本数据类型。<br>    2、在java中随便使用双引号括起来的都是String对象。例如：”abc”，”def”，”hello world!”，这是3个String对象。<br>    3、java中规定，双引号括起来的字符串，是不可变的，也就是说”abc”自出生到最终死亡，不可变，不能变成”abcd”，也不能变成”ab”<br>    4、在JDK当中双引号括起来的字符串，例如：”abc” “def”都是直接存储在“方法区”的“字符串常量池”当中的。<br>    为什么SUN公司把字符串存储在一个“字符串常量池”当中呢。因为字符串在实际的开发中使用太频繁。为了执行效率，<br>    所以把字符串放到了方法区的字符串常量池当中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StringTest01 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中。        String s1 &#x3D; &quot;abcdef&quot;;        String s2 &#x3D; &quot;abcdef&quot; + &quot;xy&quot;;        &#x2F;&#x2F; 分析：这是使用new的方式创建的字符串对象。这个代码中的&quot;xy&quot;是从哪里来的？        &#x2F;&#x2F; 凡是双引号括起来的都在字符串常量池中有一份。        &#x2F;&#x2F; new对象的时候一定在堆内存当中开辟空间。        String s3 &#x3D; new String(&quot;xy&quot;);        &#x2F;&#x2F; i变量中保存的是100这个值。        int i &#x3D; 100;        &#x2F;&#x2F; s变量中保存的是字符串对象的内存地址。        &#x2F;&#x2F; s引用中保存的不是&quot;abc&quot;，是0x1111        &#x2F;&#x2F; 而0x1111是&quot;abc&quot;字符串对象在“字符串常量池”当中的内存地址。        String s &#x3D; &quot;abc&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常量池</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str1 &#x3D; &quot;abc&quot;;String str2 &#x3D; new&#96;String(&#96;&#96;&quot;def&quot;&#96;&#96;);String str3 &#x3D; &quot;abc&quot;;String str4 &#x3D; str2.intern();String str5 &#x3D; &quot;def&quot;;System.out.println(str1 &#x3D;&#x3D; str3);&#x2F;&#x2F; trueSystem.out.println(str2 &#x3D;&#x3D; str4);&#x2F;&#x2F; falseSystem.out.println(str4 &#x3D;&#x3D; str5);&#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 通过这个案例的学习，我们知道了，字符串对象之间的比较不能使用“&#x3D;&#x3D;”</p><p> “ &#x3D;&#x3D;”不保险。应该调用String类的equals方法。 String类已经重写了equals方法，以下的equals方法调用的是String重写之后的equals方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String k &#x3D; new String(&quot;testString&quot;);System.out.println(&quot;testString&quot;.equals(k)); &#x2F;&#x2F; 建议使用这种方式，因为这个可以避免空指针异常。System.out.println(k.equals(&quot;testString&quot;)); &#x2F;&#x2F; 存在空指针异常的风险。不建议这样写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>关于String类中的构造方法</strong>&#x3D;&#x3D;</p><ul><li>第一个：String s &#x3D; new String(“”);</li></ul><ul><li>第二个：String s &#x3D; “”;     (最常用创建字符串对象最常用的一种方式)</li></ul><ul><li>第三个：String s &#x3D; new String(char数组);</li><li>第四个：String s &#x3D; new String(char数组,起始下标,长度);</li><li>第五个：String s &#x3D; new String(byte数组);</li><li>第六个：String s &#x3D; new String(byte数组,起始下标,长度)</li></ul><p>&#x3D;&#x3D;<strong>关于String类中的常用方法</strong>&#x3D;&#x3D;</p><ul><li><strong>public char charAt(int index)</strong> (返回<code>char</code>指定索引处的值。  指数范围为<code>0</code>至<code>length() - 1</code> 。  该序列的第一个<code>char</code>值在索引<code>0</code> ，下一个索引为<code>1</code>  ，依此类推，与数组索引一样)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">char c &#x3D; &quot;中国人&quot;.charAt(1); &#x2F;&#x2F; &quot;中国人&quot;是一个字符串String对象。只要是对象就能“点.”System.out.println(c); &#x2F;&#x2F; 国 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>public int compareTo(String anotherString)</strong>      (按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值。  由该<code>String</code>对象表示的字符序列按字典顺序与由参数字符串表示的字符序列进行比较。  如果<code>String</code>对象按字典顺序排列在参数字符串之前，结果为负整数。  结果是一个正整数，如果<code>String</code>对象按字典顺序跟随参数字符串。  如果字符串相等，结果为零; <code>compareTo</code>返回<code>0</code> ，当equals(Object)方法将返回<code>true</code>  。 )</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 拿着字符串第一个字母和后面字符串的第一个字母比较。能分胜负就不再比较了。System.out.println(&quot;xyz&quot;.compareTo(&quot;yxz&quot;)); &#x2F;&#x2F; -1(比较大于返回1，小于0返回-1，等于零返回0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**public boolean contains(CharSequence s)**（当且仅当此字符串包含指定的char值序列时才返回true。）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 判断前面的字符串中是否包含后面的子字符串 System.out.println(&quot;HelloWorld.java&quot;.contains(&quot;.java&quot;)); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**public boolean endsWith(String suffix)**（测试此字符串是否以指定的后缀结尾。）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;&#x2F; 判断当前字符串是否以某个子字符串结尾。System.out.println(&quot;test.txt&quot;.endsWith(&quot;.java&quot;)); &#x2F;&#x2F; falseSystem.out.println(&quot;test&quot;.endsWith(&quot;est&quot;)); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>equals(Object anObject)</strong> （将此字符串与指定对象进行比较。）</p></li><li><p>**public boolean equalsIgnoreCase(String anotherString)**（将此<code>String</code>与其他<code>String</code>比较，忽略案例注意事项。  如果两个字符串的长度相同，并且两个字符串中的相应字符等于忽略大小写，则两个字符串被认为是相等的。 ）</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 判断两个字符串是否相等，并且同时忽略大小写。System.out.println(&quot;ABc&quot;.equalsIgnoreCase(&quot;abC&quot;)); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>public byte[] getBytes()</strong> （使用平台的默认字符集将此<code>String</code>编码为字节序列，将结果存储到新的字节数组中）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">   &#x2F;&#x2F; 将字符串对象转换成字节数组byte[] bytes &#x3D; &quot;abcdef&quot;.getBytes();for(int i &#x3D; 0; i &lt; bytes.length; i++)&#123;    System.out.println(bytes[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**public int indexOf(int ch,int fromIndex)**（返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索。 ）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 判断某个子字符串在当前字符串中第一次出现处的索引（下标）。System.out.println(&quot;oraclejavac++.netc#phppythonjavaoraclec++&quot;.indexOf(&quot;java&quot;)); &#x2F;&#x2F; 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**public boolean isEmpty()**（判断某个字符串是否为空）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;&quot;.isEmpty());&#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public int length()**（判断数组长度）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;abcd&quot;.length()); &#x2F;&#x2F;4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public int lastIndexOf(String str)**（判断某个子字符串中最后一次出现的索引）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;oraclejavac++javac#phpjavapython&quot;.lastIndexOf(&quot;java&quot;)); &#x2F;&#x2F;22<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public String replace(CharSequence target,CharSequence replacement)**（将与字面目标序列匹配的字符串的每个子字符串替换为指定的字面替换序列。）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"> String newString &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;.replace(&quot;http:&#x2F;&#x2F;&quot;, &quot;https:&#x2F;&#x2F;&quot;);System.out.println(newString); &#x2F;&#x2F;https:&#x2F;&#x2F;www.baidu.com        &#x2F;&#x2F; 把以下字符串中的“&#x3D;”替换成“:”String newString2 &#x3D; &quot;name&#x3D;zhangsan&amp;password&#x3D;123&amp;age&#x3D;20&quot;.replace(&quot;&#x3D;&quot;, &quot;:&quot;);System.out.println(newString2); &#x2F;&#x2F;name:zhangsan&amp;password:123&amp;age:20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>public String[] split(String regex)</strong> （拆分字符串）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String[] ymd &#x3D; &quot;1980-10-11&quot;.split(&quot;-&quot;); &#x2F;&#x2F;&quot;1980-10-11&quot;以&quot;-&quot;分隔符进行拆分。for(int i &#x3D; 0; i &lt; ymd.length; i++)&#123;    System.out.println(ymd[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**public boolean startsWith(String prefix)**（测试此字符串是否以指定的前缀开始）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;.startsWith(&quot;http&quot;)); &#x2F;&#x2F; trueSystem.out.println(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;.startsWith(&quot;https&quot;)); &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**public String substring(int beginIndex)**（截取字符串）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;.substring(7)); &#x2F;&#x2F;www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public String substring(int beginIndex,int endIndex)**（也是截取字符串，不过可以截取范围，包括开始不包括结尾）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;.substring(7, 10)); &#x2F;&#x2F;www<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public char[] toCharArray()**（将字符串转换成char数组）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">char[] chars &#x3D; &quot;我是中国人&quot;.toCharArray();for(int i &#x3D; 0; i &lt; chars.length; i++)&#123;    System.out.println(chars[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**public String toLowerCase()**（将字符串转换成小写）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;ABCDefKXyz&quot;.toLowerCase());&#x2F;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public String toUpperCase(Locale locale)**（将字符串转换成大写）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;ABCDefKXyz&quot;.toUpperCase());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public String trim()**（去除字符串前后空白）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(&quot;           hello      world             &quot;.trim());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**public static String valueOf(boolean b)**（将”非字符串“转换成”字符串“）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String s1 &#x3D; String.valueOf(true);String s1 &#x3D; String.valueOf(100);String s1 &#x3D; String.valueOf(3.14);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>StringBuffer和StringBuilder</strong>&#x3D;&#x3D;</p><p>如果以后需要进行大量字符串的拼接操作，建议使用JDK中自带的：</p><ul><li><pre><code> java.lang.StringBuffer</code></pre></li><li><pre><code> java.lang.StringBuilder</code></pre></li></ul><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test&#123;  public static void main(String args[])&#123;    StringBuffer sBuffer &#x3D; new StringBuffer(&quot;g:&quot;);    sBuffer.append(&quot;www&quot;);    sBuffer.append(&quot;.DawnCoody&quot;);    sBuffer.append(&quot;.com&quot;);    System.out.println(sBuffer);  &#x2F;&#x2F; 输出结果：g:www.DawnCoody.com  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-2-基本类型对应的8个包装类"><a href="#7-2-基本类型对应的8个包装类" class="headerlink" title="7.2 基本类型对应的8个包装类"></a>7.2 基本类型对应的8个包装类</h2><p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：</p><table><thead><tr><th align="left">包装类</th><th align="left">基本数据类型</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">boolean</td></tr><tr><td align="left">Byte</td><td align="left">byte</td></tr><tr><td align="left">Short</td><td align="left">short</td></tr><tr><td align="left">Integer</td><td align="left">int</td></tr><tr><td align="left">Long</td><td align="left">long</td></tr><tr><td align="left">Character</td><td align="left">char</td></tr><tr><td align="left">Float</td><td align="left">float</td></tr><tr><td align="left">Double</td><td align="left">double</td></tr></tbody></table><p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/OOP_WrapperClass.png" alt="Java Number类"></p><p>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer i &#x3D; new Integer(100);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer i &#x3D; 100;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们就以Interger类为例，下面看一段代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args)&#123;    Integer i &#x3D; 10; &#x2F;&#x2F;装箱    int index &#x3D; i;  &#x2F;&#x2F;拆箱&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Interger类中常用方法：</p><ul><li><p>**static int parseInt(String s)**（将字符串转换为数值）</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">int retValue &#x3D; Integer.parseInt(&quot;123&quot;); &#x2F;&#x2F; String -转换-&gt; int&#x2F;&#x2F;int retValue &#x3D; Integer.parseInt(&quot;中文&quot;); &#x2F;&#x2F; NumberFormatExceptionSystem.out.println(retValue + 100);&#x2F;&#x2F; 输出结果为223<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>**static String toBinaryString(int i)**（将十进制转换成二进制字符串。）</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String binaryString &#x3D; Integer.toBinaryString(3);System.out.println(binaryString); &#x2F;&#x2F;&quot;11&quot; 二进制字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**static String toHexString(int i)**（将十进制转换成十六进制字符串。）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String hexString &#x3D; Integer.toHexString(16);System.out.println(hexString); &#x2F;&#x2F; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**static String toOctalString(int i)**（将十进制转换成八进制字符串。）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String octalString &#x3D; Integer.toOctalString(8);System.out.println(octalString); &#x2F;&#x2F; &quot;10&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**static Integer valueOf(int i)**（将数值转换成Interger对象）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer i1 &#x3D; Integer.valueOf(100);System.out.println(i1);&#x2F;&#x2F; 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>**static Integer valueOf(String s)**（将字符串转换成Integer 对象）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer i2 &#x3D; Integer.valueOf(&quot;100&quot;);System.out.println(i2);&#x2F;&#x2F; 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>String int Integer之间互相转换总结:</strong></p></blockquote><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200728231425652-170440521.png" alt="image-20200722070748165"></p><p>实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IntegerTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; String --&gt; int        int i1 &#x3D; Integer.parseInt(&quot;100&quot;); &#x2F;&#x2F; i1是100数字        System.out.println(i1 + 1); &#x2F;&#x2F; 101        &#x2F;&#x2F; int --&gt; String        String s2 &#x3D; i1 + &quot;&quot;; &#x2F;&#x2F; &quot;100&quot;字符串        System.out.println(s2 + 1); &#x2F;&#x2F; &quot;1001&quot;        &#x2F;&#x2F; int --&gt; Integer        &#x2F;&#x2F; 自动装箱        Integer x &#x3D; 1000;        &#x2F;&#x2F; Integer --&gt; int        &#x2F;&#x2F; 自动拆箱        int y &#x3D; x;        &#x2F;&#x2F; String --&gt; Integer        Integer k &#x3D; Integer.valueOf(&quot;123&quot;);        &#x2F;&#x2F; Integer --&gt; String        String e &#x3D; String.valueOf(k);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-3-Date类"><a href="#7-3-Date类" class="headerlink" title="7.3 Date类"></a>7.3 Date类</h2><p>类 Date 表示特定的瞬间，精确到毫秒。</p><p>获取系统当前时间：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Date;public class DateTest&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F; 获取系统当前时间        &#x2F;&#x2F; 直接调用无参数构造方法。        Date nowTime &#x3D; new Date();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SimpleDateFormat类</strong>（日期格式化）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;创建日期格式化对象,在获取格式化对象时可以指定风格DateFormat df&#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);&#x2F;&#x2F;对日期进行格式化Date date &#x3D; new Date(1607616000000L);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>DateFormat类的作用：即可以将一个Date对象转换为一个符合指定格式的字符串，也可以将一个符合指定格式的字符串转为一个Date对象。</p><p>指定格式的具体规则我们可参照SimpleDateFormat类的说明，这里做简单介绍，规则是在一个字符串中，会将以下字母替换成对应时间组成部分，剩余内容原样输出：</p><ul><li>当出现y时，会将y替换成年</li><li>当出现M时，会将M替换成月</li><li>当出现d时，会将d替换成日</li><li>当出现H时，会将H替换成时</li><li>当出现m时，会将m替换成分</li><li>当出现s时，会将s替换成秒</li></ul><p><strong>DateFormat类常用方法</strong></p><p>format方法，用来将Date对象转换成String</p><p>parse方法，用来将String转换成Date（转换时，该String要符合指定格式，否则不能转换）。</p><p>代码演示：</p><p>练习一：把Date对象转换成String</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Date date &#x3D; new Date(1607616000000L);&#x2F;&#x2F;Fri Dec 11 00:00:00 CST 2020SimpleDateFormat df &#x3D; new SimpleDateFormat(“yyyy年MM月dd日”);String str &#x3D; df.format(date);&#x2F;&#x2F;str中的内容为2020年12月11日<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>练习二：把String转换成Date对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; ”2020年12月11日”;DateFormat df &#x3D; new SimpleDateFormat(“yyyy年MM月dd日”);Date date &#x3D; df.parse( str );&#x2F;&#x2F;Date对象中的内容为Fri Dec 11 00:00:00 CST 2020<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取自1970年1月1日 00:00:00 000到当前系统时间的终毫秒数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">long nowTimeMillis &#x3D; System.currentTimeMillis();System.out.println(nowTimeMillis);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>关于数据处理</strong></p><p><strong>DecimalFormat</strong>专门负责数字格式化的。</p><p>关于数字格式化：</p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>#</td><td>代表任意数字</td></tr><tr><td>,</td><td>代表千分位</td></tr><tr><td>.</td><td>代表小数点</td></tr><tr><td>0</td><td>代表不够时补0</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 表示：加入千分位，保留2个小数。DecimalFormat df &#x3D; new DecimalFormat(&quot;###,###.##&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>BigDecimal</strong></p><p>BigDecimal 属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F; 这个100不是普通的100，是精度极高的100        BigDecimal v1 &#x3D; new BigDecimal(100);        BigDecimal v2 &#x3D; new BigDecimal(200);        &#x2F;&#x2F;求和        BigDecimal v3 &#x3D; v1.add(v2);&#x2F;&#x2F; 调用方法求和        System.out.println(v3);                &#x2F;&#x2F; 相除        BigDecimal v4 &#x3D; v2.divide(v1);        System.out.println(v4);&#x2F;&#x2F; 2    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Random()类</strong>（生成随机数）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RandomTest&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F; 创建随机数对象        Random random &#x3D; new Random();                &#x2F;&#x2F; 随机产生一个int类型取值范围的数字        int num1 &#x3D; random.nextInt();                &#x2F;&#x2F; 产生【0 ~ 100】之间的随机数。不能产生101        random.nextInt(101);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="第8章-异常"><a href="#第8章-异常" class="headerlink" title="第8章 异常"></a>第8章 异常</h1><p>​对于异常情况，例如，可能造成程序崩溃的错误输入，java使用了一种称为异常处理的错误捕获机制。java中的异常处理与 C++ 或 Delphi 中的异常处理十分类似。</p><p>​在测试期间，需要运行大量的检查以确保程序操作的正确性。然而，这些检查可能非常耗时，在测试完成后也没必要保留。也可以简单地将这些检查删除，需要另做测试时再将它们粘贴回来，不过这样做会很繁琐。</p><blockquote><p>什么是异常</p></blockquote><p>1、什么是异常，java提供异常处理机制有什么用？<br>    以下程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常<br>    java语言是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常情况，<br>    java把该异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，可以对<br>    程序进行修改，让程序更加的健壮。</p><p>​什么是异常：程序执行过程中的不正常情况。<br>​异常的作用：增强程序的健壮性。</p><p>2、以下程序执行控制台出现了：</p><p>​    Exception in thread “main” java.lang.ArithmeticException: &#x2F; by zero<br>​    at com.bjpowernode.javase.exception.ExceptionTest01.main(ExceptionTest01.java:14)<br>​这个信息被我们称为：异常信息。这个信息是JVM打印的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExceptionTest01 &#123;    public static void main(String[] args) &#123;        int a &#x3D; 10;        int b &#x3D; 0;        int c &#x3D; a &#x2F; b;        System.out.println(a + &quot;&#x2F;&quot; + b + &quot;&#x3D;&quot; + c);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Object下有Throwable（可抛出的）</p><p>Throwabl下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）</p><p>​Exception下有两个分支：</p><p>​Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须先对这些异常进行处理，如果不处理编译报错。）</p><p>​RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理也可以不管）</p><p><img src="https://images2017.cnblogs.com/blog/858860/201709/858860-20170911125844719-1230755033.png" alt="img"></p><p>所有异常都是运行阶段发生的。因为只有程序运行阶段才可以new对象。编译时异常必须在编译阶段预先处理，如果不处理编译报错。</p><blockquote><p>编译时异常和运行时异常的区别</p></blockquote><p>编译时异常一般发生的概率比较高。</p><p>运行时异常一般发生的概率比较低。</p><blockquote><p>Java语言中对异常的处理包括两种方式：</p></blockquote><p>第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。</p><p>第二种方式：使用try…catch语句进行异常的捕捉。</p><h2 id="8-1-try-…-catch"><a href="#8-1-try-…-catch" class="headerlink" title="8.1 try … catch"></a>8.1 try … catch</h2><p>  捕获异常是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可有多条;finally语句最多只能有一条，根据自己的需要可有可无)。如图所示:</p><p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170520/1495273755315926.png" alt="图6-10 异常处理.png"></p><p><strong>上面过程详细解析：</strong></p><p><strong>1. try：</strong></p><p>   try语句指定了一段代码，该段代码就是异常捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该条语句中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。</p><p>   一个try语句必须带有至少一个catch语句块或一个finally语句块 。</p><p><strong>注意事项</strong></p><p>   当异常处理的代码执行结束以后，不会回到try语句去执行尚未执行的代码。</p><p><strong>2. catch：</strong></p><p>   n-每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p><p>   n-常用方法，这些方法均继承自Throwable类 。</p><p>​     u-toString ()方法，显示异常的类名和产生异常的原因</p><p>​     u-getMessage()方法，只显示产生异常的原因，但不显示类名。</p><p>​     u-printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。</p><p>   n-catch捕获异常时的捕获顺序：</p><p>​     u-如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是先捕获子类异常再捕获父类异常。</p><p><strong>3. finally：</strong></p><p>   n-有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。</p><p>   n-通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。</p><p><strong>try-catch-finally语句块的执行过程：</strong></p><p>   try-catch-finally程序块的执行流程以及执行结果比较复杂。</p><p>   基本执行过程如下：</p><p>   程序首先执行可能发生异常的try语句块。如果try语句没有出现异常则执行完后跳至finally语句块执行;如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。catch语句块可以有多个，分别捕获不同类型的异常。catch语句块执行完后程序会继续执行finally语句块。finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。</p><p><strong>注意事项</strong></p><ol><li><p><strong>即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。</strong></p></li><li><p><strong>finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。</strong></p></li><li><p><strong>catch写多个的时候，从上到下，必须遵守从小到大</strong>。</p></li></ol><h2 id="8-2-throws"><a href="#8-2-throws" class="headerlink" title="8.2 throws"></a>8.2 throws</h2><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p><p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p><p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN&#123;      &#x2F;&#x2F;foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-3-final-finally-finalize的区别"><a href="#8-3-final-finally-finalize的区别" class="headerlink" title="8.3 final finally finalize的区别"></a>8.3 final finally finalize的区别</h2><blockquote><p>final 关键字</p></blockquote><p>final修饰的类无法继承<br>    final修饰的方法无法覆盖<br>    final修饰的变量不能重新赋值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; final修饰的类无法继承final class A &#123;    &#x2F;&#x2F; 常量。    public static final double MATH_PI &#x3D; 3.1415926;&#125;class B &#123;    &#x2F;&#x2F; final修饰的方法无法覆盖    public final void doSome()&#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>finally 关键字</p></blockquote><p>和try一起联合使用。<br>    finally语句块中的代码是必须执行的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; finally也是一个关键字，和try联合使用，使用在异常处理机制中&#x2F;&#x2F; 在fianlly语句块中的代码是一定会执行的。try &#123;&#125; finally &#123;    System.out.println(&quot;finally....&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>finalize 标识符</p></blockquote><p>是一个Object类中的方法名。<br>    这个方法是由垃圾回收器GC负责调用的。</p><h2 id="8-4-异常的方法"><a href="#8-4-异常的方法" class="headerlink" title="8.4 异常的方法"></a>8.4 异常的方法</h2><p>异常对象有两个非常重要的方法：</p><p>获取异常简单的描述信息：<br>    String msg &#x3D; exception.getMessage();</p><p>打印异常追踪的堆栈信息：<br>    exception.printStackTrace();</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExceptionTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 这里只是为了测试getMessage()方法和printStackTrace()方法。        &#x2F;&#x2F; 这里只是new了异常对象，但是没有将异常对象抛出。JVM会认为这是一个普通的java对象。        NullPointerException e &#x3D; new NullPointerException(&quot;空指针异常fdsafdsafdsafds&quot;);        &#x2F;&#x2F; 获取异常简单描述信息：这个信息实际上就是构造方法上面String参数。        String msg &#x3D; e.getMessage();        System.out.println(msg); &#x2F;&#x2F;空指针异常fdsafdsafdsafds        &#x2F;&#x2F; 打印异常堆栈信息        &#x2F;&#x2F; java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印的。        e.printStackTrace();        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-5-自定义异常"><a href="#8-5-自定义异常" class="headerlink" title="8.5 自定义异常"></a>8.5 自定义异常</h2><p>  1.在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。</p><p>   2.自定义异常类只需从Exception类或者它的子类派生一个子类即可。</p><p>   3.自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。</p><p>   4.习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。</p><p>现在，我们来定义个自己的异常，即自定义异常。</p><p>格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class 异常名 extends Exception&#123; &#x2F;&#x2F;或继承RuntimeException    public 异常名()&#123;    &#125;    public 异常名(String s)&#123;   　　 super(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义异常继承Exception演示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyException extends Exception&#123;&#x2F;*为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。*&#x2F;public MyException()&#123;    super();&#125;public MyException(String message) &#123;    super(message);&#x2F;&#x2F; 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义异常继承RuntimeException演示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyException extends RuntimeException&#123;&#x2F;*为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。*&#x2F;    MyException()&#123;        super();    &#125;    MyException(String message) &#123;        super(message);&#x2F;&#x2F; 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下实例演示了通过继承 Exception 来实现自定义异常：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class WrongInputException extends Exception &#123;  &#x2F;&#x2F; 自定义的类    WrongInputException(String s) &#123;        super(s);    &#125;&#125;class Input &#123;    void method() throws WrongInputException &#123;        throw new WrongInputException(&quot;Wrong input&quot;); &#x2F;&#x2F; 抛出自定义的类    &#125;&#125;class TestInput &#123;    public static void main(String[] args)&#123;        try &#123;            new Input().method();        &#125;        catch(WrongInputException wie) &#123;            System.out.println(wie.getMessage());        &#125;    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="第9章-集合"><a href="#第9章-集合" class="headerlink" title="第9章 集合"></a>第9章 集合</h1><p>有一门课程叫数据结构，在Java中已经将数据结构实现了，不用自己去实现这些代码了。</p><h2 id="9-1集合的概述"><a href="#9-1集合的概述" class="headerlink" title="9.1集合的概述"></a>9.1集合的概述</h2><p>什么是集合？有什么用？</p><ol><li><p>数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其他数据类型。集合是一个容器，是一个载体，可以异常容纳多个对象，在实际开发中，假设连接数据库，数据库当中有10个记录，那么假设把这10条记录查询出来，在java程序对象中会将10条数据封装成10个对象，然后将10个java对象放到某个集合中，将集合传到前端，然后遍历集合，将一个个数据展现出来。</p></li><li><p>集合不能直接存储基本数据类型，另外集合也不能直接存储Java对象，集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）</p></li><li><p>在Java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。</p></li><li><p>所有的集合类和接口都在java.util包下。</p></li><li><p>在java中集合分为两大类：</p><p>  一类是单个方式存储元素：</p><p> ​单个方式存储元素，这一类集合中超级父接口：java.util.Collection</p><p> 该继承结构图如下（这继承图要背会）：</p><p> <img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200728231424851-2042256498.png" alt="image-20200724184017735"></p><p> 另一个是一键值对的方式存储元素，</p><p> ​以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;</p><p> 该继承结构图如下（记会）：</p><p> <img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200728231423354-1409054416.png" alt="image-20200724183937247"></p></li></ol><h2 id="9-2-Collection"><a href="#9-2-Collection" class="headerlink" title="9.2 Collection"></a>9.2 Collection</h2><blockquote><p> 关于java.util.Collection接口中常用的方法</p></blockquote><ul><li>boolean add(Object e) 向集合中添加元素</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 因为Collection是接口所以无法实例化，这里就利用了多态Collection c &#x3D; new ArrayList();&#x2F;&#x2F;测试Collection接口中的常用方法c.add(1200);&#x2F;&#x2F;自动装箱，实际上是放进去了一个对象的内存地址。Integer x &#x3D; new Integer(1200);c.add(3.14);&#x2F;&#x2F;自动装箱c.add(new Object());c.add(true);&#x2F;&#x2F;自动装箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>int size()  获取集合中元素的个数</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection c &#x3D; new ArrayList();&#x2F;&#x2F;获取集合中元素的个数System.out.println(&quot;集合中元素的个数是：&quot; + c.size());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>void clear() 清空集合</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection c &#x3D; new ArrayList();&#x2F;&#x2F;清空集合c.clear();System.out.println(&quot;集合中元素个数是&quot; + c.size());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>boolean contains(Object o) 判断当前集合中是否包含元素o,包含返回true,不包含返回false。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection c &#x3D; new ArrayList();c.add(1);&#x2F;&#x2F; 判断集合中是否包含1System.out.println(c.contains(1));&#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：&#x3D;&#x3D;contains方法底层调用的是equals方法&#x3D;&#x3D; 以下为例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CollectionTest04 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建集合对象        Collection c &#x3D; new ArrayList();        &#x2F;&#x2F;向集合中存储元素        String s1 &#x3D; new String(&quot;abc&quot;);        c.add(s1);        String s2 &#x3D; new String(&quot;def&quot;);        c.add(s2);                &#x2F;&#x2F;新建的对象String        String x &#x3D; new String(&quot;abc&quot;);        &#x2F;&#x2F;c集合中是否包含x？        System.out.println(c.contains(x));&#x2F;&#x2F;contains 底层调用的equals，所有判断的是内容&quot;abc&quot;,true    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为String的equals是重写了的所以返回true，如果不重写equals方法会返回false：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.collection;import java.util.ArrayList;import java.util.Collection;public class CollectionTest &#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F;创建集合对象        Collection c &#x3D; new ArrayList();        &#x2F;&#x2F;创建用户对象        User u1 &#x3D; new User(&quot;jack&quot;);        User u2 &#x3D; new User(&quot;jack&quot;);        &#x2F;&#x2F;加入集合        c.add(u1);        &#x2F;&#x2F;判断集合中是否包含u2        User u2 &#x3D; new User(&quot;jack&quot;);        &#x2F;&#x2F;没有重写equals之前:这个结果是false        System.out.println(c.contains(u2)); &#x2F;&#x2F;false    &#125;&#125;class User&#123;    private String name;    public User()&#123;            &#125;    public User(String name)&#123;        this.name &#x3D; name;    &#125;    &#x2F;&#x2F; 这里没有重写equals方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>boolean remove(Object o) 删除集合中的某个元素。同样remove的底层也是调用的equals方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection c &#x3D; new ArrayList();&#x2F;&#x2F; 添加元素c.add(&quot;我是中国人我骄傲&quot;)c.add(1);&#x2F;&#x2F;删除集合中某个元素c.remove(1);System.out.println(&quot;集合中元素个数是:&quot; + c.size());  &#x2F;&#x2F;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>boolean isEmpty()  判断该集合中元素的个数是否为零，为零返回true，不为零返回false</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection c &#x3D; new LinkedList();&#x2F;&#x2F;判断集合是否为为空（集合中是否存在元素）System.out.println(c.isEmpty());&#x2F;&#x2F;ture<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Object[] toArray() 调用这方法可以把集合转换成数组【作为了解，使用不多。】</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection c &#x3D; new LinkedList();c.add(&quot;abc&quot;);c.add(&quot;def&quot;);c.add(100);c.add(&quot;HelloWorld&quot;);c.add(new Student());&#x2F;&#x2F;转换为数组Object[] objs &#x3D; c.toArray();for (int i &#x3D; 0; i &lt; objs.length; i++) &#123;    &#x2F;&#x2F;遍历数组    Object o &#x3D; objs[i];    System.out.println(o.toString());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于集合的遍历：</p></blockquote><p><strong>注意</strong>:&#x3D;&#x3D;以下的遍历方式，是所有Collection通用的一种方式。&#x3D;&#x3D;<br>&#x3D;&#x3D;在Map集合中不能使用。在所有的Collection以及子类中使用。&#x3D;&#x3D;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CollectionTest02 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建集合对象        Collection c &#x3D; new ArrayList();&#x2F;&#x2F; 后面的集合无所谓，主要看前面的Collection接口，怎么遍历&#x2F;迭代。        &#x2F;&#x2F;添加元素        c.add(&quot;abc&quot;);        c.add(&quot;def&quot;);        c.add(100);        c.add(new Object());        &#x2F;&#x2F; 对集合Collection进行遍历&#x2F;迭代        &#x2F;&#x2F; 第一步:获取集合对象的迭代器对象Iteration        Iterator it &#x3D; c.iterator();        &#x2F;&#x2F;第二步:通过以上获取的迭代器对象开始迭代&#x2F;遍历集合。        &#x2F;*            以下两个方法是迭代器对象Iterator中的方法:        boolean hasNext()如果仍有元素可以迭代，则返回true。        Object next() 返回迭代的下一个元素。         *&#x2F;        while (it.hasNext())&#123;            &#x2F;&#x2F;不管你当初存进去什么，取出来统一都是Object。            Object obj &#x3D; it.next();            System.out.println(obj);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于集合元素的remove，使用Collection的remove删除元素之后，集合的结构发生了变化，应该重新去获取迭代器，但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：java.util.ConcurrentModificationException。 使用迭代器来删除,迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素），举个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CollectionTest06 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 注意：此时获取的迭代器，指向的是那是集合中没有元素状态下的迭代器。        &#x2F;&#x2F; 一定要注意：集合结构只要发生改变，迭代器必须重新获取。        &#x2F;&#x2F; 当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：java.util.ConcurrentModificationException        Collection c2 &#x3D; new ArrayList();        c2.add(&quot;abc&quot;);        c2.add(&quot;def&quot;);        c2.add(&quot;xyz&quot;);        Iterator it2 &#x3D; c2.iterator();        while(it2.hasNext())&#123;            Object o &#x3D; it2.next();            &#x2F;&#x2F; 删除元素            &#x2F;&#x2F; 删除元素之后，集合的结构发生了变化，应该重新去获取迭代器            &#x2F;&#x2F; 但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：java.util.ConcurrentModificationException            &#x2F;&#x2F;c2.remove(o); &#x2F;&#x2F; 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同。）            &#x2F;&#x2F; 使用迭代器来删除,迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）。            it2.remove(); &#x2F;&#x2F; 删除的一定是迭代器指向的当前元素。            System.out.println(o);        &#125;        System.out.println(c2.size()); &#x2F;&#x2F;0    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-3-List"><a href="#9-3-List" class="headerlink" title="9.3 List"></a>9.3 List</h2><p> List是有序、可重复的容器。</p><p>   <strong>有序：</strong>List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。</p><p>   <strong>可重复：</strong>List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。</p><p>  除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法，参见下表：</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">void add(int index, Object element)</td><td align="left">在指定位置插入元素，以前元素全部后移</td></tr><tr><td align="left">Object set(int index, Object element)</td><td align="left">修改指定位置的元素</td></tr><tr><td align="left">Object get(int index)</td><td align="left">返回指定位置的元素</td></tr><tr><td align="left">int indexOf(Object o)</td><td align="left">返回第一个匹配元素的索引，如果没有该元素，返回-1</td></tr><tr><td align="left">int lastIndexOf(Object o)</td><td align="left">返回最后一个匹配元素的索引，如果没有该元素，返回-1</td></tr><tr><td align="left">Object remove(int index)</td><td align="left">删除指定位置的元素，后面元素全部前移一位</td></tr></tbody></table><p>实现以上方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ListTest01 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建List类型的集合。        List myList &#x3D; new ArrayList();        &#x2F;&#x2F; 添加元素        myList.add(&quot;A&quot;); &#x2F;&#x2F; 默认都是向集合末尾添加元素。        myList.add(&quot;B&quot;);        myList.add(&quot;C&quot;);        myList.add(&quot;C&quot;);        myList.add(&quot;D&quot;);        &#x2F;&#x2F;在列表的指定位置插入指定元素（第一个参数是下标）        &#x2F;&#x2F; 这个方法使用不多，因为对于ArrayList集合来说效率比较低。        myList.add(1, &quot;KING&quot;);        &#x2F;&#x2F; 根据下标获取元素        Object firstObj &#x3D; myList.get(0);        System.out.println(firstObj);        &#x2F;&#x2F; 获取指定对象第一次出现处的索引。        System.out.println(myList.indexOf(&quot;C&quot;)); &#x2F;&#x2F; 3        &#x2F;&#x2F; 获取指定对象最后一次出现处的索引。        System.out.println(myList.lastIndexOf(&quot;C&quot;)); &#x2F;&#x2F; 4        &#x2F;&#x2F; 删除指定下标位置的元素        &#x2F;&#x2F; 删除下标为0的元素        myList.remove(0);        System.out.println(myList.size()); &#x2F;&#x2F; 5        &#x2F;&#x2F; 修改指定位置的元素        myList.set(2, &quot;Soft&quot;);    &#125;&#125;&#x2F;*计算机英语：    增删改查这几个单词要知道：        增：add、save、new        删：delete、drop、remove        改：update、set、modify        查：find、get、query、select *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为有下标，所以List集合有自己比较特殊的遍历方式，通过下标遍历。【List集合特有的方式，Set没有。】</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建List类型的集合。List myList &#x3D; new ArrayList();myList.add(&quot;A&quot;);myList.add(&quot;B&quot;);myList.add(&quot;C&quot;);myList.add(&quot;C&quot;);myList.add(&quot;D&quot;);for(int i &#x3D; 0; i &lt; myList.size(); i++)&#123;    Object obj &#x3D; myList.get(i);    System.out.println(obj);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-4-ArrayList特点-数组"><a href="#9-4-ArrayList特点-数组" class="headerlink" title="9.4 ArrayList特点(数组)"></a>9.4 ArrayList特点(数组)</h2><p> ArrayList底层是用数组实现的存储。 特点：查询效率高，增删效率低，线程不安全。我们一般使用它。</p><p>ArrayList集合：<br>    1。默认初始化容量10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10。）<br>    2、集合底层是一个Object[]数组。<br>    3、构造方法：<br>        new ArrayList();</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 默认初始化容量是10&#x2F;&#x2F; 数组的长度是10List list1 &#x3D; new ArrayList();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​new ArrayList(20);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 指定初始化长度，数组长度为30List list2 &#x3D; new ArrayList(30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​new ArrayList(Collection&lt;? extends E&gt; c);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayListTest02 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 默认初始化容量10        List myList1 &#x3D; new ArrayList();        &#x2F;&#x2F; 创建一个HashSet集合        Collection c &#x3D; new HashSet();        &#x2F;&#x2F; 添加元素到Set集合        c.add(100);        c.add(200);        c.add(400);        c.add(20);        &#x2F;&#x2F; 通过这个构造方法就可以将HashSet集合转换成List集合。        List myList3 &#x3D; new ArrayList(c);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    4、ArrayList集合的扩容：<br>​        增长到原容量的1.5倍。<br>​        ArrayList集合底层是数组，怎么优化？<br>​            尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合<br>​            的时候预估计元素的个数，给定一个初始化容量。<br>​    5、数组优点：<br>​        检索效率比较高。（每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，<br>​        然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。）<br>​    6、数组缺点：<br>​        随机增删元素效率比较低。<br>​        另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间。）<br>​    7、向数组末尾添加元素，效率很高，不受影响。</p><h2 id="9-5-LinkedList-链表"><a href="#9-5-LinkedList-链表" class="headerlink" title="9.5 LinkedList(链表)"></a>9.5 LinkedList(链表)</h2><p><strong>链表的优点：</strong><br>    由于链表上的元素在空间存储上内存地址不连续。<br>    所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。<br>    在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议<br>    使用LinkedList。</p><p><strong>链表的缺点：</strong><br>    不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索&#x2F;查找的效率较低。</p><p>​ArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）<br>​LinkedList：把随机增删发挥到极致。<br>​加元素都是往末尾添加，所以ArrayList用的比LinkedList多。</p><p><strong>LinkedList集合底层也是有下标的。</strong><br>         注意：ArrayList之所以检索效率比较高，不是单纯因为下标的原因。是因为底层数组发挥的作用。<br>         LinkedList集合照样有下标，但是检索&#x2F;查找某个元素的时候效率比较低，因为只能从头节点开始一个一个遍历。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkedListTest01 &#123;    public static void main(String[] args) &#123;             &#x2F;&#x2F; LinkedList集合没有初始化容量        &#x2F;&#x2F; 不管是LinkedList还是ArrayList，以后写代码时不需要关心具体是哪个集合。        &#x2F;&#x2F; 因为我们要面向接口编程，调用的方法都是接口中的方法。        &#x2F;&#x2F;List list1 &#x3D; new ArrayList(); &#x2F;&#x2F; 这样写表示底层你用了数组。        List list1 &#x3D; new LinkedList(); &#x2F;&#x2F; 这样写表示底层你用了双向链表。        &#x2F;&#x2F; 以下这些方法你面向的都是接口编程。        list1.add(&quot;123&quot;);        list1.add(&quot;456&quot;);        list1.add(&quot;789&quot;);        &#x2F;&#x2F; 遍历集合        for(int i &#x3D; 0; i &lt; list2.size(); i++)&#123;            System.out.println(list2.get(i));        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-6-Vector-底层也是数组"><a href="#9-6-Vector-底层也是数组" class="headerlink" title="9.6 Vector(底层也是数组)"></a>9.6 Vector(底层也是数组)</h2><p>Vector：</p><ol><li><p>底层也是一个数组。</p></li><li><p>初始化容量：10</p></li><li><p>Vector扩容<br> 扩容之后是原容量的2倍。<br> 10–&gt; 20 –&gt; 40 –&gt; 80</p></li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建一个Vector集合List vector &#x3D; new Vector();&#x2F;&#x2F; 添加元素&#x2F;&#x2F; 默认容量10个。vector.add(1);vector.add(2);vector.add(3);vector.add(4);vector.add(5);vector.add(6);vector.add(7);vector.add(8);vector.add(9);vector.add(10);&#x2F;&#x2F; 满了之后扩容（扩容之后的容量是20.）vector.add(11);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p>Vector中所有的方法都是线程同步的，都带有synchronized关键字，<br> 是线程安全的。效率比较低，使用较少了。</p></li><li><p>怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？<br> 使用集合工具类：<br>        java.util.Collections;<br>        java.util.Collection 是集合接口。<br>        java.util.Collections 是集合工具类。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class VectorTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建集合        List vector &#x3D; new Vector();        &#x2F;&#x2F; 变成线程安全的        Collections.synchronizedList(myList);        &#x2F;&#x2F; myList集合就是线程安全的了。    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-7-泛型Generics"><a href="#9-7-泛型Generics" class="headerlink" title="9.7 泛型Generics"></a>9.7 泛型Generics</h2><p>  为了能够更好的学习集合，我们首先要先来学习一个概念：泛型。</p><p>​泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。</p><blockquote><p>泛型的好处</p></blockquote><p>第一:集合存储的元素类型统一了。<br>第二:从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”！</p><p>在不使用泛型之前：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GenericTest01 &#123;    public static void main(String[] args) &#123;        List myList &#x3D; new ArrayList();        &#x2F;&#x2F;准备对象        Cat c &#x3D; new Cat();        Bird b &#x3D; new Bird();        &#x2F;&#x2F;将对象添加到集合当中        myList.add(c);        myList.add(b);                Iterator it &#x3D; myList.iterator();        while (it.hasNext())&#123;            Object obj &#x3D; it.next();            &#x2F;&#x2F;obj中没有move方法，无法调用，需要向下转型！            if(obj instanceof Animal)&#123;                Animal a &#x3D; (Animal)obj;                a.move();            &#125;        &#125;    &#125;&#125;class Animal&#123;    &#x2F;&#x2F;父类自带方法    public void move()&#123;    &#125;&#125;class  Cat extends Animal&#123;    &#x2F;&#x2F;特有方法    public void catchMouse()&#123;    &#125;&#125;class Bird extends Animal&#123;    &#x2F;&#x2F;特有方法    public void fly()&#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用泛型之后：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GenericTest02 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;使用泛型List&lt;Animal&gt;之后，表示List集合中只允许存储Animal类型的数据。        &#x2F;&#x2F;用泛型来指定集合中存储的数据类型。        List&lt;Animal&gt; myList &#x3D; new ArrayList&lt;Animal&gt;();        &#x2F;&#x2F;指定List集合中只能存储Animal，那么存储String就编译报错。        &#x2F;&#x2F;这样用了泛型之后，集合中元素的数据类型更加同一了。        &#x2F;&#x2F;myList.add(&quot;abc&quot;)        Cat c &#x3D; new Cat();        Bird b &#x3D; new Bird();        myList.add(c);        myList.add(b);        &#x2F;&#x2F;获取迭代器        &#x2F;&#x2F;这个表示迭代器迭代的是Animal类型。        Iterator&lt;Animal&gt; it &#x3D; myList.iterator();        while (it.hasNext())&#123;            &#x2F;&#x2F;使用泛型之后，每一次迭代返回的数据都是Animal类型。            Animal a &#x3D; it.next();            &#x2F;&#x2F;调用之类特有的方法还是需要向下转换的！            if (a instanceof Cat)&#123;                Cat x &#x3D; (Cat)a;                x.catchMouse();            &#125;            if (a instanceof Bird)&#123;                Bird y &#x3D; (Bird)a;                y.fly();            &#125;        &#125;    &#125;&#125;class Animal&#123;    &#x2F;&#x2F;父类自带方法    public void move()&#123;        System.out.println(&quot;动物在移动！&quot;);    &#125;&#125;class  Cat extends Animal&#123;    &#x2F;&#x2F;特有方法    public void catchMouse()&#123;        System.out.println(&quot;猫抓老鼠 !&quot;);    &#125;&#125;class Bird extends Animal&#123;    &#x2F;&#x2F;特有方法    public void fly()&#123;        System.out.println(&quot;鸟儿在飞翔! &quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JDK8之后引入了:自动类型判断机制。(又称为钻石表达式)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GenericTest03 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;ArrayList&lt;这里的类型非自动推断&gt;(),前提是JDK8之后才允许。自动类型推断，钻石表达式        List&lt;String&gt; strList &#x3D; new ArrayList&lt;&gt;();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>自定义泛型</strong></p></blockquote><p><em>泛型类的声明</em></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyCollection&lt;E&gt; &#123;&#x2F;&#x2F; E:表示泛型,这里可以随便写;    Object[] objs &#x3D; new Object[5];     public E get(int index) &#123;&#x2F;&#x2F; E:表示泛型;        return (E) objs[index];    &#125;    public void set(E e, int index) &#123;&#x2F;&#x2F; E:表示泛型;        objs[index] &#x3D; e;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型E像一个占位符一样表示“未知的某个数据类型”，我们在真正调用的时候传入这个“数据类型”。</p><p><em>泛型类的应用</em></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestGenerics &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 这里的”String”就是实际传入的数据类型；        MyCollection&lt;String&gt; mc &#x3D; new MyCollection&lt;String&gt;();        mc.set(&quot;aaa&quot;, 0);        mc.set(&quot;bbb&quot;, 1);        String str &#x3D; mc.get(1); &#x2F;&#x2F;加了泛型，直接返回String类型，不用强制转换;        System.out.println(str);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-8-Map接口"><a href="#9-8-Map接口" class="headerlink" title="9.8 Map接口"></a>9.8 Map接口</h2><p>Map就是用来存储“键(key)-值(value) 对”的。 Map类中存储的“键值对”通过键来标识，所以“键对象”不能重复。<br>Map 接口的实现类有HashMap、TreeMap、HashTable、Properties等。</p><blockquote><p><strong>Map接口中常用的方法：</strong></p></blockquote><table><thead><tr><th>V put(K key, V value)</th><th>向Map集合中添加键值对</th></tr></thead><tbody><tr><td>V get(Object key)</td><td>通过key获取value</td></tr><tr><td>void clear()</td><td>清空Map集合</td></tr><tr><td>boolean containsKey (Object key)</td><td>判断Map中是否包含某个key</td></tr><tr><td>boolean containsValue (Object value)</td><td>判断Map中是否包含某个value</td></tr><tr><td>boolean isEmpty ()</td><td>判断Map集合中元素个数是否为0</td></tr><tr><td>V remove(Object key)</td><td>通过key删除键值对</td></tr><tr><td>int size()</td><td>获取Map集合中键值对的个数</td></tr><tr><td>Collection<V> values()</td><td>获取Map集合中所有的value，返回一个Collection</td></tr><tr><td>Set<K> keySet()</td><td>获取Map集合所有的key（所有的键是一个set集合）</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td>将Map集合转换成Set集合</td></tr></tbody></table><p>运用以上方法：</p><ul><li><p>V put(K key, V value)方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建Map集合Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 向Map集合中添加键值对map.put(1, &quot;zhangsan&quot;); &#x2F;&#x2F; 1在这里进行了自动装箱。map.put(2, &quot;lisi&quot;);map.put(3, &quot;wangwu&quot;);map.put(4, &quot;zhaoliu&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>V get(Object key)方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(2, &quot;lisi&quot;);&#x2F;&#x2F; 通过key获取valueString value &#x3D; map.get(2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>void clear()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(2, &quot;lisi&quot;);&#x2F;&#x2F; 清空Map集合map.clear();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>boolean containsKey (Object key) 方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(4, &quot;lisi&quot;);&#x2F;&#x2F; contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法。System.out.println(map.containsKey(new Integer(4))); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>boolean containsValue (Object value) 方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(4, &quot;lisi&quot;);&#x2F;&#x2F; contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法。System.out.println(map.containsValue(new String(&quot;lisi&quot;))); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>boolean isEmpty () 方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();System.out.println(map.isEmpty()); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>V remove(Object key) 方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(2,&quot;wuhan&quot;);&#x2F;&#x2F; 通过key删除key-valuemap.remove(2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>int size() 方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(2,&quot;wangwu&quot;);&#x2F;&#x2F; 获取键值对的数量System.out.println(&quot;键值对的数量：&quot; + map.size()); &#x2F;&#x2F; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Collection<V> values()  方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 获取所有的valueCollection&lt;String&gt; values &#x3D; map.values();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Set<K> keySet() 方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(2,&quot;wangwu&quot;);&#x2F;&#x2F; 获取所有的valueSet&lt;Integer&gt; keys &#x3D; map.keySet();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(2,&quot;wangwu&quot;);Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set &#x3D; map.entrySet();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>Map 集合的遍历</strong>（重点）</p></blockquote><p>第一种方式：获取所有的key，通过遍历key，来遍历value :</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MapTest &#123;    public static void main(String[] args) &#123;        Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(1, &quot;zhangsan&quot;);        map.put(2, &quot;lisi&quot;);        map.put(3, &quot;wangwu&quot;);        map.put(4, &quot;zhaoliu&quot;);        &#x2F;&#x2F; 遍历Map集合        &#x2F;&#x2F; 获取所有的key，所有的key是一个Set集合        Set&lt;Integer&gt; keys &#x3D; map.keySet();        &#x2F;&#x2F; 遍历key，通过key获取value        &#x2F;&#x2F; 迭代器可以        Iterator&lt;Integer&gt; it &#x3D; keys.iterator();        while(it.hasNext())&#123;            &#x2F;&#x2F; 取出其中一个key            Integer key &#x3D; it.next();            &#x2F;&#x2F; 通过key获取value            String value &#x3D; map.get(key);            System.out.println(key + &quot;&#x3D;&quot; + value);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以通过 foreach：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MapTest&#123;    public static void main(String[] args)&#123;        Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(1, &quot;zhangsan&quot;);        map.put(2, &quot;lisi&quot;);        map.put(3, &quot;wangwu&quot;);        map.put(4, &quot;zhaoliu&quot;);        set&lt;Integer&gt; keys &#x3D; map.keySet();                &#x2F;&#x2F; 用foreach遍历集合        for (Integer key : keys)&#123;            System.out.println(key + &quot;&#x3D;&quot; + map.get(key))        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种方式：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() （这种方式效率比较高）<br>以上这个方法是把Map集合直接全部转换成Set集合，Set集合中元素的类型是：Map.Entry</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MapTest&#123;    public static void main(String[] args)&#123;        map.put(1, &quot;zhangsan&quot;);        map.put(2, &quot;lisi&quot;);        map.put(3, &quot;wangwu&quot;);        map.put(4, &quot;zhaoliu&quot;);        &#x2F;&#x2F; 将Map集合转换为Set集合        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set &#x3D; map.entrySet();                &#x2F;&#x2F; 遍历Set集合，迭代器        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it2 &#x3D; set.iterator();        while(it2.hashNext())&#123;            Map.Entry&lt;Integer, String&gt; node &#x3D; it2.next();            Integer key &#x3D; node.getKey();            String value &#x3D; node.getValue();            System.out.println(key + &quot;&#x3D;&quot; + value);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过foreach遍历：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MapTest02 &#123;    public static void main(String[] args) &#123;        Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(1, &quot;zhangsan&quot;);        map.put(2, &quot;lisi&quot;);        map.put(3, &quot;wangwu&quot;);        map.put(4, &quot;zhaoliu&quot;);               Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set &#x3D; map.entrySet();         &#x2F;&#x2F; 遍历Map集合        for(Map.Entry&lt;Integer, String&gt; node : set)&#123;            System.out.println(node.getKey() + &quot;&#x3D;&quot; + node.getValue());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-9-HashMap和HashTable"><a href="#9-9-HashMap和HashTable" class="headerlink" title="9.9 HashMap和HashTable"></a>9.9 HashMap和HashTable</h2><p>HashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。 HashMap在<strong>查找、删除、修改方面都有非常高的效率</strong>。</p><p>HashMap集合：</p><ol><li><p><strong>HashMap集合底层是哈希表&#x2F;散列表的数据结构。</strong></p></li><li><p>哈希表是一个怎样的数据结构呢？<br> 哈希表是一个数组和单向链表的结合体。<br> 数组：在查询方面效率很高，随机增删方面效率很低。<br> 单向链表：在随机增删方面效率较高，在查询方面效率很低。<br> 哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。</p></li><li><p>HashMap集合底层的源代码：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashMap&#123;    &#x2F;&#x2F; HashMap底层实际上就是一个数组。（一维数组）    Node&lt;K,V&gt;[] table;    &#x2F;&#x2F; 静态的内部类HashMap.Node    static class Node&lt;K,V&gt; &#123;        final int hash; &#x2F;&#x2F; 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数&#x2F;算法，可以转换存储成数组的下标。）        final K key; &#x2F;&#x2F; 存储到Map集合中的那个key        V value; &#x2F;&#x2F; 存储到Map集合中的那个value        Node&lt;K,V&gt; next; &#x2F;&#x2F; 下一个节点的内存地址。    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  哈希表&#x2F;散列表：一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）</p></li><li><p>最主要掌握的是：<br> <code>map.put(k,v)</code><br><br><br> <code>v = map.get(k)</code><br>     以上这两个方法的实现原理，是必须掌握的。</p></li><li><p>HashMap集合的key部分特点：<br> 无序，不可重复。</p><blockquote><p>为什么无序？ </p></blockquote><p> ​因为不一定挂到哪个单向链表上。</p><blockquote><p>不可重复是怎么保证的？ </p></blockquote><p> equals方法来保证HashMap集合的key不可重复，如果key重复了，value会覆盖。</p><p> &#x3D;&#x3D;放在HashMap集合key部分的元素其实就是放到HashSet集合中了。&#x3D;&#x3D;<br> 所以HashSet集合中的元素也需要同时重写<code>hashCode()</code>和<code>equals()</code>方法。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.HashMap;import java.util.Map;import java.util.Set;public class HashMapTest01 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 测试HashMap集合key部分的元素特点        &#x2F;&#x2F; Integer是key，它的hashCode和equals都重写了。        Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(1111, &quot;zhangsan&quot;);        map.put(6666, &quot;lisi&quot;);        map.put(7777, &quot;wangwu&quot;);        map.put(2222, &quot;zhaoliu&quot;);        map.put(2222, &quot;king&quot;); &#x2F;&#x2F;key重复的时候value会自动覆盖。        System.out.println(map.size()); &#x2F;&#x2F; 4        &#x2F;&#x2F; 遍历Map集合        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set &#x3D; map.entrySet();        for(Map.Entry&lt;Integer,String&gt; entry : set)&#123;            &#x2F;&#x2F; 验证结果：HashMap集合key部分元素：无序不可重复。            System.out.println(entry.getKey() + &quot;&#x3D;&quot; + entry.getValue());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>哈希表HashMap使用不当时无法发挥性能！<br> 假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了<br> 纯单向链表。这种情况我们成为：散列分布不均匀。</p><blockquote><p>什么是散列分布均匀？</p></blockquote><pre><code> 假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。</code></pre><p> 假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？<br> 不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。散列分布均匀需要你重写hashCode()方法时有一定的技巧。</p></li><li><p>重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，&#x3D;&#x3D;需要同时重写hashCode和equals方法。&#x3D;&#x3D;</p></li><li><p>HashMap集合的默认初始化容量是16，默认加载因子是0.75<br> 这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。<br> 重点，记住：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的，这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。</p></li><li><p>向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！<br> equals方法有可能调用，也有可能不调用。</p><blockquote><p> 拿put(k,v)举例，什么时候equals不会调用？</p></blockquote><pre><code>k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。</code></pre><blockquote><p>   拿get(k)举例，什么时候equals不会调用？</p></blockquote><p> ​        k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。</p><p> <strong>注意</strong>：如果一个类的equals方法重写了，那么hashCode()方法必须重写，并且equals方法返回如果是true，hashCode()方法返回的值必须一样。equals方法返回true表示两个对象相同，在同一个单向链表上比较。那么对于同一个单向链表上的节点来说，他们的哈希值都是相同的。所以hashCode()方法的返回值也应该相同。</p></li><li><p>HashMap集合key部分允许null吗？<br>允许，但是要注意：HashMap集合的key null值只能有一个。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashMapTest03 &#123;    public static void main(String[] args) &#123;&#x2F;&#x2F; 创建集合        Map map &#x3D; new HashMap();        &#x2F;&#x2F; HashMap集合允许key为null        map.put(null, null);        System.out.println(map.size()); &#x2F;&#x2F; 1        &#x2F;&#x2F; key重复的话value是覆盖！        map.put(null, 100);        System.out.println(map.size()); &#x2F;&#x2F;1        &#x2F;&#x2F; 通过key获取value        System.out.println(map.get(null)); &#x2F;&#x2F; 100    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Hashtable</p></blockquote><p><strong>Hashtable的key和value都是不能为null的，HashMap集合的key和value都是可以为null的。</strong></p><p>Hashtable方法都带有synchronized：线程安全的。<br>线程安全有其它的方案，这个Hashtable对线程的处理<br>导致效率较低，使用较少了。</p><p>Hashtable和HashMap一样，底层都是哈希表数据结构。<br>Hashtable的初始化容量是11，默认加载因子是：0.75f<br>Hashtable的扩容是：原容量 * 2 + 1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashtableTest01 &#123;    public static void main(String[] args) &#123;        Map map &#x3D; new Hashtable();        map.put(null, &quot;123&quot;);&#x2F;&#x2F; 空指针异常        map.put(100, null);&#x2F;&#x2F; 空指针异常    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Properties</p></blockquote><p>目前只需要掌握Properties属性类对象的相关方法即可。<br>Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。<br>Properties被称为属性类对象。<br>Properties是线程安全的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PropertiesTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建一个Properties对象        Properties pro &#x3D; new Properties();        &#x2F;&#x2F; 需要掌握Properties的两个方法，一个存，一个取。        pro.setProperty(&quot;url&quot;, &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;bjpowernode&quot;);        pro.setProperty(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;);        pro.setProperty(&quot;username&quot;, &quot;root&quot;);        pro.setProperty(&quot;password&quot;, &quot;123&quot;);        &#x2F;&#x2F; 通过key获取value        System.out.println(pro.getProperty(&quot;url&quot;));        System.out.println(pro.getProperty(&quot;driver&quot;));        System.out.println(pro.getProperty(&quot;username&quot;));        System.out.println(pro.getProperty(&quot;password&quot;));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-10-TreeSet集合（底层是二叉树）"><a href="#9-10-TreeSet集合（底层是二叉树）" class="headerlink" title="9.10 TreeSet集合（底层是二叉树）"></a>9.10 TreeSet集合（底层是二叉树）</h2><p>TreeSet集合存储元素特点：</p><ol><li><p>无序不可重复的，但是存储的元素可以自动按照大小顺序排序，称为：可排序集合。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TreeSetTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建一个TreeSet集合        TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;();        &#x2F;&#x2F; 添加String        ts.add(&quot;zhangsan&quot;);        ts.add(&quot;lisi&quot;);        ts.add(&quot;wangwu&quot;);        &#x2F;&#x2F; 遍历        for(String s : ts)&#123;            &#x2F;&#x2F; 按照字典顺序，升序！            System.out.println(s);        &#125;        TreeSet&lt;Integer&gt; ts2 &#x3D; new TreeSet&lt;&gt;();        ts2.add(100);        ts2.add(200);        ts2.add(900);        for(Integer elt : ts2)&#123;            &#x2F;&#x2F; 升序！            System.out.println(elt);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。</p></li><li><p>TreeSet集合底层实际上是一个TreeMap，而TreeMap集合底层是一个二叉树。</p></li><li><p>放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。</p></li></ol><blockquote><p>对于自定义的类型，TreeSet的排序</p></blockquote><p>以下程序中对于Person类型来说，无法排序。因为没有指定Person对象之间的比较规则。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TreeSetTest03 &#123;    public static void main(String[] args) &#123;        Person p1 &#x3D; new Person(32);        Person p2 &#x3D; new Person(20);        Person p3 &#x3D; new Person(30);        &#x2F;&#x2F; 创建TreeSet集合        TreeSet&lt;Person&gt; persons &#x3D; new TreeSet&lt;&gt;();        &#x2F;&#x2F; 添加元素        persons.add(p1);        persons.add(p2);        persons.add(p3);        &#x2F;&#x2F; 遍历        for (Person p : persons)&#123;            System.out.println(p);        &#125;    &#125;&#125;class Person &#123;    int age;    public Person(int age)&#123;        this.age &#x3D; age;    &#125;    &#x2F;&#x2F; 重写toString()方法    public String toString()&#123;        return &quot;Person[age&#x3D;&quot;+age+&quot;]&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上程序运行的时候出现了这个异常：<br>java.lang.ClassCastException:<br>com.bjpowernode.javase.collection.Person<br>cannot be cast to class java.lang.Comparable<br>    出现这个异常的原因是：<br>        Person类没有实现java.lang.Comparable接口。</p><p><strong>以下通过代码来实现自定义类排序：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*先按照年龄升序，如果年龄一样的再按照姓名升序。 *&#x2F;public class TreeSetTest &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Vip&gt; vips &#x3D; new TreeSet&lt;&gt;();        vips.add(new Vip(&quot;zhangsi&quot;, 20));        vips.add(new Vip(&quot;zhangsan&quot;, 20));        vips.add(new Vip(&quot;king&quot;, 18));        vips.add(new Vip(&quot;soft&quot;, 17));        for(Vip vip : vips)&#123;            System.out.println(vip);        &#125;    &#125;&#125;class Vip implements Comparable&lt;Vip&gt;&#123;    String name;    int age;     public Vip(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;    &#125;    @Override    public String toString() &#123;        return &quot;Vip&#123;&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age&#x3D;&quot; + age r                &#39;&#125;&#39;;    &#125;    &#x2F;*    compareTo方法的返回值很重要：        返回0表示相同，value会覆盖。        返回&gt;0，会继续在右子树上找。【10 - 9 &#x3D; 1 ，1 &gt; 0的说明左边这个数字比较大。所以在右子树上找。】        返回&lt;0，会继续在左子树上找。     *&#x2F;    public int compareTo(Vip v) &#123;        &#x2F;&#x2F; 写排序规则，按照什么进行比较。        if(this.age &#x3D;&#x3D; v.age)&#123;            &#x2F;&#x2F; 年龄相同时按照名字排序。         姓名是String类型，可以直接比。调用compareTo来完成比较。            return this.name.compareTo(v.name);        &#125; else &#123;            &#x2F;&#x2F; 年龄不一样            return this.age - v.age;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TreeSet 集合中元素可排序的第二种方式：使用比较器的方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TreeSetTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建TreeSet集合的时候，需要使用这个比较器。        &#x2F;&#x2F; TreeSet&lt;WuGui&gt; wuGuis &#x3D; new TreeSet&lt;&gt;();&#x2F;&#x2F;这样不行，没有通过构造方法传递一个比较器进去。        &#x2F;&#x2F; 给构造方法传递一个比较器。        TreeSet&lt;WuGui&gt; wuGuis &#x3D; new TreeSet&lt;&gt;(new WuGuiComparator());        wuGuis.add(new WuGui(1000));        wuGuis.add(new WuGui(800));        wuGuis.add(new WuGui(810));        for(WuGui wuGui : wuGuis)&#123;            System.out.println(wuGui);        &#125;    &#125;&#125;&#x2F;&#x2F; 单独在这里编写一个比较器&#x2F;&#x2F; 比较器实现java.util.Comparator接口。（Comparable是java.lang包下的。Comparator是java.util包下的。）class WuGuiComparator implements Comparator&lt;WuGui&gt; &#123;    @Override    public int compare(WuGui o1, WuGui o2) &#123;        &#x2F;&#x2F; 指定比较规则,按照年龄排序        return o1.age - o2.age;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种方式也可以这样写，用匿名内部类的方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TreeSetTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 大家可以使用匿名内部类的方式（这个类没有名字。直接new接口。）        TreeSet&lt;WuGui&gt; wuGuis &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;WuGui&gt;() &#123;            @Override            public int compare(WuGui o1, WuGui o2) &#123;                return o1.age - o2.age;            &#125;        &#125;);        wuGuis.add(new WuGui(1000));        wuGuis.add(new WuGui(800));        wuGuis.add(new WuGui(810));        for(WuGui wuGui : wuGuis)&#123;            System.out.println(wuGui);        &#125;    &#125;&#125;&#x2F;&#x2F; 乌龟class WuGui&#123;    int age;    public WuGui(int age)&#123;        this.age &#x3D; age;    &#125;    @Override    public String toString() &#123;        return &quot;小乌龟[&quot; +                &quot;age&#x3D;&quot; + age +                &#39;]&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于Comparable和Comparator该如何选择<br>    当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。<br>    如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。</p><hr><h1 id="第10章-IO流"><a href="#第10章-IO流" class="headerlink" title="第10章 IO流"></a>第10章 IO流</h1><p>通过IO可以完成硬盘文件的读和写。抽象类InputStream和OutputStream构成了 输入&#x2F;输出，输出和输入都是相对于内存来比较的。输出也就是写，输入是读。</p><h2 id="10-1-流的分类"><a href="#10-1-流的分类" class="headerlink" title="10.1 流的分类"></a>10.1 流的分类</h2><p>流的分类有很多种分类方式：</p><p>​<code>一种方式是按流的方向分类：</code></p><p>​往内存中去，叫做输入（Input）。或者叫做读（Read）。从内存中初来，叫做输出（Output）。或者叫做写（Wirte）。</p><p>​<code>另一种方式是按照读取数据方式不同进行分类：</code></p><p>​有的流是按照字节的方式读取数据，一次读取1个字节byte，这种流什么类型文件都可以读取，比如：图片，视频，MP3，文本文件等。</p><p>​有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取文本文件而存在的，这种流不能读取：图片、MP3、视频、word文档等。</p><blockquote><p>java IO流中有四大家族（抽象类）：</p></blockquote><p>​java.io.InputStream 字节输入流</p><p>​java.io.OutputSrream 字节输入流</p><p>​java.io.Reader 字符输入流</p><p>​java.io.Writer 字符输入流</p><blockquote><p>主要掌握以下16个流</p></blockquote><p><code>文件专属</code>：</p><p>​java.io.FileInputStream</p><p>​java.io.FileOutputStream</p><p>​java.io.FileReader</p><p>​java.io.FileWriter</p><p><code>转换流（将字节流转换成字符流）</code>：</p><p>​java.io.InputStreamReader</p><p>​java.io.OutputStreamWriter</p><p><code>缓冲流专属</code>：</p><p>​java.io.BufferedReader</p><p>​java.io.BufferedWriter</p><p>​java.io.BufferedInputStream</p><p>​java.io.BufferedOutputStream</p><p><code>数据流专属</code>：</p><p>​java.io.DataInputStream</p><p>​java.io.DataOutputStream</p><p><code>标准输出流</code>：<br>    java.io.PrintWriter</p><p>​java.io.PrintStream</p><p><code>对象专属流</code>：</p><p>​java.io.ObjectInputStream</p><p>​java.io.ObjectOutputStream</p><p>​可以看看以下图片作为参考</p><p><img src="https://images2018.cnblogs.com/blog/612774/201807/612774-20180731103830968-1394456905.png" alt="img"></p><h2 id="10-2-文件字节流"><a href="#10-2-文件字节流" class="headerlink" title="10.2 文件字节流"></a>10.2 文件字节流</h2><blockquote><p>java.io.FileInputStream:</p></blockquote><ol><li>文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。</li><li>字节的方式，完成输入的操作，完成读的操作（硬盘—&gt; 内存）</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FileInputStreamTest &#123;    public static void main(String[] args) &#123;        FileInputStream fis &#x3D; null;        try &#123;            &#x2F;&#x2F; 创建文件字节输入流对象            &#x2F;&#x2F; 以下都是采用了：绝对路径的方式。            &#x2F;&#x2F;FileInputStream fis &#x3D; new FileInputStream(&quot;D:\\javase\\temp&quot;);            &#x2F;&#x2F; 写成这个&#x2F;也是可以的。            fis &#x3D; new FileInputStream(&quot;D:&#x2F;javase&#x2F;temp&quot;);            &#x2F;&#x2F; 开始读            int readData &#x3D; fis.read(); &#x2F;&#x2F; 这个方法的返回值是：读取到的“字节”本身。            System.out.println(readData);             readData &#x3D; fis.read();            System.out.println(readData);             &#x2F;&#x2F; 读到文件末尾时，再读的时候读取不到任何数据，返回-1.            readData &#x3D; fis.read();            System.out.println(readData);        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 在finally语句块当中确保流一定关闭。            if (fis !&#x3D; null) &#123; &#x2F;&#x2F; 避免空指针异常！                &#x2F;&#x2F; 关闭流的前提是：流不是空。流是null的时候没必要关闭。                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现对以上文件一个一个读有点繁琐，这里用while循环进行改进：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*对第一个程序进行改进。循环方式。分析这个程序的缺点：    一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上时间&#x2F;资源都耗费    在交互上面了。能不能一次读取多个字节呢？可以。 *&#x2F;public class FileInputStreamTest02 &#123;    public static void main(String[] args) &#123;        FileInputStream fis &#x3D; null;        try &#123;            fis &#x3D; new FileInputStream(&quot;D:\\javase\\temp&quot;);                        int readData &#x3D; 0;            &#x2F;&#x2F; 采用while循环的方式            while((readData &#x3D; fis.read()) !&#x3D; -1)&#123;                System.out.println(readData);            &#125;                    &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fis !&#x3D; null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是以上程序一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上时间&#x2F;资源都耗费在交互上面了。我们需要一次读取多个字节。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FileInputStreamTest &#123;    public static void main(String[] args) &#123;        FileInputStream fis &#x3D; null;        try &#123;            fis &#x3D; new FileInputStream(&quot;D:\\javase\\temp&quot;);            &#x2F;&#x2F; 准备一个byte数组            byte[] bytes &#x3D; new byte[4];                        int readCount &#x3D; 0;            while((readCount &#x3D; fis.read(bytes)) !&#x3D; -1) &#123;                &#x2F;&#x2F; 将byte数组转换成字符串                System.out.print(new String(bytes, 0, readCount));            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fis !&#x3D; null) &#123;                try &#123;                    &#x2F;&#x2F; 关闭流                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>int available()</code>方法 返回流当中剩余的没有读到的字节数量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FileInputStream fis &#x3D; new FileInputStream(&quot;D:\\javase\\temp&quot;);System.out.println(&quot;总字节数量：&quot; + fis.available());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个方法再实际中的用处</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FileInputStream fis &#x3D; new FileInputStream(&quot;D:\\javase\\temp&quot;);byte[] bytes &#x3D; new byte[fis.available()]; &#x2F;&#x2F; 这种方式不太适合太大的文件，因为byte[]数组不能太大。int readCount &#x3D; fis.read(bytes);System.out.println(new String(bytes)); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>long skip(long n)</code>方法跳过几个字节不读。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FileInputStream fis &#x3D; new FileInputStream(&quot;D:\\javase\\temp&quot;);fis.skip(3);&#x2F;&#x2F; 跳过3个字节不读<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>java.io.FileOutputStream</p></blockquote><p>文件字节输出流，负责写。从内存到硬盘。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FileOutputStreamTest &#123;    public static void main(String[] args) &#123;        FileOutputStream fos &#x3D; null;        try &#123;            &#x2F;&#x2F; 以追加的方式在文件末尾写入。不会清空原文件内容。            fos &#x3D; new FileOutputStream(&quot;D:\\javase\\temp&quot;, true);            &#x2F;&#x2F; 开始写。            byte[] bytes &#x3D; &#123;97, 98, 99, 100&#125;;            &#x2F;&#x2F; 将byte数组全部写出！            fos.write(bytes); &#x2F;&#x2F; abcd            &#x2F;&#x2F; 将byte数组的一部分写出！            fos.write(bytes, 0, 2); &#x2F;&#x2F; 再写出ab            &#x2F;&#x2F; 字符串            String s &#x3D; &quot;我是一个中国人，我骄傲！！！&quot;;            &#x2F;&#x2F; 将字符串转换成byte数组。            byte[] bs &#x3D; s.getBytes();            &#x2F;&#x2F; 写            fos.write(bs);            &#x2F;&#x2F; 写完之后，最后一定要刷新            fos.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fos !&#x3D; null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>文件不存在的时候会自动新建！ 这种方式谨慎使用，这种方式会先将原文件清空，然后重新写入。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FileOutputStream fos &#x3D; new FileOutputStream(&quot;myfile&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>学完了字节流就可以开始使用FileInputStream + FileOutputStream完成文件的拷贝。<br>拷贝的过程应该是一边读，一边写。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Copy01 &#123;    public static void main(String[] args) &#123;        FileInputStream fis &#x3D; null;        FileOutputStream fos &#x3D; null;        try &#123;            &#x2F;&#x2F; 创建一个输入流对象            fis &#x3D; new FileInputStream(&quot;D:\\javase\\teamp&quot;);            &#x2F;&#x2F; 创建一个输出流对象            fos &#x3D; new FileOutputStream(&quot;C:\\javase\\teamp&quot;);            &#x2F;&#x2F; 最核心的：一边读，一边写            byte[] bytes &#x3D; new byte[1024 * 1024]; &#x2F;&#x2F; 1MB（一次最多拷贝1MB。）            int readCount &#x3D; 0;            while((readCount &#x3D; fis.read(bytes)) !&#x3D; -1) &#123;                fos.write(bytes, 0, readCount);            &#125;            &#x2F;&#x2F; 刷新，输出流最后要刷新            fos.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 分开try，不要一起try。            &#x2F;&#x2F; 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。            if (fos !&#x3D; null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (fis !&#x3D; null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-3-文件字符流"><a href="#10-3-文件字符流" class="headerlink" title="10.3 文件字符流"></a>10.3 文件字符流</h2><p>文件字符流只能对普通文本进行操作，学了文件字节流之后，这个也就照葫芦画瓢</p><blockquote><p>java.io.FileReader</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FileReaderTest &#123;    public static void main(String[] args) &#123;        FileReader reader &#x3D; null;        try &#123;            &#x2F;&#x2F; 创建文件字符输入流            reader &#x3D; new FileReader(&quot;javase&#x2F;testy&quot;);            &#x2F;&#x2F;准备一个char数组            char[] chars &#x3D; new char[4];            &#x2F;&#x2F; 往char数组中读            reader.read(chars); &#x2F;&#x2F; 按照字符的方式读取：第一次e，第二次f，第三次 风....            for(char c : chars) &#123;                System.out.println(c);            &#125;            &#x2F;*&#x2F;&#x2F; 开始读            char[] chars &#x3D; new char[4]; &#x2F;&#x2F; 一次读取4个字符            int readCount &#x3D; 0;            while((readCount &#x3D; reader.read(chars)) !&#x3D; -1) &#123;                System.out.print(new String(chars,0,readCount));            &#125;*&#x2F;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (reader !&#x3D; null) &#123;                try &#123;                    reader.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>java.io.FileWriter</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FileWriterTest &#123;    public static void main(String[] args) &#123;        FileWriter out &#x3D; null;        try &#123;            &#x2F;&#x2F; 创建文件字符输出流对象            &#x2F;&#x2F;out &#x3D; new FileWriter(&quot;file&quot;);            out &#x3D; new FileWriter(&quot;file&quot;, true);            &#x2F;&#x2F; 开始写。            char[] chars &#x3D; &#123;&#39;我&#39;,&#39;是&#39;,&#39;中&#39;,&#39;国&#39;,&#39;人&#39;&#125;;            out.write(chars);            out.write(chars, 2, 3);            out.write(&quot;我是一名java软件工程师！&quot;);            &#x2F;&#x2F; 刷新            out.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (out !&#x3D; null) &#123;                try &#123;                    out.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用FileReader FileWriter进行拷贝的话，只能拷贝“普通文本”文件:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Copy02 &#123;    public static void main(String[] args) &#123;        FileReader in &#x3D; null;        FileWriter out &#x3D; null;        try &#123;            &#x2F;&#x2F; 读            in &#x3D; new FileReader(&quot;javase\\temp.java&quot;);            &#x2F;&#x2F; 写            out &#x3D; new FileWriter(&quot;Copy02.java&quot;);            &#x2F;&#x2F; 一边读一边写：            char[] chars &#x3D; new char[1024 * 512]; &#x2F;&#x2F; 1MB            int readCount &#x3D; 0;            while((readCount &#x3D; in.read(chars)) !&#x3D; -1)&#123;                out.write(chars, 0, readCount);            &#125;            &#x2F;&#x2F; 刷新            out.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (in !&#x3D; null) &#123;                try &#123;                    in.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (out !&#x3D; null) &#123;                try &#123;                    out.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-4-缓冲字节流"><a href="#10-4-缓冲字节流" class="headerlink" title="10.4 缓冲字节流"></a>10.4 缓冲字节流</h2><p>   Java缓冲流本身并不具有IO流的读取与写入功能，只是在别的流(节点流或其他处理流)上加上缓冲功能提高效率，就像是把别的流包装起来一样，因此缓冲流是一种处理流(包装流)。</p><p>   当对文件或者其他数据源进行频繁的读写操作时，效率比较低，这时如果使用缓冲流就能够更高效的读写信息。因为缓冲流是先将数据缓存起来，然后当缓存区存满后或者手动刷新时再一次性的读取到程序或写入目的地。</p><p>   因此，缓冲流还是很重要的，我们在IO操作时记得加上缓冲流来提升性能。</p><blockquote><p>BuffereReader</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BufferedReaderTest &#123;    public static void main(String[] args) throws Exception&#123;        FileReader reader &#x3D; new FileReader(&quot;Copy02.java&quot;);        &#x2F;&#x2F; 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。        &#x2F;&#x2F; 外部负责包装的这个流，叫做：包装流，还有一个名字叫做：处理流。        &#x2F;&#x2F; 像当前这个程序来说：FileReader就是一个节点流。BufferedReader就是包装流&#x2F;处理流。        BufferedReader br &#x3D; new BufferedReader(reader);        String s &#x3D; null;        &#x2F;&#x2F; readLine()方法是一读读一行        while((s &#x3D; br.readLine()) !&#x3D; null)&#123;            System.out.print(s);        &#125;        &#x2F;&#x2F; 关闭流        &#x2F;&#x2F; 对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。        br.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>BuffereWriter</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.BufferedWriter;import java.io.FileOutputStream;import java.io.FileWriter;public class BufferedWriterTest &#123;    public static void main(String[] args) throws Exception&#123;        &#x2F;&#x2F; 带有缓冲区的字符输出流        BufferedWriter out &#x3D; new BufferedWriter(new FileWriter(&quot;copy&quot;));        &#x2F;&#x2F; 开始写。        out.write(&quot;hello world!&quot;);        out.write(&quot;\n&quot;);        out.write(&quot;hello kitty!&quot;);        &#x2F;&#x2F; 刷新        out.flush();        &#x2F;&#x2F; 关闭最外层        out.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-5-转换流"><a href="#10-5-转换流" class="headerlink" title="10.5 转换流"></a>10.5 转换流</h2><p>InputStreamReader&#x2F;OutputStreamWriter用来实现将字节流转化成字符流</p><blockquote><p>InputStreamReader（将字节流转换成字符流）</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStream;import java.io.InputStreamReader;public class BufferedReaderTest02 &#123;    public static void main(String[] args) throws Exception&#123;        &#x2F;&#x2F; 字节流        FileInputStream in &#x3D; new FileInputStream(&quot;Copy02.java&quot;);        &#x2F;&#x2F; 通过转换流转换（InputStreamReader将字节流转换成字符流。）        &#x2F;&#x2F; in是节点流。reader是包装流。        InputStreamReader reader &#x3D; new InputStreamReader(in);        &#x2F;&#x2F; 这个构造方法只能传一个字符流。不能传字节流。        &#x2F;&#x2F; reader是节点流。br是包装流。        BufferedReader br &#x3D; new BufferedReader(reader);        String line &#x3D; null;        while((line &#x3D; br.readLine()) !&#x3D; null)&#123;            System.out.println(line);        &#125;        &#x2F;&#x2F; 关闭最外层        br.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>OutputStreamWriter（将字节流转换成字符流）</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.BufferedWriter;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.OutputStreamWriter;public class BufferedWriterTest &#123;    public static void main(String[] args) throws Exception&#123;        BufferedWriter out &#x3D; new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;copy&quot;, true)));        &#x2F;&#x2F; 开始写。        out.write(&quot;hello world!&quot;);        out.write(&quot;\n&quot;);        out.write(&quot;hello kitty!&quot;);        &#x2F;&#x2F; 刷新        out.flush();        &#x2F;&#x2F; 关闭最外层        out.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-6-数据流"><a href="#10-6-数据流" class="headerlink" title="10.6 数据流"></a>10.6 数据流</h2><p>这个流在 java.io.DataOutputSteam 包下这个流可以将数据连同数据类型一并写入文件。DataInputStream和DataOutputStream提供了可以存取与机器无关的所有Java基础类型数据(如：int、double、String等)的方法。DataInputStream和DataOutputStream是处理流，可以对其他节点流或处理流进行包装，增加一些更灵活、更高效的功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException; public class TestDataStream &#123;    public static void main(String[] args) &#123;        DataOutputStream dos &#x3D; null;        DataInputStream dis &#x3D; null;        FileOutputStream fos &#x3D; null;        FileInputStream  fis &#x3D; null;        try &#123;            fos &#x3D; new FileOutputStream(&quot;D:&#x2F;data.txt&quot;);            fis &#x3D; new FileInputStream(&quot;D:&#x2F;data.txt&quot;);            &#x2F;&#x2F;使用数据流对缓冲流进行包装，新增缓冲功能            dos &#x3D; new DataOutputStream(new BufferedOutputStream(fos));            dis &#x3D; new DataInputStream(new BufferedInputStream(fis));            &#x2F;&#x2F;将如下数据写入到文件中            dos.writeChar(&#39;a&#39;);            dos.writeInt(10);            dos.writeDouble(Math.random());            dos.writeBoolean(true);            &#x2F;&#x2F;手动刷新缓冲区：将流中数据写入到文件中            dos.flush();            &#x2F;&#x2F;直接读取数据：读取的顺序要与写入的顺序一致，否则不能正确读取数据。            System.out.println(&quot;char: &quot; + dis.readChar());            System.out.println(&quot;int: &quot; + dis.readInt());            System.out.println(&quot;double: &quot; + dis.readDouble());            System.out.println(&quot;boolean: &quot; + dis.readBoolean());        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(dos!&#x3D;null)&#123;                    dos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(dis!&#x3D;null)&#123;                    dis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(fos!&#x3D;null)&#123;                    fos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(fis!&#x3D;null)&#123;                    fis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-7-标准字节流"><a href="#10-7-标准字节流" class="headerlink" title="10.7 标准字节流"></a>10.7 标准字节流</h2><p>这个使用来记录日志的例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.PrintStream;import java.text.SimpleDateFormat;import java.util.Date;&#x2F;*日志工具 *&#x2F;public class Logger &#123;    public static void log(String msg) &#123;        try &#123;            &#x2F;&#x2F; 指向一个日志文件            PrintStream out &#x3D; new PrintStream(new FileOutputStream(&quot;log.txt&quot;, true));            &#x2F;&#x2F; 改变输出方向            System.setOut(out);            &#x2F;&#x2F; 日期当前时间            Date nowTime &#x3D; new Date();            SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);            String strTime &#x3D; sdf.format(nowTime);            System.out.println(strTime + &quot;: &quot; + msg);        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-8-File类"><a href="#10-8-File类" class="headerlink" title="10.8 File类"></a>10.8 File类</h2><p>File类可以用来移除或重命名文件，或者查询文件最后被修改的时间。换句话来说，输入&#x2F; 输出流关心的是文件的内容，而我们在此处要讨论的类关心的是文件在磁盘上的储存。</p><p>File类中的构造方法 <code>File(String pathname)</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建一个File对象File f1 &#x3D; new File(&quot;D:\\file\\t&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>File类访问属性的方法列表：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public boolean exists()</td><td>判断File是否存在</td></tr><tr><td>public boolean isDirectory()</td><td>判断File是否是目录</td></tr><tr><td>public boolean isFile()</td><td>判断File是否是文件</td></tr><tr><td>public long lastModified()</td><td>返回File最后修改时间</td></tr><tr><td>public String getName()</td><td>返回文件名</td></tr><tr><td>public String getPath()</td><td>返回文件的目录路径</td></tr><tr><td>boolean mkdir()</td><td>创建一个目录；中间某个目录缺失，则创建失败</td></tr><tr><td>boolean mkdirs()</td><td>创建多个目录；中间某个目录缺失，则创建该缺失的目录</td></tr><tr><td>void createNewFile()</td><td>创建一个文件</td></tr><tr><td>String getParent()</td><td>获取文件的父路径，返回字符串</td></tr><tr><td>File getParentFile</td><td>获取文件的父路径，返回的是一个File</td></tr><tr><td>getAbsolutePath()</td><td>获取绝对路径</td></tr><tr><td>long length()</td><td>获取文件的大小</td></tr><tr><td>File[] listFiles()</td><td>获取当前目录下所有的子文件</td></tr></tbody></table><ul><li><p>exists()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.bjpowernode.java.io;import java.io.File;public class FileTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 创建一个File对象        File f1 &#x3D; new File(&quot;D:\\file&quot;);        &#x2F;&#x2F; 判断是否存在！        System.out.println(f1.exists());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>isDirectory()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;public class FileTest &#123;    public static void main(String[] args) &#123;        File f1 &#x3D; new File(&quot;D:\\course&quot;);        &#x2F;&#x2F; 判断是否是一个目录,是目录返回true，不是返回false        System.out.println(f1.isDirectory());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>isFile()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;public class FileTest &#123;    public static void main(String[] args) &#123;        File f1 &#x3D; new File(&quot;D:\\course&quot;);        &#x2F;&#x2F; 判断是否是一个文件,是文件返回true，不是返回false        System.out.println(f1.isFile());     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>lastModified()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;public class FileTest &#123;    public static void main(String[] args) &#123;        File f1 &#x3D; new File(&quot;D:\\course&quot;); &#x2F;&#x2F; 获取文件最后一次修改时间        long haoMiao &#x3D; f1.lastModified(); &#x2F;&#x2F; 这个毫秒是从1970年到现在的总毫秒数。    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>getName()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;public class FileTest &#123;    public static void main(String[] args) &#123;        File f1 &#x3D; new File(&quot;D:\\course&quot;);        &#x2F;&#x2F; 获取文件名        System.out.println(f1.getName());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>getPath()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;import java.util.Date;public class TestFile &#123;    public static void main(String[] args) throws Exception &#123;        File f &#x3D; new File(&quot;d:&#x2F;b.txt&quot;);        System.out.println(&quot;File的目录路径：&quot;+f.getPath());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>mkdir()和mkdirs()</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class TestFile &#123;    public static void main(String[] args) throws Exception &#123;        File f &#x3D; new File(&quot;d:&#x2F;c.txt&quot;);        f.createNewFile(); &#x2F;&#x2F; 会在d盘下面生成c.txt文件        f.delete(); &#x2F;&#x2F; 将该文件或目录从硬盘上删除        File f2 &#x3D; new File(&quot;d:&#x2F;电影&#x2F;华语&#x2F;大陆&quot;);        boolean flag &#x3D; f2.mkdir(); &#x2F;&#x2F;目录结构中有一个不存在，则不会创建整个目录树        System.out.println(flag);&#x2F;&#x2F;创建失败                f.createNewFile(); &#x2F;&#x2F; 会在d盘下面生成c.txt文件        f.delete(); &#x2F;&#x2F; 将该文件或目录从硬盘上删除        File f2 &#x3D; new File(&quot;d:&#x2F;电影&#x2F;华语&#x2F;大陆&quot;);        boolean flag &#x3D; f2.mkdirs();&#x2F;&#x2F;目录结构中有一个不存在也没关系；创建整个目录树        System.out.println(flag);&#x2F;&#x2F;创建成功    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>createNewFile()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class FileTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 创建一个File对象        File f1 &#x3D; new File(&quot;D:\\file&quot;);        &#x2F;&#x2F; 如果D:\file不存在，则以文件的形式创建出来        if(!f1.exists()) &#123;            &#x2F;&#x2F; 以文件形式新建            f1.createNewFile();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>getParent()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class FileTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 创建一个File对象        File f1 &#x3D; new File(&quot;D:\\file&quot;);        String parentPath &#x3D; f1.getParent();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>getAbsolutePath()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class FileTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 创建一个File对象        File f1 &#x3D; new File(&quot;D:\\file&quot;);System.out.println(&quot;获取绝对路径：&quot; + parentFile.getAbsolutePath());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>length()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class FileTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 创建一个File对象        File f1 &#x3D; new File(&quot;D:\\file&quot;);        &#x2F;&#x2F; 获取文件大小        System.out.println(f1.length());     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>listFiles()方法</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FileTest &#123;    public static void main(String[] args) &#123;        File f &#x3D; new File(&quot;D:\\course\\01-开课&quot;);        File[] files &#x3D; f.listFiles();        &#x2F;&#x2F; foreach        for(File file : files)&#123;            System.out.println(file.getName());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="10-9-序列化和反序列化"><a href="#10-9-序列化和反序列化" class="headerlink" title="10.9 序列化和反序列化"></a>10.9 序列化和反序列化</h2><p> 把Java对象转换为字节序列的过程称为对象的序列化。把字节序列恢复为Java对象的过程称为对象的反序列化。</p><p>   对象序列化的作用有如下两种：</p><ol><li><p>持久化： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中，比如：休眠的实现。以后服务器session管理，hibernate将对象持久化实现。</p></li><li><p>网络通信：在网络上传送对象的字节序列。比如：服务器之间的数据通信、对象传递。</p></li></ol><p>​     ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。<br>   ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。<br>   只有实现了Serializable接口的类的对象才能被序列化。 Serializable接口是一个空接口，只起到标记作用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable; &#x2F;&#x2F;Person类实现Serializable接口后，Person对象才能被序列化class Person implements Serializable &#123;    &#x2F;&#x2F; 添加序列化ID，它决定着是否能够成功反序列化！    private static final long serialVersionUID &#x3D; 1L;    int age;    boolean isMan;    String name;     public Person(int age, boolean isMan, String name) &#123;        super();        this.age &#x3D; age;        this.isMan &#x3D; isMan;        this.name &#x3D; name;    &#125;     @Override    public String toString() &#123;        return &quot;Person [age&#x3D;&quot; + age + &quot;, isMan&#x3D;&quot; + isMan + &quot;, name&#x3D;&quot; + name + &quot;]&quot;;    &#125;&#125; public class TestSerializable &#123;    public static void main(String[] args) &#123;        FileOutputStream fos &#x3D; null;        ObjectOutputStream oos &#x3D; null;        ObjectInputStream ois &#x3D; null;        FileInputStream fis &#x3D; null;        try &#123;            &#x2F;&#x2F; 通过ObjectOutputStream将Person对象的数据写入到文件中，即序列化。            Person person &#x3D; new Person(18, true, &quot;张三&quot;);            &#x2F;&#x2F; 序列化            fos &#x3D; new FileOutputStream(&quot;d:&#x2F;c.txt&quot;);            oos &#x3D; new ObjectOutputStream(fos);            oos.writeObject(person);            oos.flush();            &#x2F;&#x2F; 反序列化            fis &#x3D; new FileInputStream(&quot;d:&#x2F;c.txt&quot;);            &#x2F;&#x2F; 通过ObjectInputStream将文件中二进制数据反序列化成Person对象：            ois &#x3D; new ObjectInputStream(fis);            Person p &#x3D; (Person) ois.readObject();            System.out.println(p);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (oos !&#x3D; null) &#123;                try &#123;                    oos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (fos !&#x3D; null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (ois !&#x3D; null) &#123;                try &#123;                    ois.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (fis !&#x3D; null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。<br>这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。</p><blockquote><p>一次序列化多个对象呢？</p></blockquote><p>   可以，可以将对象放到集合当中，序列化集合。<br>提示：<br>    参与序列化的ArrayList集合以及集合中的元素User都需要实现 java.io.Serializable接口&gt;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.util.ArrayList;import java.util.List;import java.io.Serializable;public class ObjectOutputStreamTest &#123;    public static void main(String[] args) throws Exception&#123;        List&lt;User&gt; userList &#x3D; new ArrayList&lt;&gt;();        userList.add(new User(1,&quot;zhangsan&quot;));        userList.add(new User(2, &quot;lisi&quot;));        userList.add(new User(3, &quot;wangwu&quot;));        ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;users&quot;));        &#x2F;&#x2F; 序列化一个集合，这个集合对象中放了很多其他对象。        oos.writeObject(userList);        oos.flush();        oos.close();    &#125;&#125;public class User implements Serializable &#123;    private int no;    &#x2F;&#x2F; transient关键字表示游离的，不参与序列化。    private transient String name; &#x2F;&#x2F; name不参与序列化操作！    public User() &#123;    &#125;    public User(int no, String name) &#123;        this.no &#x3D; no;        this.name &#x3D; name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;no&#x3D;&quot; + no +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no &#x3D; no;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-10-IO和Properties的联合应用"><a href="#10-10-IO和Properties的联合应用" class="headerlink" title="10.10 IO和Properties的联合应用"></a>10.10 IO和Properties的联合应用</h2><p>以后经常改变的数据，可以单独写到一个文件中，使用程序动态读取。将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启。就可以拿到动态的信息。</p><p>类似于以上机制的这种文件被称为配置文件。<br>并且当配置文件中的内容格式是：<br>    key1&#x3D;value<br>    key2&#x3D;value<br>我们把这种配置文件叫做属性配置文件。</p><p>java规范中有要求：属性配置文件建议以.properties结尾，但这不是必须的。这种以.properties结尾的文件在java中被称为：属性配置文件。其中Properties是专门存放属性配置文件内容的一个类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileReader;import java.util.Properties;public class IoPropertiesTest &#123;    public static void main(String[] args) throws Exception&#123;        &#x2F;&#x2F; 新建一个输入流对象        FileReader reader &#x3D; new FileReader(&quot;javase&#x2F;userinfo.properties&quot;);        &#x2F;&#x2F; 新建一个Map集合        Properties pro &#x3D; new Properties();        &#x2F;&#x2F; 调用Properties对象的load方法将文件中的数据加载到Map集合中。        pro.load(reader); &#x2F;&#x2F; 文件中的数据顺着管道加载到Map集合中，其中等号&#x3D;左边做key，右边做value        &#x2F;&#x2F; 通过key来获取value        String username &#x3D; pro.getProperty(&quot;username&quot;);        System.out.println(username);        String password &#x3D; pro.getProperty(&quot;password&quot;);        System.out.println(password);        String data &#x3D; pro.getProperty(&quot;data&quot;);        System.out.println(data);        String usernamex &#x3D; pro.getProperty(&quot;usernamex&quot;);        System.out.println(usernamex);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="第11章-多线程"><a href="#第11章-多线程" class="headerlink" title="第11章 多线程"></a>第11章 多线程</h1><p>​多线程在更低一层扩展了多个任务的概念：单个程序看起来同时完成多个任务。每一个任务在线程中执行，线程是控制线程的简称。如果一个程序可以同时运行多个线程，则称这个线程是多线程。</p><p>​多进程与多线程的区别：<br>​本质区别在于每个进程都拥有自己的一整套变量，而线程则共享数据。</p><p>​在实际开发中，多线程非常有用。例如，一个浏览器可以同时下载几个视频。</p><h2 id="11-1-什么是线程"><a href="#11-1-什么是线程" class="headerlink" title="11.1 什么是线程"></a>11.1 什么是线程</h2><p>对于java程序来说，当在Dos命名窗口中输入：<br>    java HelloWorld 回车后。会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。最起码，现在的java程序中至少有两个线程并发，一个是垃圾回收站，一个是执行main方法的主线程。</p><p>对于单核的CPU来说，不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。对于单核的CPU来说，再某个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换，给人的感觉多个事情再同时做。</p><h2 id="11-2-通过继承Thread类实现多线程"><a href="#11-2-通过继承Thread类实现多线程" class="headerlink" title="11.2 通过继承Thread类实现多线程"></a>11.2 通过继承Thread类实现多线程</h2><p> 继承Thread类实现多线程的步骤：</p><ol><li><p>在Java中负责实现线程功能的类是java.lang.Thread 类。</p></li><li><p>可以通过创建 Thread的实例来创建新的线程。</p></li><li><p>每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。</p></li><li><p>通过调用Thread类的start()方法来启动一个线程。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 这里是main方法，这里的代码属于主线程，在主栈中运行。        &#x2F;&#x2F; 新建一个分支线程对象        MyThread t &#x3D; new MyThread();                &#x2F;&#x2F; 启动线程        &#x2F;&#x2F; start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。        &#x2F;&#x2F; 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。        &#x2F;&#x2F; run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。        t.start();        &#x2F;&#x2F; 这里的代码还是运行在主线程中。        for(int i &#x3D; 0; i &lt; 1000; i++)&#123;            System.out.println(&quot;主线程---&gt;&quot; + i);        &#125;    &#125;&#125;class MyThread extends Thread &#123;    @Override    public void run() &#123;        &#x2F;&#x2F; 编写程序，这段程序运行在分支线程中（分支栈）。        for(int i &#x3D; 0; i &lt; 1000; i++)&#123;            System.out.println(&quot;分支线程---&gt;&quot; + i);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-3-通过Runnable接口实现多线程"><a href="#11-3-通过Runnable接口实现多线程" class="headerlink" title="11.3 通过Runnable接口实现多线程"></a>11.3 通过Runnable接口实现多线程</h2><p>   在开发中，我们应用更多的是通过Runnable接口实现多线程。这种方式克服了上一节中实现线程类的缺点，即在实现Runnable接口的同时还可以继承某个类。所以实现Runnable接口的方式要通用一些。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建一个可运行的对象        MyRunnable r &#x3D; new MyRunnable();        &#x2F;&#x2F; 将可运行的对象封装成一个线程对象        Thread t &#x3D; new Thread(r);        &#x2F;&#x2F; 启动线程        t.start();        for(int i &#x3D; 0; i &lt; 100; i++)&#123;            System.out.println(&quot;主线程---&gt;&quot; + i);        &#125;    &#125;&#125;&#x2F;&#x2F; 这并不是一个线程类，是一个可运行的类。它还不是一个线程。class MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        for(int i &#x3D; 0; i &lt; 100; i++)&#123;            System.out.println(&quot;分支线程---&gt;&quot; + i);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对以上代码使用匿名内部类的方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest04 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建线程对象，采用匿名内部类方式。        &#x2F;&#x2F; 这是通过一个没有名字的类，new出来的对象。        Thread t &#x3D; new Thread(new Runnable()&#123;            @Override            public void run() &#123;                for(int i &#x3D; 0; i &lt; 100; i++)&#123;                    System.out.println(&quot;t线程---&gt; &quot; + i);                &#125;            &#125;        &#125;);        &#x2F;&#x2F; 启动线程        t.start();        for(int i &#x3D; 0; i &lt; 100; i++)&#123;            System.out.println(&quot;main线程---&gt; &quot; + i);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-4-线程的生命周期"><a href="#11-4-线程的生命周期" class="headerlink" title="11.4 线程的生命周期"></a>11.4 线程的生命周期</h2><p>线程可以有如下6种状态：</p><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200728231421854-599010774.png" alt="image-20200728113158890"></p><ul><li><p><strong>新生状态(New)</strong></p><pre><code>   用new关键词建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。</code></pre></li><li><p><strong>就绪状态(Runnable)</strong></p><p>  处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态：</p><ol><li>新建线程：调用start()方法，进入就绪状态;</li><li>阻塞线程：阻塞解除，进入就绪状态;</li><li>运行线程：调用yield()方法，直接进入就绪状态;</li><li>运行线程：JVM将CPU资源从本线程切换到其他线程。</li></ol></li><li><p><strong>运行状态(Running)</strong></p><p>  ​          在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。</p></li><li><p><strong>阻塞状态(Blocked)</strong></p><p>  阻塞指的是暂停一个线程的执行以等待某个条件发生。有4种情况会导致阻塞：</p><ol><li>执行sleep(int millsecond)方法，使当前线程进入休眠，进入阻塞状态。当指定的时间到了后，它进入就绪状态。</li><li>执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒后，它进入就绪状态。</li><li>线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()&#x2F;write() 方法本身就是阻塞的方法)。只是当引起该操作阻塞的原因消失后，线程进入就绪状态。</li><li>join()线程联合：当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。</li></ol></li><li><p><strong>死亡状态(Terminated)</strong></p><p>  ​死亡状态是线程生命周期种的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它run()方法的全部工作；另一个是线程被强制终止，如通过stop()或destroy()方法来终止一个线程(注：stop()&#x2F;destroy()方法已经被JDK废弃，不推荐使用)。</p></li></ul><h2 id="11-5获取线程对象和名字"><a href="#11-5获取线程对象和名字" class="headerlink" title="11.5获取线程对象和名字"></a>11.5获取线程对象和名字</h2><p>获取线程对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Thread t &#x3D; Thread.currentThread();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取线程名字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String name &#x3D; 线程对象.getName();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改线程对象的名字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">线程对象.setName(&quot;线程名字&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当线程没有设置名字的时候，默认的名字有什么规律？（了解一下）<br>    Thread-0<br>    Thread-1<br>    Thread-2<br>    Thread-3<br>    …..</p><p>用以下代码实现以上方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest&#123;    public static void main(String[] args)&#123;        Thread currentThread &#x3D; Thread.currentThread();        System.out.println(currentThread.getName());&#x2F;&#x2F; main                &#x2F;&#x2F; 创建线程对象        MyThread2 t &#x3D; new MyThread2();        &#x2F;&#x2F; 设置线程名字        t.setName(&quot;t1&quot;);        &#x2F;&#x2F; 获取线程名字        String tName &#x3D; t.getName();        System.out.println(tName);&#x2F;&#x2F;Thread-0        t.start();    &#125;&#125;class MyThread2 extends Thread &#123;    public void run()&#123;        for(int i &#x3D; 0; i &lt; 100; i++)&#123;            &#x2F;&#x2F; currentThread就是当前线程对象。当前线程是谁呢？            &#x2F;&#x2F; 当t1线程执行run方法，那么这个当前线程就是t1            Thread currentThread &#x3D; Thread.currentThread();            System.out.println(currentThread.getName() + &quot;--&gt;&quot; + i);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-6-暂停线程执行sleep-x2F-yield-x2F-join"><a href="#11-6-暂停线程执行sleep-x2F-yield-x2F-join" class="headerlink" title="11.6 暂停线程执行sleep&#x2F;yield&#x2F;join"></a>11.6 暂停线程执行sleep&#x2F;yield&#x2F;join</h2><p>  暂停线程执行常用的方法有sleep()和yield()方法，这两个方法的区别是：</p><ol><li>sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态。</li><li>yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权。</li></ol><blockquote><p>关于线程的static void sleep(long millis)方法：</p></blockquote><ol><li>静态方法：Thread.sleep(1000);</li><li>参数是毫秒</li><li>作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。这行代码出现在A线程中，A线程就会进入休眠。 这行代码出现在B线程中，B线程就会进入休眠。</li><li>Thread.sleep()方法，可以做到这种效果：<br> 间隔特定的时间，去执行一段特定的代码，每隔多久执行一次。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F;让当前线程休息5秒        try &#123;            Thread.sleep(1000 * 5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 5秒之后执行这里的代码        System.out.println(&quot;hello world!&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sleep睡眠太久了，如果希望半道上醒来，就要用到<code>interrupt()</code>方法<br>    注意：这个不是终断线程的执行，是终止线程的睡眠。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        Thread t &#x3D; new Thread(new MyRunnable2());        t.setName(&quot;t&quot;);        t.start();        &#x2F;&#x2F; 希望5秒之后，t线程醒来        try &#123;            Thread.sleep(1000 * 5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）        t.interrupt();    &#125;&#125;class MyRunnable2 implements Runnable &#123;    &#x2F;&#x2F; 重点：run()当中的异常不能throws，只能try catch    &#x2F;&#x2F; 因为run()方法在父类中没有抛出任何异常，子类不能比父类抛出更多的异常。    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot;---&gt; begin&quot;);        try &#123;            &#x2F;&#x2F; 睡眠1年            Thread.sleep(1000 * 60 * 60 * 24 * 365);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F;1年之后才会执行这里        System.out.println(Thread.currentThread().getName() + &quot;---&gt; end&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>static void yield() 让位方法</p></blockquote><p>暂停当前正在执行的线程对象，并执行其他线程yield()方法不是阻塞方法。让当前线程让位，让给其他线程使用。yield()方法的执行会让当前线程从”运行状态“回到“就绪状态”</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestThreadState &#123;    public static void main(String[] args) &#123;        StateThread thread1 &#x3D; new StateThread();        thread1.start();        StateThread thread2 &#x3D; new StateThread();        thread2.start();    &#125;&#125;&#x2F;&#x2F;使用继承方式实现多线程class StateThread extends Thread &#123;    public void run() &#123;        for (int i &#x3D; 0; i &lt; 100; i++) &#123;            System.out.println(this.getName() + &quot;:&quot; + i);            Thread.yield();&#x2F;&#x2F;调用线程的yield()方法；        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>join()线程合并</p></blockquote><p> 线程A在运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest&#123;    public static void mian(String[] args)&#123;        Thread t &#x3D; new Thread(new MyRunnable());        t.start();    &#125;    &#x2F;&#x2F; 合并线程    try&#123;        t.join(); &#x2F;&#x2F; t合并到当前线程中，当前线程受到阻塞，t线程执行直到结束。    &#125; catch (InterruptedException e)&#123;        e.printStackTrace();    &#125;    &#x2F;&#x2F; t线程执行完拆了才能执行这行代码    System.out.println(&quot;main over&quot;);&#125;class MyRunnable implements Runnable &#123;    public void run() &#123;        for(int i &#x3D; 10; i &lt; 100; i++)&#123;            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-7-强制终止线程的执行"><a href="#11-7-强制终止线程的执行" class="headerlink" title="11.7 强制终止线程的执行"></a>11.7 强制终止线程的执行</h2><p>   终止线程我们一般不使用JDK提供的stop()&#x2F;destroy()方法(它们本身也被JDK废弃了)。<br>在java中怎么强行终止一个线程的执行。<br>    这种方式存在很大的缺点：容易丢失数据。因为这种方式是直接将线程杀死了，线程没有保存的数据将会丢失。不建议使用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest09 &#123;    public static void main(String[] args) &#123;        Thread t &#x3D; new Thread(new MyRunnable3());        t.setName(&quot;t&quot;);        t.start();        &#x2F;&#x2F; 模拟5秒        try &#123;            Thread.sleep(1000 * 5);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 5秒之后强行终止t线程        t.stop(); &#x2F;&#x2F; 已过时（不建议使用。）    &#125;&#125;class MyRunnable3 implements Runnable &#123;    @Override    public void run() &#123;        for(int i &#x3D; 0; i &lt; 10; i++)&#123;            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + i);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest10 &#123;    public static void main(String[] args) &#123;        MyRunable4 r &#x3D; new MyRunable4();        Thread t &#x3D; new Thread(r);        t.setName(&quot;t&quot;);        t.start();        &#x2F;&#x2F; 模拟5秒        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 终止线程        &#x2F;&#x2F; 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。        r.run &#x3D; false;    &#125;&#125;class MyRunable4 implements Runnable &#123;    &#x2F;&#x2F; 打一个布尔标记    boolean run &#x3D; true;    @Override    public void run() &#123;        for (int i &#x3D; 0; i &lt; 10; i++)&#123;            if(run)&#123;                System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + i);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;else&#123;                &#x2F;&#x2F; return就结束了，你在结束之前还有什么没保存的。                &#x2F;&#x2F; 在这里可以保存。                &#x2F;&#x2F;save....                &#x2F;&#x2F;终止当前线程                return;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-8-线程的优先级"><a href="#11-8-线程的优先级" class="headerlink" title="11.8 线程的优先级"></a>11.8 线程的优先级</h2><ol><li><p>处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选。</p></li><li><p>线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5。</p></li><li><p>使用下列方法获得或设置线程对象的优先级。</p></li></ol><p>​     int getPriority();</p><p>​     void setPriority(int newPriority);</p><p>   注意：优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest&#123;    public static void main(String[] args)&#123;        System.out.println(&quot;最高优先级&quot; + Thread.MAX_PRIORITY); &#x2F;&#x2F; 10        System.out.println(&quot;最低优先级&quot; + Thread.MIN_PRIORITY); &#x2F;&#x2F; 1        System.out.println(&quot;默认优先级&quot; + Thread.NORM_PRIORITY); &#x2F;&#x2F;5    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-9-线程同步"><a href="#11-9-线程同步" class="headerlink" title="11.9 线程同步"></a>11.9 线程同步</h2><p> 在大多数实例的多线程应用中，两个或两个以上的线程需要共享同一数据的存取。如果两个线程存取同一个对象，并且每个线程分别调用了一个修改该对象状态的方法，会导致两个线程会互相覆盖。</p><p><strong>竞态条件的一个例子</strong></p><p>为了避免多线程破坏共享数据，必须学习如何同步存取。在下面的测试程序中，还是考虑我们模拟的银行。</p><p>银行账户:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Account &#123;    &#x2F;&#x2F; 账号    private String actno;    &#x2F;&#x2F; 余额    private double balance;    public Account() &#123;    &#125;    public Account(String actno, double balance) &#123;        this.actno &#x3D; actno;        this.balance &#x3D; balance;    &#125;    public String getActno() &#123;        return actno;    &#125;    public void setActno(String actno) &#123;        this.actno &#x3D; actno;    &#125;    public double getBalance() &#123;        return balance;    &#125;    public void setBalance(double balance) &#123;        this.balance &#x3D; balance;    &#125;    &#x2F;&#x2F;取款的方法    public void withdraw(double money)&#123;        &#x2F;&#x2F; t1和t2并发这个方法。。。。（t1和t2是两个栈。两个栈操作堆中同一个对象。）        &#x2F;&#x2F; 取款之前的余额        double before &#x3D; this.getBalance(); &#x2F;&#x2F; 10000        &#x2F;&#x2F; 取款之后的余额        double after &#x3D; before - money;        &#x2F;&#x2F; 在这里模拟一下网络延迟，100%会出现问题        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 更新余额        &#x2F;&#x2F; 思考：t1执行到这里了，但还没有来得及执行这行代码，t2线程进来withdraw方法了。此时一定出问题。        this.setBalance(after);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>run方法不断地从一个给定银行账户取钱。每次取钱没等待银行账户更新，导致了银行资金泄露</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AccountThread extends Thread &#123;    &#x2F;&#x2F; 两个线程必须共享同一个账户对象。    private Account act;    &#x2F;&#x2F; 通过构造方法传递过来账户对象    public AccountThread(Account act) &#123;        this.act &#x3D; act;    &#125;    public void run()&#123;        &#x2F;&#x2F; run方法的执行表示取款操作。        &#x2F;&#x2F; 假设取款5000        double money &#x3D; 5000;        &#x2F;&#x2F; 取款        &#x2F;&#x2F; 多线程并发执行这个方法。        act.withdraw(money);        System.out.println(Thread.currentThread().getName() + &quot;对&quot;+act.getActno()+&quot;取款&quot;+money+&quot;成功，余额&quot; + act.getBalance());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序的时候，可能很快就能发现错误，有时可能需要很长时间才能方向余额不对。这种情况可能很影响人们的信任</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建账户对象（只创建1个）        Account act &#x3D; new Account(&quot;act-001&quot;, 10000);        &#x2F;&#x2F; 创建两个线程        Thread t1 &#x3D; new AccountThread(act);        Thread t2 &#x3D; new AccountThread(act);        &#x2F;&#x2F; 设置name        t1.setName(&quot;t1&quot;);        t2.setName(&quot;t2&quot;);        &#x2F;&#x2F; 启动线程取款        t1.start();        t2.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-9-1锁对象"><a href="#11-9-1锁对象" class="headerlink" title="11.9.1锁对象"></a>11.9.1锁对象</h3><p>怎么解决线程安全问题呢？<br>            线程排队执行。（不能并发）。用排队执行解决线程安全问题。机制被称为：线程同步机制。专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行。使用“线程同步机制”。线程同步就是线程排队了，线程排队了就会牺牲一部分效率，数据安全第一位，只有数据安全了，我们才可以谈效率。</p><p>&#x3D;&#x3D;异步编程模型：&#x3D;&#x3D;<br>    线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，<br>    谁也不需要等谁，这种编程模型叫做：异步编程模型。<br>    其实就是：多线程并发（效率较高。）异步就是并发。</p><p>&#x3D;&#x3D;同步编程模型：&#x3D;&#x3D;<br>    线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行<br>    结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，<br>    两个线程之间发生了等待关系，这就是同步编程模型。<br>    效率较低。线程排队执行。同步就是排队。</p><blockquote><p><strong>&#x3D;&#x3D;synchronized关键字&#x3D;&#x3D;</strong></p></blockquote><p>有两种机制可以防止并发访问代码块。Java语言中提供了一个synchronized关键字来达到这一目标。synchronized关键字会自动提供一个锁以及相关的“条件”，对于大多数需要显示锁的情况，这种机制功能强大也很便利。</p><p>锁和条件的要点：</p><ul><li>锁用来保护代码片段，一次只能有一个线程执行被保护的代码。</li><li>锁可以管理试图进入被保护代码段的线程。</li><li>一个锁可以有一个或多个相关联的对象。</li><li>每一个条件对象管理那些已经进入被保护代码段但还不能运行的线程。，</li></ul><p>从1.0版本开始，Java中每个对象都有一个内部锁。如果一个方法声明时有synchronized关键字，那么对象的锁保护整个方法。也就是锁，要调用这个方法，线程必须获得内部对象锁。</p><p>通过在方法声明中加入 synchronized关键字来声明，语法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public synchronized void accessVal( int newVal);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</p><p>线程可以同个方法获得，还可以有另一种机制可以获得锁：即进入一个同步块</p><p> synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">synchronized(syncObject)　  &#123; 　　 &#x2F;&#x2F;允许访问控制的代码 　  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>总结：<br>    synchronized有三种写法：</p><p>第一种：同步代码块<br>    灵活</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">synchronized(线程共享对象)&#123;同步代码块;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二种：在实例方法上使用synchronized<br>    表示共享对象一定是this<br>    并且同步代码块是整个方法体。</p><p>第三种：在静态方法上使用synchronized<br>    表示找类锁。<br>    类锁永远只有1把。<br>    就算创建了100个对象，那类锁也只有一把。</p><p>对象锁：1个对象1把锁，100个对象100把锁。<br>类锁：100个对象，也可能只是1把类锁。</p><h2 id="11-10-死锁"><a href="#11-10-死锁" class="headerlink" title="11.10 死锁"></a>11.10 死锁</h2><p>   “死锁”指的是：</p><p>   多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。</p><p>   因此， 某一个同步块需要同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。下面案例中都在互相等待对方释放资源，才能解锁。这样，两个线程就形成了互相等待，无法继续运行的“死锁状态”。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DeadLock&#123;    public static void main(String[] args)&#123;        Object o1 &#x3D; new Object();        Object o2 &#x3D; new Object();        Thread t1 &#x3D; new MyThread1(o1, o2);        Thread t2 &#x3D; new MyThread2(o1, o2);        t1.start();        t2.start();    &#125;&#125;class MyThread1 extends Thread&#123;    Object o1;    Object o2;    public MyThread1(Object o2, Object o2)&#123;        this.o1 &#x3D; o1;        this.o2 &#x3D; o2;    &#125;    public void run()&#123;        synchronized (o1)&#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            synchronized (o2)&#123;            &#125;        &#125;    &#125;&#125;class MyThread2 extends Thread &#123;    Object o1;    Object o2;    public MyThread2(Object o1,Object o2)&#123;        this.o1 &#x3D; o1;        this.o2 &#x3D; o2;    &#125;    public void run()&#123;        synchronized (o2)&#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            synchronized (o1)&#123;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-11守护线程"><a href="#11-11守护线程" class="headerlink" title="11.11守护线程"></a>11.11守护线程</h2><p>java语言中线程分为两大类：</p><ol><li>用户线程</li><li>守护线程（后台线程）</li></ol><p>守护线程的特点：<br>​一般守护线程是一个死循环，所有的用户线程只要结束。守护线程自动结束。</p><p>注意：主线程main方法是一个用户线程。</p><p>守护线程一般用在数据备份。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadTest14 &#123;    public static void main(String[] args) &#123;        Thread t &#x3D; new BakDataThread();        t.setName(&quot;备份数据的线程&quot;);        &#x2F;&#x2F; 启动线程之前，将线程设置为守护线程        t.setDaemon(true);        t.start();        &#x2F;&#x2F; 主线程：主线程是用户线程        for(int i &#x3D; 0; i &lt; 10; i++)&#123;            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + i);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;class BakDataThread extends Thread &#123;    public void run()&#123;        int i &#x3D; 0;        &#x2F;&#x2F; 即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。        while(true)&#123;            System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + (++i));            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-12定时器"><a href="#11-12定时器" class="headerlink" title="11.12定时器"></a>11.12定时器</h2><p>定时器的作用：<br>间隔特定的时间，执行特定的程序。例如：每周要进行银行的总站操作。每天要进行数据的备份操作。在实际开发中，每隔多久执行一段特定的程序，这种需求是很常见的，在java中其实可以采用多种方式实现：可以使用sleep方法，睡眠，设置睡眠时间，每到这个时间点醒来，执行任务。</p><p>在Java的类库中已经写好了一个定时器：java.util.Timer ,可以直接拿来用。在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，这个框架只要进行简单的配置，就可以完成定时器的任务。</p><p>使用定时器指定定时任务</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 创建定时器对象        Timer timer &#x3D; new Timer();        &#x2F;&#x2F;Timer timer &#x3D; new Timer(true); &#x2F;&#x2F;守护线程的方式        &#x2F;&#x2F; 指定定时任务        &#x2F;&#x2F;timer.schedule(定时任务, 第一次执行时间, 间隔多久执行一次);        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        Date firstTime &#x3D; sdf.parse(&quot;2020-03-14 09:34:30&quot;);        &#x2F;&#x2F;timer.schedule(new LogTimerTask() , firstTime, 1000 * 10);    &#125;&#125;&#x2F;&#x2F; 编写一个定时任务类&#x2F;&#x2F; 假设这是一个记录日志的定时任务class LogTimerTask extends TimerTask &#123;    @Override    public void run() &#123;        &#x2F;&#x2F; 编写你需要执行的任务就行了。        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String strTime &#x3D; sdf.format(new Date());        System.out.println(strTime + &quot;:成功完成了一次数据备份！&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h2 id="11-13实现多线程的第三种方式（JDK8新特性）"><a href="#11-13实现多线程的第三种方式（JDK8新特性）" class="headerlink" title="11.13实现多线程的第三种方式（JDK8新特性）"></a>11.13实现多线程的第三种方式（JDK8新特性）</h2><p>在11.2章和11.3章我们实现了多线程的两种方式，之前简介的那两种方式是无法获取线程返回值的，因为run方法返回void。以下我们来看看第三种方式</p><ol><li>创建Callable接口实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li><li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask封装了该Callable对象的call()方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后得返回值</li></ol><p>实现代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask; &#x2F;&#x2F;JUC包下的，属于java的并发包，老JDK中没有这个包。新特性。&#x2F;*实现线程的第三种方式:    实现Callable接口    这种方式的优点:可以获得线程的执行结果。    这种方式的缺点:效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。 *&#x2F;public class ThreadTeat15 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 第一步:创建一个“未来任务类”对象。        &#x2F;&#x2F;参数非常重要，需要给一个Callable接口实现类对象，这里采用的匿名内部类        FutureTask task &#x3D; new FutureTask(new Callable() &#123;            @Override            public Object call() throws Exception &#123; &#x2F;&#x2F;call()方法相当于run方法。只不过这个有返回值                &#x2F;&#x2F;线程执行一个任务，执行之后可能会有一个执行结果。                &#x2F;&#x2F;模拟执行                System.out.println(&quot;call method begin&quot;);                Thread.sleep(1000 * 10);                System.out.println(&quot;call method end!&quot;);                int a &#x3D; 100;                int b &#x3D; 200;                return a + b;&#x2F;&#x2F;自动装箱(300结果变成Integer)            &#125;        &#125;);        &#x2F;&#x2F;创建线程对象        Thread t &#x3D; new Thread(task);        &#x2F;&#x2F;启动线程        t.start();        try &#123;            &#x2F;&#x2F;这里是main方法，这是在主线中。            &#x2F;&#x2F;在主线程，获取t线程的返回结果.            &#x2F;&#x2F;get()方法的执行会导致“当前线程堵塞”            Object obj &#x3D; task.get();            System.out.println(&quot;线程执行结果:&quot; + obj);            &#x2F;&#x2F;main方法这里的程序要想执行必须等待get()方法的结束            &#x2F;&#x2F;而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果            &#x2F;&#x2F;另一个线程的执行是需要时间的            System.out.println(&quot;hello world!&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-14-生产者-x2F-消费者模式"><a href="#11-14-生产者-x2F-消费者模式" class="headerlink" title="11.14 生产者 &#x2F; 消费者模式"></a>11.14 生产者 &#x2F; 消费者模式</h2><p>   多线程环境下，我们经常需要多个线程的并发和协作。这个时候，就需要了解一个重要的多线程并发协作模型“生产者&#x2F;消费者模式”。</p><p><strong>什么是生产者?</strong></p><p>   生产者指的是负责生产数据的模块(这里模块可能是：方法、对象、线程、进程)。</p><p><strong>什么是消费者?</strong></p><p>   消费者指的是负责处理数据的模块(这里模块可能是：方法、对象、线程、进程)。</p><ol><li>使用wait方法和notify方法实现“生产者和消费者模式”</li><li>什么是“生产者和消费者模式”？<br> 生产线程负责生产，消费线程负责消费。<br> 生产线程和消费线程要达到均衡。<br> 这是一种特殊的业务需求，在这种特殊的情况下需要使用wait方法和notify方法。</li><li>wait和notify方法不是线程对象的方法，是普通java对象都有的方法。</li><li>wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作一个仓库。有线程安全问题。</li><li>wait方法作用：o.wait()让正在o对象上活动的线程t进入等待状态，并且释放掉t线程之前占有的o对象的锁。</li><li>notify方法作用：o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。</li><li>模拟这样一个需求：<br> 仓库我们采用List集合。<br> List集合中假设只能存储1个元素。<br> 1个元素就表示仓库满了。<br> 如果List集合中元素个数是0，就表示仓库空了。<br> 保证List集合中永远都是最多存储1个元素。</li></ol><p>必须做到这种效果：生产1个消费1个。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.thread;import java.util.ArrayList;import java.util.List;public class ThreadTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建1个仓库对象，共享的。        List list &#x3D; new ArrayList();        &#x2F;&#x2F; 创建两个线程对象        &#x2F;&#x2F; 生产者线程        Thread t1 &#x3D; new Thread(new Producer(list));        &#x2F;&#x2F; 消费者线程        Thread t2 &#x3D; new Thread(new Consumer(list));        t1.setName(&quot;生产者线程&quot;);        t2.setName(&quot;消费者线程&quot;);        t1.start();        t2.start();    &#125;&#125;&#x2F;&#x2F; 生产线程class Producer implements Runnable &#123;    &#x2F;&#x2F; 仓库    private List list;    public Producer(List list) &#123;        this.list &#x3D; list;    &#125;    @Override    public void run() &#123;        &#x2F;&#x2F; 一直生产（使用死循环来模拟一直生产）        while (true) &#123;            &#x2F;&#x2F; 给仓库对象list加锁。            synchronized (list) &#123;                if (list.size() &gt; 0) &#123; &#x2F;&#x2F; 大于0，说明仓库中已经有1个元素了。                    try &#123;                        &#x2F;&#x2F; 当前线程进入等待状态，并且释放Producer之前占有的list集合的锁。                        list.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                &#x2F;&#x2F; 程序能够执行到这里说明仓库是空的，可以生产                Object obj &#x3D; new Object();                list.add(obj);                System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + obj);                &#x2F;&#x2F; 唤醒消费者进行消费                list.notifyAll();            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 消费线程class Consumer implements Runnable &#123;    &#x2F;&#x2F; 仓库    private List list;    public Consumer(List list) &#123;        this.list &#x3D; list;    &#125;    @Override    public void run() &#123;        &#x2F;&#x2F; 一直消费        while (true) &#123;            synchronized (list) &#123;                if (list.size() &#x3D;&#x3D; 0) &#123;                    try &#123;                        &#x2F;&#x2F; 仓库已经空了。                        &#x2F;&#x2F; 消费者线程等待，释放掉list集合的锁                        list.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                &#x2F;&#x2F; 程序能够执行到此处说明仓库中有数据，进行消费。                Object obj &#x3D; list.remove(0);                System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + obj);                &#x2F;&#x2F; 唤醒生产者生产。                list.notifyAll();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="第12章-反射"><a href="#第12章-反射" class="headerlink" title="第12章 反射"></a>第12章 反射</h1><p>​反射库提供了一个丰富且精巧的工具集，可以用来编写能够动态操纵Java代码的程序。使用反射，Java可以支持用户界面生成器、对象关系映射器以及很多其他需要动态查询类能力的开发工具。</p><p>​反射机制的功能极其强大，反射机制的相关类在<code>java.lang.reflect.*</code>包下反射机制可以用来：</p><ul><li>在运行时分析类的能力。</li><li>在运行时检查对象，例如，编写一个适合用于所有类的toString方法。</li><li>实现泛型数据操作代码。</li><li>利用Method对象，这个对象很像C++中函数指针。</li></ul><blockquote><p>反射机制相关的重要的类有哪些？</p></blockquote><ul><li>java.lang.Class：代表整个字节码，代表一个类型，代表整个类。</li><li>java.lang.reflect.Method：代表字节码中的方法字节码。代表类中的方法。</li><li>java.lang.reflect.Constructor：代表字节码中的构造方法字节码。代表类中的构造方法</li><li>java.lang.reflect.Field：代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</li></ul><h2 id="12-1-Class-类"><a href="#12-1-Class-类" class="headerlink" title="12.1 Class 类"></a>12.1 Class 类</h2><p>​在程序运行期间，Java运行时系统始终为所有维护一个运行时类型标识。这个信息会跟踪每个对象所属的类。虚拟机利用运行时类型信息选择要执行的正确方法。</p><p>​不过，可以使用一个特殊的Java类访问这些信息。</p><p>在java中获取Class的三种方式：</p><ul><li>第一种：<br>           Class c &#x3D; Class.forName(“完整类名”);</li><li>第二种：<br>           Class c &#x3D; 对象.getClass();</li><li>第三种：<br>           Class c &#x3D; int.class;<br>                Class c &#x3D; String.class;</li></ul><p></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.reflect;import java.util.Date;&#x2F;*要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？    三种方式        第一种:Class c &#x3D; Class.forName(&quot;完整类名带包名&quot;);        第二种:Class c &#x3D; 对象.getClass();        第三种:Class c &#x3D; 任何类型.class; *&#x2F;public class ReflectTest01 &#123;    public static void main(String[] args) &#123;        &#x2F;*        Class.forName()            1、静态方法            2、方法的参数是一个字符串。            3、字符串需要的是一个完整的类名。            4、完整类名必须带有包名。java.lang包也不能省略         *&#x2F;        Class c1 &#x3D; null;        try &#123;            c1 &#x3D; Class.forName(&quot;java.lang.String&quot;);  &#x2F;&#x2F; c1代表String.class文件，或者c1代表String类型。            Class c2 &#x3D; Class.forName(&quot;java.util.Date&quot;);    &#x2F;&#x2F;c2代表Date类型            Class c3 &#x3D; Class.forName(&quot;java.lang.Integer&quot;);  &#x2F;&#x2F;c3代表Integer类型            Class c4 &#x3D; Class.forName(&quot;java.lang.System&quot;);   &#x2F;&#x2F;c4代表System        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F;第二种方式:java中任何一个对象都有一个方法:getClass()        String s &#x3D; &quot;abc&quot;;        Class x &#x3D; s.getClass();   &#x2F;&#x2F;x代表String.class字节码文件，x代表String类型。        System.out.println(c1&#x3D;&#x3D;x);&#x2F;&#x2F;true(&#x3D;&#x3D;判断的是对象的内存地址。)        System.out.println(c1.equals(x));        &#x2F;&#x2F;第三种方法，java语言中任何一种类型，包括基本数据类型，它都有.class属性。        Class z &#x3D; String.class; &#x2F;&#x2F;z代表String类型        Class k &#x3D; Date.class; &#x2F;&#x2F;k代表Date类型        Class f &#x3D; int.class;  &#x2F;&#x2F;f代表int类型        Class e &#x3D; double.class; &#x2F;&#x2F;e代表double类型        System.out.println(x &#x3D;&#x3D; z);&#x2F;&#x2F;true    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取了Class之后，可以调用无参数构造方法来实例化对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;c代表的就是日期Date类型Class c &#x3D; Class.forName(&quot;java.util.Date&quot;);&#x2F;&#x2F;实例化一个Date日期类型的对象Object obj &#x3D; c.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一定要注意：<br>    newInstance()底层调用的是该类型的无参数构造方法。<br>    如果没有这个无参数构造方法会出现”实例化”异常。</p><p>验证反射机制的灵活性。<br>    java代码写一遍，在不改变java源代码的基础之上，可以做到不同对象的实例化。非常之灵活。（符合OCP开闭原则:对扩展开放，对修改关闭。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileReader;import java.util.Properties;public class ReflectTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 这种方式代码就写死了，只能创建一个User类型对象        &#x2F;&#x2F;User user &#x3D; new User();        &#x2F;&#x2F; 以下代码是灵活的，代码不需要改动，可以修改配置文件，配置文件修改之后，可以创建出不同的实例对象        &#x2F;&#x2F; 通过IO流读取classinfo.properties文件        FileReader reader &#x3D; new FileReader(&quot;E:\\Project\\laodu\\charpter25\\classinfo2.properties&quot;);        &#x2F;&#x2F; 创建属性对象Map        Properties pro &#x3D; new Properties();  &#x2F;&#x2F;key value都是String        &#x2F;&#x2F; 加载        pro.load(reader);        &#x2F;&#x2F; 关闭流        reader.close();        &#x2F;&#x2F; 通过key获取value        String className &#x3D; pro.getProperty(&quot;className&quot;);        &#x2F;&#x2F;System.out.println(className);        &#x2F;&#x2F;通过反射机制实例化对象        Class c &#x3D;  Class.forName(className);        Object obj &#x3D; c.newInstance();        System.out.println(obj);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>研究一下:Class.forName()发生了什么？</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.reflect;public class ReflectTest04 &#123;    public static void main(String[] args) &#123;        try &#123;            &#x2F;&#x2F; Class.forName() 这个方法的执行会导致:类加载。            Class.forName(&quot;javase.reflect.MyClass&quot;);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;class MyClass&#123;    &#x2F;&#x2F;静态代码块在类加载时执行，并且只执行一次。    static &#123;        System.out.println(&quot;MyClass类的静态代码块执行了！&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img2020.cnblogs.com/blog/2082193/202007/2082193-20200731193628424-1319184094.png" alt="image-20200729204558824"></p><p>如果你只希望一个类的静态代码块执行，其他代码一律不执行，<br>你可以使用:  <code> Class.forName(&quot;完整类名&quot;)</code>这个方法的执行会导致类加载，类加载时，静态代码块执行.</p><h2 id="12-2-关于路径问题"><a href="#12-2-关于路径问题" class="headerlink" title="12.2 关于路径问题"></a>12.2 关于路径问题</h2><p>关于路径的问题前面有说过，以前我们用的这种方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AboutPath &#123;    public static void main(String[] args)&#123;        try &#123;            File Reader reader &#x3D; new FileReader(&quot;charpter25&#x2F;classinfo2.properties&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是以上方式的移植性差，在IDEA中默认的当前路径是project的根。这个代码离开了IDEA，换到其他位置可能就不是project的根了，这时这个路径就无效了。</p><p>以下讲解的这种方式是通用的。但是前提：文件要在类路径下。才能使用这种方式。类路径就是src的根路径。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AboutPath &#123;    public static void main(String[] args) &#123;                &#x2F;*       解释：       Thread.currentThread() 当前线程对象       getContextClassLoader() 是线程对象的方法，可以获取的当前线程的类加载对象。       getResourec() 这是类加载器对象的方法，当前线程的累加载器默认从类的根路径下加载资源       getPath() 获取绝对路径，返回字符串。        *&#x2F;        String path &#x3D; Thread.currentThread().getContextClassLoader().getResource(&quot;classinfo2.properties&quot;).getPath();                &#x2F;&#x2F;  采用以上的代码可以拿到一个文件的绝对路径        &#x2F;&#x2F;  &#x2F;E:&#x2F;Project&#x2F;out&#x2F;production&#x2F;charpter25&#x2F;classinfo2.properties        System.out.println(path);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在类加载对象中<code>getResourceAsStream()</code>方法可以直接以流的方式返回</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.InputStream;import java.util.Properties;public class IoPropertiesTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 直接以流的形式返回        InputStream reader &#x3D; Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;classinfo.properties&quot;);        Properties pro &#x3D; new Properties();        try &#123;            pro.load(reader);        &#125; catch (IOException e)&#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                reader.close();            &#125; cath (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        &#x2F;&#x2F; 通过key获取value        String className &#x3D; pro.getProperty(&quot;className&quot;);        System.out.println(className);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容。使用以下这种方式的时候，属性配置文件必须放到类路径下。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ResourceBundle;pubic class ResourceBundleTest&#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 资源绑定器，只能绑定xxx.properties文件。并且这个文件必须在类路径下。文件扩展名也必须是properties        &#x2F;&#x2F; 并且在写路径的时候，路径后面的扩展名也不能写        ResourceBundle bundle &#x3D; ResourceBundle.getBundle(&quot;classinfo&quot;);        String className &#x3D; bundle.getString(&quot;className&quot;);        System.out.println(className);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-3通过反射获取属性（Field）"><a href="#12-3通过反射获取属性（Field）" class="headerlink" title="12.3通过反射获取属性（Field）"></a>12.3通过反射获取属性（Field）</h2><p>我们给定一个类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.bean;public class Student &#123;    public int no;    private String name;    protected int age;    boolean sex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取以上的Field：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class studentClass &#x3D; Class.forName(&quot;javase.bean.Student&quot;);&#x2F;&#x2F; 获取类中所有的public修饰的FieldField[] fields &#x3D; studentClass.getFields();&#x2F;&#x2F; 获取所有的FieldField[] fs &#x3D; studentClass.getDeclaredFields();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取修饰符：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int i &#x3D; fs[1].getModifiers();&#x2F;&#x2F; 返回的修饰符是一个数字，每个数字是修饰符的代号&#x2F;&#x2F; 将数字转换成字符串。String modifiersString &#x3D; Modifier.toString(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>获取属性类型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class fieldType &#x3D; fs[1].getType();String fieldName &#x3D; fieldType.getSimpleName();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取属性名字:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(field.getName());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下完整的将Student的class文件反编译出来：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class ReflectTest06 &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        &#x2F;&#x2F; 创建这个是为了拼接字符串。        StringBuilder s &#x3D; new StringBuilder();        Class studentClass &#x3D; Class.forName(&quot;javase.bean.Student&quot;);        s.append(Modifier.toString(studentClass.getModifiers()) + &quot;class&quot; + studentClass.getSimpleName() + &quot;&#123;\n&quot;);        Field[] fields &#x3D; studentClass.getDeclaredFields();        for (Field field : fields)&#123;            s.append(&quot;\t&quot;);            s.append(Modifier.toString(field.getModifiers()));            s.append(&quot; &quot;);            s.append(field.getType().getSimpleName());            s.append(&quot; &quot;);            s.append(field.getName());            s.append(&quot;;\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过反射机制给属性赋值</strong></p><p>我们不使用反射机制，去访问一个对象的属性（还是用上面的Students类）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Student s &#x3D; new Student();&#x2F;&#x2F;给属性赋值s.no &#x3D; 111; &#x2F;&#x2F; 三要素:给s对象的no属性赋值1111&#x2F;&#x2F;要素1:对象s&#x2F;&#x2F;要素2:no属性&#x2F;&#x2F;要素3:1111&#x2F;&#x2F; 读属性值&#x2F;&#x2F; 获取要素:获取s对象的no属性的值System.out.println(s.no);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用反射机制，去访问一个对象的属性（set  get）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class studentClass &#x3D; Class.forName(&quot;javase.bean.Student&quot;);Object obj &#x3D; studentClass.newInstance();&#x2F;&#x2F; obj就是Student对象（底层调用无参数构造方法）&#x2F;&#x2F; 获取no属性（根据属性的名称来获取Field）Field noFiled &#x3D; studentClass.getDeclaredField(&quot;no&quot;);&#x2F;&#x2F; 给obj对象（Student对象）的no属性赋值&#x2F;*        虽然使用了反射机制，但是三要素还是缺一不可:            要素1: obj对象            要素2: no属性            要素3: 2222值        注意: 反射机制让代码复杂了，但是为了一个”灵活“，这也是值得的。         *&#x2F;noFiled.set(obj,2222); &#x2F;&#x2F; 给obj对象的no属性赋值2222&#x2F;&#x2F; 读取属性的值&#x2F;&#x2F; 两个要素: 获取obj对象的no属性的值。Object a  &#x3D; noFiled.get(obj);System.out.println(a);&#x2F;&#x2F; 可以访问私有的属性吗？Field nameFiled &#x3D; studentClass.getDeclaredField(&quot;name&quot;);&#x2F;&#x2F; 打破封装(反射机制的缺点: 打破封装，可能会给不法分子留下机会的！)&#x2F;&#x2F; 这样设置完之后，在外部也是可以访问private的。nameFiled.setAccessible(true);&#x2F;&#x2F; 给name属性赋值nameFiled.set(obj,&quot;jackson&quot;);&#x2F;&#x2F; 获取name属性的值System.out.println(nameFiled.get(obj));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-4-可变长度参数"><a href="#12-4-可变长度参数" class="headerlink" title="12.4 可变长度参数"></a>12.4 可变长度参数</h2><p>int…args 就是可变长度参数</p><p>语法是：类型…(3个点)</p><ol><li>可变长度参数要求的参数的0~N个。</li><li>可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有一个。</li><li>可变长度参数可以当作一个数组类看待。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArgsTest &#123;    public static void main(String[] args) &#123;        m();        m(10);        m(10, 20);        &#x2F;&#x2F; 编译报错        &#x2F;&#x2F;m(&quot;abc&quot;);        m2(100);        m2(200,&quot;abc&quot;);        m2(200,&quot;abc&quot;,&quot;def&quot;);        m2(200,&quot;abc&quot;,&quot;def&quot;,&quot;xyz&quot;);        m3(&quot;ab&quot;,&quot;de&quot;,&quot;kk&quot;,&quot;ff&quot;);        String[] strs &#x3D; &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;        &#x2F;&#x2F; 也可以传一个数组,不能传多个数组        m3(strs);            &#125;    public static void m(int... args)&#123;        System.out.println(&quot;m方法执行了！&quot;);    &#125;    &#x2F;&#x2F;public static void m2(String...args1, int...args2)&#123;&#125;    public static void m2(int a, String... args1)&#123;        System.out.println(&quot;m2执行了！&quot;);    &#125;    public static void m3(String... args)&#123;        &#x2F;&#x2F; args有length属性，说明args是一个数组！        &#x2F;&#x2F; 可以将可变长度参数当做一个数组来看。        for (int i &#x3D; 0; i &lt; args.length; i++) &#123;            System.out.println(args[i]);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-5通过反射获取方法-Method"><a href="#12-5通过反射获取方法-Method" class="headerlink" title="12.5通过反射获取方法(Method)"></a>12.5通过反射获取方法(Method)</h2><p>一个用户业务类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.service;&#x2F;** *  *&#x2F;public class UserService &#123;    &#x2F;**     * 登录方法     * @param name     * @param password     * @return true表示登录成功，false表示登录失败！     *&#x2F;    public boolean login(String name,String password)&#123;        if (&quot;admin&quot;.equals(name) &amp;&amp; &quot;123&quot;.equals(password))&#123;            return true;        &#125;        return false;    &#125;    &#x2F;**     * 退出系统的方法     *&#x2F;    public void logout()&#123;        System.out.println(&quot;系统已经安全退出！&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射反射Method（方法）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.reflect;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class ReflectTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 获取类了        Class userServiceClass &#x3D; null;        try &#123;            userServiceClass &#x3D; Class.forName(&quot;javase.service.UserService&quot;);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 获取所有的Method(包括私有的！)        Method[] methods &#x3D; userServiceClass.getDeclaredMethods();        &#x2F;&#x2F;System.out.println(methods.length); &#x2F;&#x2F; 2        &#x2F;&#x2F; 遍历Method        for (Method method :methods)&#123;            &#x2F;&#x2F; 获取修饰符列表            System.out.println(Modifier.toString(method.getModifiers()));            &#x2F;&#x2F; 获取方法的返回值类型            System.out.println(method.getReturnType().getSimpleName());            &#x2F;&#x2F; 获取方法名            System.out.println(method.getName());            &#x2F;&#x2F; 方法的修饰符列表（一个方法的参数可能会有多个。）            Class[] parameterTypes &#x3D; method.getParameterTypes();            for (Class parameterType : parameterTypes)&#123;                System.out.println(parameterType.getSimpleName());            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反编译以上业务类方法（了解）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.reflect;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class ReflectTest09 &#123;    public static void main(String[] args) throws Exception&#123;        StringBuilder s &#x3D; new StringBuilder();        Class userServiceClass &#x3D; Class.forName(&quot;javase.service.UserService&quot;);        s.append(Modifier.toString(userServiceClass.getModifiers()) +&quot;class&quot;+userServiceClass.getSimpleName()+&quot;&#123;\n&quot;);        Method[] methods &#x3D; userServiceClass.getDeclaredMethods();        for (Method method : methods)&#123;            s.append(&quot;\t&quot;);            s.append(Modifier.toString(method.getModifiers()));            s.append(&quot; &quot;);            s.append(method.getReturnType().getSimpleName());            s.append(&quot; &quot;);            s.append(method.getName());            s.append(&quot;(&quot;);            &#x2F;&#x2F; 参数列表            Class[] parameterTypes &#x3D; method.getParameterTypes();            for (Class parameterType: parameterTypes)&#123;                s.append(parameterType.getSimpleName());                s.append(&quot;,&quot;);            &#125;            s.append(&quot;)&#123;&#125;\n&quot;);        &#125;        &#x2F;&#x2F; 删除指定下标的字符        s.deleteCharAt(s.length() - 1);        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射机制调用一个对象的方法(重点)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.reflect;import javase.bean.User;import javase.service.UserService;import java.lang.reflect.Field;import java.lang.reflect.Method;&#x2F;*重点:必须掌握，通过反射机制调用一个对象的方法 *&#x2F;public class ReflectTest &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 不使用反射机制调用方法。        &#x2F;&#x2F; 创建对象        UserService userService &#x3D; new UserService();        &#x2F;&#x2F; 调用方法        &#x2F;*        要素分析:            要素1: 对象userService            要素2: login方法名            要素3: 实参列表            要素4: 返回值         *&#x2F;        boolean loginSuccess &#x3D; userService.login(&quot;admin&quot;,&quot;123&quot;);        System.out.println(loginSuccess ? &quot;登录成功&quot; : &quot;登录失败&quot;);        &#x2F;&#x2F; 使用反射机制来调用一个对象的方法        Class userServiceClass &#x3D; Class.forName(&quot;javase.service.UserService&quot;);        &#x2F;&#x2F; 创建对象        Object obj &#x3D; userServiceClass.newInstance();        &#x2F;&#x2F; 获取Method        Method loginMethod &#x3D; userServiceClass.getDeclaredMethod(&quot;login&quot;, String.class, String.class);        &#x2F;&#x2F; 调用方法        &#x2F;&#x2F; 调用方法也需要4要素        &#x2F;&#x2F; 反射机制中最重要的一个方法，必须记住。        &#x2F;&#x2F; 四要素:        &#x2F;*        loginMethod方法        obj对象        &quot;admin&quot;,&quot;123&quot; 实参        retValue 返回值         *&#x2F;        Object retValue &#x3D; loginMethod.invoke(obj,&quot;admin&quot;,&quot;123&quot;);        System.out.println(retValue);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-6-通过反编译获取构造方法-Constructor"><a href="#12-6-通过反编译获取构造方法-Constructor" class="headerlink" title="12.6 通过反编译获取构造方法(Constructor)"></a>12.6 通过反编译获取构造方法(Constructor)</h2><p>创建测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.bean;public class Vip &#123;    int no;    String name;    String birth;    boolean sex;    public Vip()&#123;    &#125;    public void setNo(int no) &#123;        this.no &#x3D; no;    &#125;    public Vip(int no, String name) &#123;        this.no &#x3D; no;        this.name &#x3D; name;    &#125;    public Vip(int no, String name, String birth) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.birth &#x3D; birth;    &#125;    public Vip(int no, String name, String birth, boolean sex) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.birth &#x3D; birth;        this.sex &#x3D; sex;    &#125;    @Override    public String toString() &#123;        return &quot;Vip&#123;&quot; +                &quot;no&#x3D;&quot; + no +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, birth&#x3D;&#39;&quot; + birth + &#39;\&#39;&#39; +                &quot;, sex&#x3D;&quot; + sex +                &#39;&#125;&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反编译这个类的构造方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javase.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;public class ReflectTest &#123;    public static void main(String[] args) throws Exception&#123;        StringBuilder s &#x3D; new StringBuilder();        Class vipClass &#x3D; Class.forName(&quot;javase.bean.Vip&quot;);        s.append(Modifier.toString(vipClass.getModifiers()));        s.append(&quot; &quot;);        s.append(&quot; class &quot;);        s.append(vipClass.getSimpleName());        s.append(&quot;&#123;\n&quot;);        &#x2F;&#x2F; 拼接构造方法        Constructor[] constructors &#x3D; vipClass.getDeclaredConstructors();        for (Constructor constructor : constructors)&#123;            s.append(&quot;\t&quot;);            s.append(Modifier.toString(constructor.getModifiers()));            s.append(&quot; &quot;);            s.append(vipClass.getSimpleName());            s.append(&quot;(&quot;);            &#x2F;&#x2F; 拼接参数            Class[] parameterTypes &#x3D; constructor.getParameterTypes();            for (Class parameterType : parameterTypes)&#123;                s.append(parameterType.getSimpleName());                s.append(&quot;,&quot;);            &#125;            &#x2F;&#x2F; 删除最后下标位置上的字符            if (parameterTypes.length &gt; 0) &#123;                s.deleteCharAt(s.length() - 1);            &#125;            s.append(&quot;)&#123;&#125;\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射机制调用构造方法实例化对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReflectTest &#123;    public static void main(String[] args)&#123;        Class c &#x3D; null;        try &#123;            c &#x3D; Class.forName(&quot;javase.bean.Vip&quot;);            &#x2F;&#x2F; 调用无参数构造方法            Ojbect obj &#x3D; c.newInstance();            System.out.println(obj);            &#x2F;&#x2F; 获取参数的构造方法            Constructor con &#x3D; c.getDeclaredConstructor(int.class,String.class,String.class, boolean.class);            &#x2F;&#x2F; 调用构造方法new对象            Object newObj &#x3D; con.newInstance(123,&quot;jack&quot;,&quot;1999-11-11&quot;,true);            System.out.prinitn(newObj);                        &#x2F;&#x2F; 获取无参数构造方法            Constructor con2 &#x3D; c.getDeclaredConstructor();            Object newObj2 &#x3D; con2.newInstance();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-7-通过反射机制获取父类"><a href="#12-7-通过反射机制获取父类" class="headerlink" title="12.7 通过反射机制获取父类"></a>12.7 通过反射机制获取父类</h2><p>给你一个类，获取这个类的父亲，已经实现了那些接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReflectTest &#123;    public static void main(String[] args) &#123;        Class stringClass &#x3D; null;        try &#123;            stringClass &#x3D; Class.forName(&quot;java.lang.String&quot;);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 获取String的父类        Class superClass &#x3D; stringClass.getSuperclass();        &#x2F;&#x2F; 获取String类实现的所有接口        Class[] interfaces &#x3D; stringClass.getInterfaces();        for (Class in : interfaces)&#123;            System.out.println(in.getName());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第13章-注解"><a href="#第13章-注解" class="headerlink" title="第13章 注解"></a>第13章 注解</h1><p> 注解（Annotation）又称标注，是 JDK5.0 引入的一种注释机制。</p><p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><h2 id="13-1-基本语法"><a href="#13-1-基本语法" class="headerlink" title="13.1 基本语法"></a>13.1 基本语法</h2><p>注解类型的声明部分：</p><p>注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同<code>@interface</code>。在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public @interface AnnotationTest &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注解类型的实现部分：</p><p>根据我们在自定义类的经验，在类的实现部分无非就是书写构造、属性或方法。但是，在自定义注解中，实现部分只能定义一个东西：注解类型元素。语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public @interface AnnotationTest &#123;    public String name();    int age();    int[] array();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也许你会认为这不就是接口中定义抽象方法的语法嘛？别着急，咱们看看下面这个：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public @interface CherryAnnotation &#123;public String name();int age() default 18;int[] array();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到关键字<code>default</code>了吗？还觉得是抽象方法吗？</p><p>注解里面定义的是：<strong>注解类型元素！</strong></p><p>定义注解类型时需要注意以下几点：</p><ol><li>访问修饰符必须为public ,不写默认为public ;</li><li>该元素的类型只能时基本数据类型、String、Class、枚举类型、注解类型（体系了注解的嵌套）以及上述类型的一维数组；</li><li>该元素的名称一般定义为名词，如果注解中只有一个元素，请把名字起为value（后面使用会带来便利操作）；</li><li>()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法；</li><li><code>default</code>代表默认值，值必须和第2点定义的类型一致；</li><li>如果没有默认值，代码后续使用注解时必须给该类型元素赋值。</li></ol><h2 id="13-2-常用元注解"><a href="#13-2-常用元注解" class="headerlink" title="13.2 常用元注解"></a>13.2 常用元注解</h2><p>一个最基本的注解定义就只包括了上面的两部分：</p><ol><li>注解的名字；</li><li>注解包含的类型元素</li></ol><p>但是，我们使用的JDK自带注解的时候发现，有些注解只能卸载方法上面（比如@Override）;有些注解却可以写在类上面（比如@Deprecated）。当然除此之外还有很多细节性的定义。</p><blockquote><p>@Target</p></blockquote><p>@Target注解，是专门用来限定某个自定义注解能够被应用在哪些Java元素上面的。它使用一个枚举类型定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum ElementType &#123;    &#x2F;** 类，接口（包括注解类型）或枚举的声明 *&#x2F;    TYPE,    &#x2F;** 属性的声明 *&#x2F;    FIELD,    &#x2F;** 方法的声明 *&#x2F;    METHOD,    &#x2F;** 方法形式参数声明 *&#x2F;    PARAMETER,    &#x2F;** 构造方法的声明 *&#x2F;    CONSTRUCTOR,    &#x2F;** 局部变量声明 *&#x2F;    LOCAL_VARIABLE,    &#x2F;** 注解类型声明 *&#x2F;    ANNOTATION_TYPE,    &#x2F;** 包的声明 *&#x2F;    PACKAGE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;@CherryAnnotation被限定只能使用在类、接口或方法上面@Target(value &#x3D; &#123;ElementType.TYPE,ElementType.METHOD&#125;)&#x2F;&#x2F; value可以省略public @interface CherryAnnotation &#123;    String name();    int age() default 18;    int[] array();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>@Retention</p></blockquote><p>@Retention 注解，翻译为持久力、保持力。即用来修饰自定义注解的生命力。</p><p>注解的生命周期有三个阶段：</p><ol><li>Java源文件阶段；</li><li>编译到class文件阶段；</li><li>运行期阶段。</li></ol><p>同样使用RetentionPolicy枚举类型定义了三个阶段</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum RetentionPolicy &#123;    &#x2F;**     * Annotations are to be discarded by the compiler.     * （注解将被编译器忽略掉）     *&#x2F;    SOURCE,    &#x2F;**     * Annotations are to be recorded in the class file by the compiler     * but need not be retained by the VM at run time.  This is the default     * behavior.     * （注解将被编译器记录在class文件中，但在运行时不会被虚拟机保留，这是一个默认的行为）     *&#x2F;    CLASS,    &#x2F;**     * Annotations are to be recorded in the class file by the compiler and     * retained by the VM at run time, so they may be read reflectively.     * （注解将被编译器记录在class文件中，而且在运行时会被虚拟机保留，因此它们能通过反射被读取到）     * @see java.lang.reflect.AnnotatedElement     *&#x2F;    RUNTIME&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再详解解释一下：</p><ol><li>如果一个注解被定义为RetentionPolicy.SOURCE，则它将被限定在Java源文件中，那么这个注解即不会参与编译也不会在运行期起任何作用，这个注解就和一个注释是一样的效果，只能被阅读Java文件的人看到；</li><li>如果一个注解被定义为RetentionPolicy.CLASS，则它将被编译到Class文件中，那么编译器可以在编译时根据注解做一些处理动作，但是运行时JVM（Java虚拟机）会忽略它，我们在运行期也不能读取到；</li><li>如果一个注解被定义为RetentionPolicy.RUNTIME，那么这个注解可以在运行期的加载阶段被加载到Class对象中。那么在程序运行阶段，我们可以通过反射得到这个注解，并通过判断是否有这个注解或这个注解中属性的值，从而执行不同的程序代码段。<strong>我们实际开发中的自定义注解几乎都是使用的RetentionPolicy.RUNTIME</strong>；</li><li>在默认的情况下，自定义注解是使用的RetentionPolicy.CLASS。</li></ol><blockquote><p>@Docnmented</p></blockquote><p>@Docunmented 注解，是被用来指定自定义注解时候能随着被定义的java文件生成到JavaDoc文档当中。</p><blockquote><p>@Inherited</p></blockquote><p>@Inherited 注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。</p><h2 id="13-3-自定义注解的配置使用"><a href="#13-3-自定义注解的配置使用" class="headerlink" title="13.3 自定义注解的配置使用"></a>13.3 自定义注解的配置使用</h2><p>回顾一下注解的使用流程：</p><ul><li><strong>第一步，定义注解——相当于定义标记；</strong></li><li><strong>第二步，配置注解——把标记打在需要用到的程序代码中；</strong></li><li><strong>第三步，解析注解——在编译期或运行时检测到标记，并进行特殊操作。</strong></li></ul><p>到目前为止我们只是完成了第一步，接下来我们就来学习第二步，配置注解，如何在另一个类当中配置它。</p><blockquote><p>在具体的Java类上使用注解</p></blockquote><p>首先，定义一个注解、和一个供注解修饰的简单Java类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Retention(RetentionPolicy.RUNTIME)@Target(value &#x3D; &#123;ElementType.METHOD&#125;)@Documentedpublic @interface CherryAnnotation &#123;    String name();    int age() default 18;    int[] score();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student&#123;    public void study(int times)&#123;        for(int i &#x3D; 0; i &lt; times; i++)&#123;            System.out.println(&quot;Good Good Study, Day Day Up!&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单分析下：</p><ol><li>CherryAnnotation的@Target定义为ElementType.METHOD，那么它书写的位置应该在方法定义的上方，即：public void study(int times)之上；</li><li>由于我们在CherryAnnotation中定义的有注解类型元素，而且有些元素是没有默认值的，这要求我们在使用的时候必须在标记名后面打上()，并且在()内以“元素名&#x3D;元素值“的形式挨个填上所有没有默认值的注解类型元素（有默认值的也可以填上重新赋值），中间用“,”号分割</li></ol><p>所以最终书写形式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;    @CherryAnnotation(name &#x3D; &quot;cherry-peng&quot;,age &#x3D; 23,score &#x3D; &#123;99,66,77&#125;)    public void study(int times)&#123;        for(int i &#x3D; 0; i &lt; times; i++)&#123;            System.out.println(&quot;Good Good Study, Day Day Up!&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>特殊语法</p></blockquote><p>特殊语法一：</p><p>如果注解本身没有注解类型元素，那么在使用注解的时候可以省略，直接写为：@注解名，它和标准语法@注解名()等效</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Retention(RetentionPolicy.RUNTIME)@Target(value &#x3D; &#123;ElementType.TYPE&#125;)@Documentedpublic @interface FirstAnnotation &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;等效于@FirstAnnotation()@FirstAnnotationpublic class JavaBean&#123;&#x2F;&#x2F;省略实现部分&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特殊语法二：</p><p><strong>如果注解本本身只有一个注解类型元素，而且命名为value，那么在使用注解的时候可以直接使用：@注解名(注解值)，其等效于：@注解名(value &#x3D; 注解值)</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Retention(RetentionPolicy.RUNTIME)@Target(value &#x3D; &#123;ElementType.TYPE&#125;)@Documentedpublic @interface SecondAnnotation &#123;String value();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;等效于@ SecondAnnotation(value &#x3D; &quot;this is second annotation&quot;)@SecondAnnotation(&quot;this is annotation&quot;)public class JavaBean&#123;&#x2F;&#x2F;省略实现部分&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特殊用法三：</p><p><strong>如果注解中的某个注解类型元素是一个数组类型，在使用时又出现只需要填入一个值的情况，那么在使用注解时可以直接写为：@注解名(类型名 &#x3D; 类型值)，它和标准写法：@注解名(类型名 &#x3D; {类型值})等效！</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Retention(RetentionPolicy.RUNTIME)@Target(value &#x3D; &#123;ElementType.TYPE&#125;)@Documentedpublic @interface ThirdAnnotation &#123;String[] name();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;等效于@ ThirdAnnotation(name &#x3D; &#123;&quot;this is third annotation&quot;&#125;)@ ThirdAnnotation(name &#x3D; &quot;this is third annotation&quot;)public class JavaBean&#123;&#x2F;&#x2F;省略实现部分&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特殊用法四：</p><p><strong>如果一个注解的@Target是定义为Element.PACKAGE，那么这个注解是配置在package-info.java中的，而不能直接在某个类的package代码上面配置。</strong></p><h2 id="13-4-反射注解"><a href="#13-4-反射注解" class="headerlink" title="13.4 反射注解"></a>13.4 反射注解</h2><p>这一章是使用注解的核心，读完此章即可明白，如何<strong>在程序运行时检测到注解，并进行一系列特殊操作</strong>！</p><blockquote><p>反射操作获取注解</p></blockquote><p>因此，明确我们的目标：<strong>在运行期探究和使用编译期的内容（编译期配置的注解），要用到Java中的灵魂技术——反射！</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestAnnotation &#123;    public static void main(String[] args)&#123;        try &#123;            &#x2F;&#x2F;获取Student的Class对象            Class stuClass &#x3D; Class.forName(&quot;pojos.Student&quot;);            &#x2F;&#x2F;说明一下，这里形参不能写成Integer.class，应写为int.class            Method stuMethod &#x3D; stuClass.getMethod(&quot;study&quot;,int.class);            if(stuMethod.isAnnotationPresent(CherryAnnotation.class))&#123;                System.out.println(&quot;Student类上配置了CherryAnnotation注解！&quot;);                &#x2F;&#x2F;获取该元素上指定类型的注解                CherryAnnotation cherryAnnotation &#x3D; stuMethod.getAnnotation(CherryAnnotation.class);                System.out.println(&quot;name: &quot; + cherryAnnotation.name() + &quot;, age: &quot; + cherryAnnotation.age()                    + &quot;, score: &quot; + cherryAnnotation.score()[0]);            &#125;else&#123;                System.out.println(&quot;Student类上没有配置CherryAnnotation注解！&quot;);            &#125;        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释一下：</p><ol><li>如果我们要获得的注解时配置在方法上的，那么我们要从Method对象上获取；如果时配置在属性上，就需要从该属性对应的Field对象上去获取，如果是配置在类型上，就需要从Class对象上去获取。总之在谁身上，就从谁身上获取！</li><li><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>方法是专门判断该元素上是否配置有某个指定的注解；</li><li><code>getAnnotation(Class&lt;A&gt; annotationClass)</code>方法是获取该元素上指定的注解。之后再调用该注解的注解类型元素方法就可以获得配置时的值数据；</li><li>反射对象上还有一个方法<code>getAnnotations()</code>，该方法可以获得该对象身上配置的所有的注解。它会返回我们一个注解数组，需要注意的是该数组的类型是Annotation类型，这个Annotation是一个来自于java.lang.annotation包的接口。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
