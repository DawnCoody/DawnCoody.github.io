<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JDK新特性上, dawncoody">
    <meta name="description" content="[toc]
第18章_JDK8-17新特性（上）
本章专题与脉络

1. Java版本迭代概述1.1 发布特点（小步快跑，快速迭代）


发行版本
发行时间
备注



Java 1.0
1996.01.23
Sun公司发布了Java的第一">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JDK新特性上 | dawncoody</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">dawncoody</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">dawncoody</div>
        <div class="logo-desc">
            
            寂寞的人总是记住生命中出现的每一个人，正如我总是意犹未尽地想起你！
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JDK新特性上</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-13
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[toc]</p>
<h1 id="第18章-JDK8-17新特性（上）"><a href="#第18章-JDK8-17新特性（上）" class="headerlink" title="第18章_JDK8-17新特性（上）"></a>第18章_JDK8-17新特性（上）</h1><hr>
<h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/../images/%E7%AC%AC3%E9%98%B6%E6%AE%B5%EF%BC%9AJava%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8-%E7%AC%AC18%E7%AB%A0.png" alt="第3阶段：Java高级应用-第18章"></p>
<hr>
<h2 id="1-Java版本迭代概述"><a href="#1-Java版本迭代概述" class="headerlink" title="1. Java版本迭代概述"></a>1. Java版本迭代概述</h2><h3 id="1-1-发布特点（小步快跑，快速迭代）"><a href="#1-1-发布特点（小步快跑，快速迭代）" class="headerlink" title="1.1 发布特点（小步快跑，快速迭代）"></a>1.1 发布特点（小步快跑，快速迭代）</h3><table>
<thead>
<tr>
<th align="center">发行版本</th>
<th align="center">发行时间</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Java 1.0</td>
<td align="center">1996.01.23</td>
<td align="center">Sun公司发布了Java的第一个开发工具包</td>
</tr>
<tr>
<td align="center">Java 5.0</td>
<td align="center">2004.09.30</td>
<td align="center">①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME</td>
</tr>
<tr>
<td align="center">Java 8.0</td>
<td align="center">2014.03.18</td>
<td align="center">此版本是继Java 5.0以来变化最大的版本。是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">Java 9.0</td>
<td align="center">2017.09.22</td>
<td align="center"><strong>此版本开始，每半年更新一次</strong></td>
</tr>
<tr>
<td align="center">Java 10.0</td>
<td align="center">2018.03.21</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java 11.0</td>
<td align="center">2018.09.25</td>
<td align="center">JDK安装包取消独立JRE安装包，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">Java 12.0</td>
<td align="center">2019.03.19</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java17.0</td>
<td align="center">2021.09</td>
<td align="center">发布Java 17.0，版本号也称为21.9，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Java19.0</td>
<td align="center">2022.09</td>
<td align="center">发布Java19.0，版本号也称为22.9。</td>
</tr>
</tbody></table>
<p>从Java 9 这个版本开始，Java 的计划发布周期是 <code>6个月</code>。</p>
<p>这意味着Java的更新从传统的以<code>特性驱动</code>的发布周期，转变为以<code>时间驱动</code>的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。</p>
<p>针对企业客户的需求，Oracle 将以<code>三年</code>为周期发布长期支持版本（long term support）。</p>
<p>Oracle 的官方观点认为：<strong>与 Java 7-&gt;8-&gt;9 相比，Java 9-&gt;10-&gt;11的升级和 8-&gt;8u20-&gt;8u40 更相似。</strong></p>
<p>新模式下的 Java 版本发布都会包含许多变更，包括<code>语言变更</code>和 <code>JVM 变更</code>，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 <code>API被删除</code>（这在 Java 8 之前没有发生过）。</p>
<p>目前看这种发布策略是非常成功的，<strong>解开了 Java&#x2F;JVM 演进的许多枷锁，至关重要的是，OpenJDK 的权力中心，正在转移到开发社区和开发者手中。</strong>在新的模式中，既可以利用 LTS 满足企业长期可靠支持的需求，也可以满足各种开发者对于新特性迭代的诉求。因为用 2-3 年的最小间隔粒度来试验一个特性，基本是不现实的。</p>
<h3 id="1-2-名词解释"><a href="#1-2-名词解释" class="headerlink" title="1.2 名词解释"></a>1.2 名词解释</h3><h4 id="名词解释：Oracle-JDK和Open-JDK"><a href="#名词解释：Oracle-JDK和Open-JDK" class="headerlink" title="名词解释：Oracle JDK和Open JDK"></a>名词解释：Oracle JDK和Open JDK</h4><p>这两个JDK最大不同就是许可证不一样。<strong>但是对于个人用户来讲，没区别。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Oracle JDK</th>
<th>Open JDK</th>
</tr>
</thead>
<tbody><tr>
<td>来源</td>
<td>Oracle团队维护</td>
<td>Oracle和Open Java社区</td>
</tr>
<tr>
<td>授权协议</td>
<td>Java 17及更高版本 Oracle Java SE 许可证<br>Java16及更低版本甲骨文免费条款和条件 （NFTC） 许可协议</td>
<td>GPL v2许可证</td>
</tr>
<tr>
<td>关系</td>
<td>由Open JDK构建，增加了少许内容</td>
<td></td>
</tr>
<tr>
<td>是否收费</td>
<td>2021年9月起Java17及更高版本所有用户免费。 16及更低版本，个人用户、开发用户免费。</td>
<td>2017年9月起，所有版本免费</td>
</tr>
<tr>
<td>对语法的支持</td>
<td>一致</td>
<td>一致</td>
</tr>
</tbody></table>
<h4 id="名词解释：JEP"><a href="#名词解释：JEP" class="headerlink" title="名词解释：JEP"></a>名词解释：JEP</h4><p>JEP(JDK Enhancement Proposals)：jdk 改进提案，每当需要有新的设想时候，JEP可以提出非正式的规范(specification)，被正式认可的JEP正式写进JDK的发展路线图并分配版本号。</p>
<h4 id="名词解释：LTS"><a href="#名词解释：LTS" class="headerlink" title="名词解释：LTS"></a>名词解释：LTS</h4><p>LTS（Long-term Support）即长期支持。Oracle官网提供了对Oracle JDK个别版本的长期支持，即使发发行了新版本，比如目前最新的JDK19，在结束日期前，LTS版本都会被长期支持。（出了bug，会被修复，非LTS则不会再有补丁发布）所以，一定要选一个LTS版本，不然出了漏洞没人修复了。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>开始日期</th>
<th>结束日期</th>
<th>延期结束日期</th>
</tr>
</thead>
<tbody><tr>
<td>7（LTS）</td>
<td>2011年7月</td>
<td>2019年7月</td>
<td>2022年7月</td>
</tr>
<tr>
<td>8（LTS）</td>
<td>2014年3月</td>
<td>2022年3月</td>
<td>2030年12月</td>
</tr>
<tr>
<td>11（LTS）</td>
<td>2018年9月</td>
<td>2023年9月</td>
<td>2026年9月</td>
</tr>
<tr>
<td>17（LTS）</td>
<td>2021年9月</td>
<td>2026年9月</td>
<td>2029年9月</td>
</tr>
<tr>
<td>21（LTS）</td>
<td>2023年9月</td>
<td>2028年9月</td>
<td>2031年9月</td>
</tr>
</tbody></table>
<p>如果要选择Oracle JDK，目前可选的LTS版本为8、11、17三个。</p>
<h3 id="1-3-各版本支持时间路线图"><a href="#1-3-各版本支持时间路线图" class="headerlink" title="1.3 各版本支持时间路线图"></a>1.3 各版本支持时间路线图</h3><p><img src="/../images/4428b288361296048.png" alt="4428b288361296048"></p>
<h3 id="1-4-各版本介绍"><a href="#1-4-各版本介绍" class="headerlink" title="1.4 各版本介绍"></a>1.4 各版本介绍</h3><p><img src="/../images/jdkxintexing.jpg" alt="jdkxintexing"></p>
<h4 id="jdk-9"><a href="#jdk-9" class="headerlink" title="jdk 9"></a>jdk 9</h4><p>Java 9 提供了<code>超过150项</code>新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。</p>
<p>特性太多，查看链接：</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk9/">https://openjdk.java.net/projects/jdk9/</a></p>
<h4 id="jdk-10"><a href="#jdk-10" class="headerlink" title="jdk 10"></a>jdk 10</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/10/">https://openjdk.java.net/projects/jdk/10/</a></p>
<blockquote>
<p>286: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/286">Local-Variable Type Inference</a> 局部变量类型推断<br> 296: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/296">Consolidate the JDK Forest into a Single Repository</a> JDK库的合并<br> 304: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/304">Garbage-Collector Interface</a> 统一的垃圾回收接口<br> 307: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/307">Parallel Full GC for G1</a> 为G1提供并行的Full GC<br> 310: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/310">Application Class-Data Sharing</a> 应用程序类数据（AppCDS）共享<br> 312: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/312">Thread-Local Handshakes</a> ThreadLocal握手交互<br> 313: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/313">Remove the Native-Header Generation Tool (javah)</a> 移除JDK中附带的javah工具<br> 314: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/314">Additional Unicode Language-Tag Extensions</a> 使用附加的Unicode语言标记扩展<br> 316: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/316">Heap Allocation on Alternative Memory Devices</a> 能将堆内存占用分配给用户指定的备用内存设备<br> 317: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/317">Experimental Java-Based JIT Compiler</a> 使用Graal基于Java的编译器</p>
<p>319: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/319">Root Certificates</a> 根证书<br> 322: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/322">Time-Based Release Versioning</a> 基于时间定于的发布版本</p>
</blockquote>
<h4 id="jdk-11"><a href="#jdk-11" class="headerlink" title="jdk 11"></a>jdk 11</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/11/">https://openjdk.java.net/projects/jdk/11/</a></p>
<blockquote>
<p>181: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/181">Nest-Based Access Control</a>  基于嵌套的访问控制<br>309: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/309">Dynamic Class-File Constants</a> 动态类文件常量<br>315: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/315">Improve Aarch64 Intrinsics</a> 改进 Aarch64 Intrinsics<br>318: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/318">Epsilon: A No-Op Garbage Collector</a> Epsilon — 一个No-Op（无操作）的垃圾收集器<br>320: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/320">Remove the Java EE and CORBA Modules</a> 删除 Java EE 和 CORBA 模块<br>321: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/321">HTTP Client (Standard)</a>  HTTPClient API<br>323: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/323">Local-Variable Syntax for Lambda Parameters</a>  用于 Lambda 参数的局部变量语法<br>324: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/324">Key Agreement with Curve25519 and Curve448</a> Curve25519 和 Curve448 算法的密钥协议<br>327: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/327">Unicode 10</a><br>328: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/328">Flight Recorder</a> 飞行记录仪<br>329: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/329">ChaCha20 and Poly1305 Cryptographic Algorithms</a> ChaCha20 和 Poly1305 加密算法<br>330: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/330">Launch Single-File Source-Code Programs</a> 启动单一文件的源代码程序<br>331: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/331">Low-Overhead Heap Profiling</a> 低开销的 Heap Profiling<br>332: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/332">Transport Layer Security (TLS) 1.3</a> 支持 TLS 1.3<br>333: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/333">ZGC: A Scalable Low-Latency Garbage Collector<br>   (Experimental)</a> 可伸缩低延迟垃圾收集器<br>335: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/335">Deprecate the Nashorn JavaScript Engine</a> 弃用 Nashorn JavaScript 引擎<br>336: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/336">Deprecate the Pack200 Tools and API</a>  弃用 Pack200 工具和 API</p>
</blockquote>
<h4 id="jdk-12"><a href="#jdk-12" class="headerlink" title="jdk 12"></a>jdk 12</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/12/">https://openjdk.java.net/projects/jdk/12/</a></p>
<blockquote>
<p>189：<a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a> 低暂停时间的GC<br>230: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/230">Microbenchmark Suite</a> 微基准测试套件<br>325: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/325">Switch Expressions (Preview)</a> switch表达式<br>334: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/334">JVM Constants API </a> JVM常量API<br>340: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/340">One AArch64 Port, Not Two</a> 只保留一个AArch64实现<br>341: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/341">Default CDS Archives</a> 默认类数据共享归档文件<br>344: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/344">Abortable Mixed Collections for G1</a> 可中止的G1 Mixed GC<br>346: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/346">Promptly Return Unused Committed Memory from G1</a> G1及时返回未使用的已分配内存</p>
</blockquote>
<h4 id="jdk-13"><a href="#jdk-13" class="headerlink" title="jdk 13"></a>jdk 13</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/13/">https://openjdk.java.net/projects/jdk/13/</a></p>
<blockquote>
<p>350: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/350">Dynamic CDS Archives</a> 动态CDS档案<br>351: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/351">ZGC: Uncommit Unused Memory</a> ZGC:取消使用未使用的内存<br>353: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/353">Reimplement the Legacy Socket API</a> 重新实现旧版套接字API<br>354: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/354">Switch Expressions (Preview)</a> switch表达式（预览）<br>355: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/355">Text Blocks (Preview)</a> 文本块（预览）</p>
</blockquote>
<h4 id="jdk-14"><a href="#jdk-14" class="headerlink" title="jdk 14"></a>jdk 14</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/14/">https://openjdk.java.net/projects/jdk/14/</a></p>
<blockquote>
<p>305: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/305">Pattern Matching for instanceof (Preview)</a> instanceof的模式匹配<br>343: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/343">Packaging Tool (Incubator)</a> 打包工具<br>345: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/345">NUMA-Aware Memory Allocation for G1</a> G1的NUMA-Aware内存分配<br>349: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/349">JFR Event Streaming</a> JFR事件流<br>352: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/352">Non-Volatile Mapped Byte Buffers</a> 非易失性映射字节缓冲区<br>358: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/358">Helpful NullPointerExceptions</a> 实用的NullPointerExceptions<br>359: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/359">Records (Preview)</a><br>361: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/361">Switch Expressions (Standard)</a> Switch表达式<br>362: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/362">Deprecate the Solaris and SPARC Ports</a> 弃用Solaris和SPARC端口<br>363: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/363">Remove the Concurrent Mark Sweep (CMS) Garbage Collector</a> 删除并发标记扫描（CMS）垃圾回收器<br>364: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/364">ZGC on macOS</a><br>365: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/365">ZGC on Windows</a><br>366: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/366">Deprecate the ParallelScavenge + SerialOld GC Combination</a> 弃用ParallelScavenge + SerialOld GC组合<br>367: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/367">Remove the Pack200 Tools and API</a> 删除Pack200工具和API<br>368: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/368">Text Blocks (Second Preview)</a> 文本块<br>370: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/370">Foreign-Memory Access API (Incubator)</a> 外部存储器访问API</p>
</blockquote>
<h4 id="jdk-15"><a href="#jdk-15" class="headerlink" title="jdk 15"></a>jdk 15</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p>
<blockquote>
<p>339: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/339">Edwards-Curve Digital Signature Algorithm (EdDSA)</a> EdDSA 数字签名算法<br>360: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/360">Sealed Classes (Preview)</a> 密封类（预览）<br>371: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/371">Hidden Classes</a> 隐藏类<br>372: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/372">Remove the Nashorn JavaScript Engine</a> 移除 Nashorn JavaScript 引擎<br>373: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/373">Reimplement the Legacy DatagramSocket API</a> 重新实现 Legacy DatagramSocket API<br>374: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/374">Disable and Deprecate Biased Locking</a> 禁用偏向锁定<br>375: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/375">Pattern Matching for instanceof (Second Preview)</a> instanceof 模式匹配（第二次预览）<br>377: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/377">ZGC: A Scalable Low-Latency Garbage Collector</a> ZGC：一个可扩展的低延迟垃圾收集器<br>378: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/378">Text Blocks</a> 文本块<br>379: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/379">Shenandoah: A Low-Pause-Time Garbage Collector</a> Shenandoah:低暂停时间垃圾收集器<br>381: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/381">Remove the Solaris and SPARC Ports</a> 移除 Solaris 和 SPARC 端口<br>383: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/383">Foreign-Memory Access API (Second Incubator)</a> 外部存储器访问 API（第二次孵化版）<br>384: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/384">Records (Second Preview)</a> Records（第二次预览）<br>385: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/385">Deprecate RMI Activation for Removal</a> 废弃 RMI 激活机制</p>
</blockquote>
<h4 id="jdk-16"><a href="#jdk-16" class="headerlink" title="jdk 16"></a>jdk 16</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/16/">https://openjdk.java.net/projects/jdk/16/</a></p>
<blockquote>
<p>338: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/338">Vector API (Incubator)</a> Vector API（孵化器）<br>347: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/347">Enable C++14 Language Features</a> JDK C++的源码中允许使用C++14的语言特性<br>357: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/357">Migrate from Mercurial to Git</a> OpenJDK源码的版本控制从Mercurial (hg) 迁移到git<br>369: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/369">Migrate to GitHub</a> OpenJDK源码的版本控制迁移到github上<br>376: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/376">ZGC: Concurrent Thread-Stack Processing</a> ZGC：并发线程处理<br>380: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/380">Unix-Domain Socket Channels</a> Unix域套接字通道<br>386: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/386">Alpine Linux Port</a> 将glibc的jdk移植到使用musl的alpine linux上<br>387: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/387">Elastic Metaspace</a> 弹性元空间<br>388: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/388">Windows&#x2F;AArch64 Port</a> 移植JDK到Windows&#x2F;AArch64<br>389: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/389">Foreign Linker API (Incubator)</a> 提供jdk.incubator.foreign来简化native code的调用<br>390: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/390">Warnings for Value-Based Classes</a> 提供基于值的类的警告<br>392: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/392">Packaging Tool</a> jpackage打包工具转正<br>393: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/393">Foreign-Memory Access API (Third Incubator)</a><br>394: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/394">Pattern Matching for instanceof</a> Instanceof的模式匹配转正<br>395: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">Records</a> Records转正<br>396: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/396">Strongly Encapsulate JDK Internals by Default</a> 默认情况下，封装了JDK内部构件<br>397: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/397">Sealed Classes (Second Preview)</a> 密封类</p>
</blockquote>
<h4 id="jdk-17"><a href="#jdk-17" class="headerlink" title="jdk 17"></a>jdk 17</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/17/">https://openjdk.java.net/projects/jdk/17/</a></p>
<blockquote>
<p>306: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/306">Restore Always-Strict Floating-Point Semantics</a> 恢复始终严格的浮点语义</p>
<p>356: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/356">Enhanced Pseudo-Random Number Generators</a> 增强型伪随机数生成器</p>
<p>382: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/382">New macOS Rendering Pipeline</a> 新的macOS渲染管道</p>
<p>391: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/391">macOS&#x2F;AArch64 Port</a> macOS&#x2F;AArch64端口</p>
<p>398: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/398">Deprecate the Applet API for Removal</a> 弃用Applet API后续将进行删除</p>
<p>403: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/403">Strongly Encapsulate JDK Internals</a> 强封装JDK的内部API</p>
<p>406: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/406">Pattern Matching for switch (Preview)</a> switch模式匹配（预览）</p>
<p>407: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/407">Remove RMI Activation</a> 删除RMI激活机制</p>
<p>409: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/409">Sealed Classes</a> 密封类转正</p>
<p>410: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/410">Remove the Experimental AOT and JIT Compiler</a> 删除实验性的AOT和JIT编译器</p>
<p>411: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/411">Deprecate the Security Manager for Removal</a> 弃用即将删除的安全管理器</p>
<p>412: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/412">Foreign Function &amp; Memory API (Incubator)</a> 外部函数和内存API（孵化特性）</p>
<p>414: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/414">Vector API (Second Incubator)</a> Vector API（第二次孵化特性）</p>
<p>415: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/415">Context-Specific Deserialization Filters</a> 上下文特定的反序列化过滤器</p>
</blockquote>
<h3 id="1-5-JDK各版本下载链接"><a href="#1-5-JDK各版本下载链接" class="headerlink" title="1.5 JDK各版本下载链接"></a>1.5 JDK各版本下载链接</h3><pre class="line-numbers language-http" data-language="http"><code class="language-http">https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;archive&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<img src="../images/image-20220525200441935.png" alt="image-20220525200441935" style="zoom:80%;" />

<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg">https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg</a><br>提取码：yyds </p>
</blockquote>
<p><img src="/../images/image-20221213235332866.png" alt="image-20221213235332866"></p>
<h3 id="1-6-如何学习新特性"><a href="#1-6-如何学习新特性" class="headerlink" title="1.6 如何学习新特性"></a>1.6 如何学习新特性</h3><p>对于新特性，我们应该从哪几个角度学习新特性呢？</p>
<ul>
<li><p>语法层面：</p>
<ul>
<li>比如JDK5中的自动拆箱、自动装箱、enum、泛型</li>
<li>比如JDK8中的lambda表达式、接口中的默认方法、静态方法</li>
<li>比如JDK10中局部变量的类型推断</li>
<li>比如JDK12中的switch</li>
<li>比如JDK13中的文本块</li>
</ul>
</li>
<li><p>API层面：</p>
<ul>
<li>比如JDK8中的Stream、Optional、新的日期时间、HashMap的底层结构</li>
<li>比如JDK9中String的底层结构</li>
<li>新的 &#x2F; 过时的 API</li>
</ul>
</li>
<li><p>底层优化</p>
<ul>
<li><p>比如JDK8中永久代被元空间替代、新的JS执行引擎</p>
</li>
<li><p>比如新的垃圾回收器、GC参数、JVM的优化</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-Java8新特性：Lambda表达式"><a href="#2-Java8新特性：Lambda表达式" class="headerlink" title="2. Java8新特性：Lambda表达式"></a>2. Java8新特性：Lambda表达式</h2><h3 id="2-1-关于Java8新特性简介"><a href="#2-1-关于Java8新特性简介" class="headerlink" title="2.1 关于Java8新特性简介"></a>2.1 关于Java8新特性简介</h3><p>Java 8 (又称为 JDK 8或JDK1.8) 是 Java 语言开发的一个主要版本。 Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p>
<img src="../images/image-20220525201653599.png" alt="image-20220525201653599" style="zoom:80%;" />

<ul>
<li><p>速度更快</p>
</li>
<li><p>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</p>
</li>
<li><p>强大的 <strong>Stream API</strong></p>
</li>
<li><p>便于并行</p>
<ul>
<li><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li>
<li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</li>
</ul>
</li>
<li><p>最大化减少空指针异常：Optional</p>
</li>
<li><p>Nashorn引擎，允许在JVM上运行JS应用</p>
<ul>
<li>发音“nass-horn”，是德国二战时一个坦克的命名</li>
<li>javascript运行在jvm已经不是新鲜事了，Rhino早在jdk6的时候已经存在。现在替代Rhino，官方的解释是Rhino相比其他JavaScript引擎（比如google的V8）实在太慢了，改造Rhino还不如重写。所以Nashorn的性能也是其一个亮点。</li>
<li>Nashorn 项目在 JDK 9 中得到改进；在JDK11 中<code>Deprecated</code>，后续JDK15版本中<code>remove</code>。在JDK11中取以代之的是GraalVM。（GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。）</li>
</ul>
</li>
</ul>
<h3 id="2-2-冗余的匿名内部类"><a href="#2-2-冗余的匿名内部类" class="headerlink" title="2.2 冗余的匿名内部类"></a>2.2 冗余的匿名内部类</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.fp;

public class UseFunctionalProgramming &#123;
    public static void main(String[] args) &#123;
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;多线程任务执行！&quot;);
            &#125;
        &#125;).start(); &#x2F;&#x2F; 启动线程
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<p><strong>代码分析：</strong></p>
<p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h3 id="2-3-好用的lambda表达式"><a href="#2-3-好用的lambda表达式" class="headerlink" title="2.3 好用的lambda表达式"></a>2.3 好用的lambda表达式</h3><img src="../images/lambda表达式.jpg" alt="lambda表达式" style="zoom:67%;" />

<p><img src="/../images/image-20221111213355625.png" alt="image-20221111213355625"></p>
<h3 id="2-4-Lambda-及其使用举例"><a href="#2-4-Lambda-及其使用举例" class="headerlink" title="2.4 Lambda 及其使用举例"></a>2.4 Lambda 及其使用举例</h3><p>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<ul>
<li>从匿名类到 Lambda 的转换举例1</li>
</ul>
<img src="../images/image-20220527101737072.png" alt="image-20220527101737072" style="zoom:67%;" />

<ul>
<li>从匿名类到 Lambda 的转换举例2</li>
</ul>
<img src="../images/image-20220527101814203.png" alt="image-20220527101814203" style="zoom:80%;" />

<h3 id="2-5-语法"><a href="#2-5-语法" class="headerlink" title="2.5 语法"></a>2.5 语法</h3><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “<code>-&gt;</code>” ， 该操作符被称为 <code>Lambda 操作符</code>或<code>箭头操作符</code>。它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表</li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</li>
</ul>
<p><strong>语法格式一：</strong>无参，无返回值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test1()&#123;
    &#x2F;&#x2F;未使用Lambda表达式
    Runnable r1 &#x3D; new Runnable() &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;我爱北京天安门&quot;);
        &#125;
    &#125;;

    r1.run();

    System.out.println(&quot;***********************&quot;);

    &#x2F;&#x2F;使用Lambda表达式
    Runnable r2 &#x3D; () -&gt; &#123;
        System.out.println(&quot;我爱北京故宫&quot;);
    &#125;;

    r2.run();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>语法格式二：</strong>Lambda 需要一个参数，但是没有返回值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test2()&#123;
    &#x2F;&#x2F;未使用Lambda表达式
    Consumer&lt;String&gt; con &#x3D; new Consumer&lt;String&gt;() &#123;
        @Override
        public void accept(String s) &#123;
            System.out.println(s);
        &#125;
    &#125;;
    con.accept(&quot;谎言和誓言的区别是什么？&quot;);

    System.out.println(&quot;*******************&quot;);

    &#x2F;&#x2F;使用Lambda表达式
    Consumer&lt;String&gt; con1 &#x3D; (String s) -&gt; &#123;
        System.out.println(s);
    &#125;;
    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>语法格式三：</strong>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test3()&#123;
    &#x2F;&#x2F;语法格式三使用前
    Consumer&lt;String&gt; con1 &#x3D; (String s) -&gt; &#123;
        System.out.println(s);
    &#125;;
    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);

    System.out.println(&quot;*******************&quot;);
    &#x2F;&#x2F;语法格式三使用后
    Consumer&lt;String&gt; con2 &#x3D; (s) -&gt; &#123;
        System.out.println(s);
    &#125;;
    con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>语法格式四：</strong>Lambda 若只需要一个参数时，参数的小括号可以省略</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test4()&#123;
    &#x2F;&#x2F;语法格式四使用前
    Consumer&lt;String&gt; con1 &#x3D; (s) -&gt; &#123;
        System.out.println(s);
    &#125;;
    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);

    System.out.println(&quot;*******************&quot;);
    &#x2F;&#x2F;语法格式四使用后
    Consumer&lt;String&gt; con2 &#x3D; s -&gt; &#123;
        System.out.println(s);
    &#125;;
    con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>语法格式五：</strong>Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test5()&#123;
    &#x2F;&#x2F;语法格式五使用前
    Comparator&lt;Integer&gt; com1 &#x3D; new Comparator&lt;Integer&gt;() &#123;
        @Override
        public int compare(Integer o1, Integer o2) &#123;
            System.out.println(o1);
            System.out.println(o2);
            return o1.compareTo(o2);
        &#125;
    &#125;;

    System.out.println(com1.compare(12,21));
    System.out.println(&quot;*****************************&quot;);
    &#x2F;&#x2F;语法格式五使用后
    Comparator&lt;Integer&gt; com2 &#x3D; (o1,o2) -&gt; &#123;
        System.out.println(o1);
        System.out.println(o2);
        return o1.compareTo(o2);
    &#125;;

    System.out.println(com2.compare(12,6));


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>语法格式六：</strong>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test6()&#123;
    &#x2F;&#x2F;语法格式六使用前
    Comparator&lt;Integer&gt; com1 &#x3D; (o1,o2) -&gt; &#123;
        return o1.compareTo(o2);
    &#125;;

    System.out.println(com1.compare(12,6));

    System.out.println(&quot;*****************************&quot;);
    &#x2F;&#x2F;语法格式六使用后
    Comparator&lt;Integer&gt; com2 &#x3D; (o1,o2) -&gt; o1.compareTo(o2);

    System.out.println(com2.compare(12,21));

&#125;

@Test
public void test7()&#123;
    &#x2F;&#x2F;语法格式六使用前
    Consumer&lt;String&gt; con1 &#x3D; s -&gt; &#123;
        System.out.println(s);
    &#125;;
    con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);

    System.out.println(&quot;*****************************&quot;);
    &#x2F;&#x2F;语法格式六使用后
    Consumer&lt;String&gt; con2 &#x3D; s -&gt; System.out.println(s);

    con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-6-关于类型推断"><a href="#2-6-关于类型推断" class="headerlink" title="2.6 关于类型推断"></a>2.6 关于类型推断</h3><p>在语法格式三 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“<code>类型推断</code>”。</p>
<img src="../images/image-20220527103215741.png" alt="image-20220527103215741" style="zoom:67%;" />

<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test() &#123;
    &#x2F;&#x2F;类型推断1
    ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
    &#x2F;&#x2F;类型推断2
    int[] arr &#x3D; &#123;1, 2, 3&#125;;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="3-Java8新特性：函数式-Functional-接口"><a href="#3-Java8新特性：函数式-Functional-接口" class="headerlink" title="3. Java8新特性：函数式(Functional)接口"></a>3. Java8新特性：函数式(Functional)接口</h2><h3 id="3-1-什么是函数式接口"><a href="#3-1-什么是函数式接口" class="headerlink" title="3.1 什么是函数式接口"></a>3.1 什么是函数式接口</h3><ul>
<li>只包含<code>一个抽象方法</code>（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。</li>
<li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>我们可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li>
<li>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口</li>
</ul>
<h3 id="3-2-如何理解函数式接口"><a href="#3-2-如何理解函数式接口" class="headerlink" title="3.2 如何理解函数式接口"></a>3.2 如何理解函数式接口</h3><p><img src="/images/03-Overview.png"></p>
<ul>
<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，即Java不但可以支持OOP还可以支持OOF（面向函数编程）<ul>
<li>Java8引入了Lambda表达式之后，Java也开始支持函数式编程。</li>
<li>Lambda表达式不是Java最早使用的。目前C++，C#，Python，Scala等均支持Lambda表达式。</li>
</ul>
</li>
<li>面向对象的思想：<ul>
<li>做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。</li>
</ul>
</li>
<li>函数式编程思想：<ul>
<li>只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。</li>
</ul>
</li>
<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</li>
<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>
</ul>
<h3 id="3-3-举例"><a href="#3-3-举例" class="headerlink" title="3.3 举例"></a>3.3 举例</h3><p>举例1：</p>
<img src="../images/image-20220527111442115.png" alt="image-20220527111442115" style="zoom: 80%;" />

<p>举例2：</p>
<img src="../images/image-20220527111621424.png" alt="image-20220527111621424" style="zoom:80%;" />

<p>作为参数传递 Lambda 表达式：</p>
<img src="../images/image-20220527111751485.png" alt="image-20220527111751485" style="zoom:80%;" />

<blockquote>
<p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p>
</blockquote>
<h3 id="3-4-Java-内置函数式接口"><a href="#3-4-Java-内置函数式接口" class="headerlink" title="3.4 Java 内置函数式接口"></a>3.4 Java 内置函数式接口</h3><h4 id="3-4-1-之前的函数式接口"><a href="#3-4-1-之前的函数式接口" class="headerlink" title="3.4.1 之前的函数式接口"></a>3.4.1 之前的函数式接口</h4><p>之前学过的接口，有些就是函数式接口，比如：</p>
<ul>
<li>java.lang.Runnable<ul>
<li>public void run()</li>
</ul>
</li>
<li>java.lang.Iterable<T><ul>
<li>public Iterator<T> iterate()</li>
</ul>
</li>
<li>java.lang.Comparable<T><ul>
<li>public int compareTo(T t)</li>
</ul>
</li>
<li>java.util.Comparator<T><ul>
<li>public int compare(T t1, T t2)</li>
</ul>
</li>
</ul>
<h4 id="3-4-2-四大核心函数式接口"><a href="#3-4-2-四大核心函数式接口" class="headerlink" title="3.4.2 四大核心函数式接口"></a>3.4.2 四大核心函数式接口</h4><table>
<thead>
<tr>
<th>函数式接口</th>
<th>称谓</th>
<th>参数类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>Consumer&lt;T&gt;  </code></td>
<td>消费型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，包含方法：  <code>void accept(T t)  </code></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;  </code></td>
<td>供给型接口</td>
<td>无</td>
<td>返回类型为T的对象，包含方法：<code>T get()  </code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;  </code></td>
<td>函数型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)  </code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;  </code></td>
<td>判断型接口</td>
<td>T</td>
<td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)  </code></td>
</tr>
</tbody></table>
<h4 id="3-4-3-其它接口"><a href="#3-4-3-其它接口" class="headerlink" title="3.4.3 其它接口"></a>3.4.3 其它接口</h4><p><strong>类型1：消费型接口</strong></p>
<p>消费型接口的抽象方法特点：有形参，但是返回值类型是void</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>void accept(T t, U u)</td>
<td>接收两个对象用于完成功能</td>
</tr>
<tr>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntConsumer</td>
<td>void accept(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongConsumer</td>
<td>void accept(long value)</td>
<td>接收一个long值</td>
</tr>
<tr>
<td>ObjDoubleConsumer<T></td>
<td>void accept(T t, double value)</td>
<td>接收一个对象和一个double值</td>
</tr>
<tr>
<td>ObjIntConsumer<T></td>
<td>void accept(T t, int value)</td>
<td>接收一个对象和一个int值</td>
</tr>
<tr>
<td>ObjLongConsumer<T></td>
<td>void accept(T t, long value)</td>
<td>接收一个对象和一个long值</td>
</tr>
</tbody></table>
<p><strong>类型2：供给型接口</strong></p>
<p>这类接口的抽象方法特点：无参，但是有返回值</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
<td>返回一个boolean值</td>
</tr>
<tr>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
<td>返回一个double值</td>
</tr>
<tr>
<td>IntSupplier</td>
<td>int getAsInt()</td>
<td>返回一个int值</td>
</tr>
<tr>
<td>LongSupplier</td>
<td>long getAsLong()</td>
<td>返回一个long值</td>
</tr>
</tbody></table>
<p><strong>类型3：函数型接口</strong></p>
<p>这类接口的抽象方法特点：既有参数又有返回值</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator<T></td>
<td>T apply(T t)</td>
<td>接收一个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>DoubleFunction<R></td>
<td>R apply(double value)</td>
<td>接收一个double值，返回一个R类型对象</td>
</tr>
<tr>
<td>IntFunction<R></td>
<td>R apply(int value)</td>
<td>接收一个int值，返回一个R类型对象</td>
</tr>
<tr>
<td>LongFunction<R></td>
<td>R apply(long value)</td>
<td>接收一个long值，返回一个R类型对象</td>
</tr>
<tr>
<td>ToDoubleFunction<T></td>
<td>double applyAsDouble(T value)</td>
<td>接收一个T类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntFunction<T></td>
<td>int applyAsInt(T value)</td>
<td>接收一个T类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongFunction<T></td>
<td>long applyAsLong(T value)</td>
<td>接收一个T类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleToIntFunction</td>
<td>int applyAsInt(double value)</td>
<td>接收一个double值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleToLongFunction</td>
<td>long applyAsLong(double value)</td>
<td>接收一个double值，返回一个long结果</td>
</tr>
<tr>
<td>IntToDoubleFunction</td>
<td>double applyAsDouble(int value)</td>
<td>接收一个int值，返回一个double结果</td>
</tr>
<tr>
<td>IntToLongFunction</td>
<td>long applyAsLong(int value)</td>
<td>接收一个int值，返回一个long结果</td>
</tr>
<tr>
<td>LongToDoubleFunction</td>
<td>double applyAsDouble(long value)</td>
<td>接收一个long值，返回一个double结果</td>
</tr>
<tr>
<td>LongToIntFunction</td>
<td>int applyAsInt(long value)</td>
<td>接收一个long值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double operand)</td>
<td>接收一个double值，返回一个double</td>
</tr>
<tr>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int operand)</td>
<td>接收一个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long operand)</td>
<td>接收一个long值，返回一个long结果</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>R apply(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>T apply(T t, T u)</td>
<td>接收两个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>ToDoubleBiFunction&lt;T,U&gt;</td>
<td>double applyAsDouble(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntBiFunction&lt;T,U&gt;</td>
<td>int applyAsInt(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongBiFunction&lt;T,U&gt;</td>
<td>long applyAsLong(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double left, double right)</td>
<td>接收两个double值，返回一个double结果</td>
</tr>
<tr>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int left, int right)</td>
<td>接收两个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long left, long right)</td>
<td>接收两个long值，返回一个long结果</td>
</tr>
</tbody></table>
<p><strong>类型4：判断型接口</strong></p>
<p>这类接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>boolean test(T t, U u)</td>
<td>接收两个对象</td>
</tr>
<tr>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
<td>接收一个long值</td>
</tr>
</tbody></table>
<h4 id="3-4-4-内置接口代码演示"><a href="#3-4-4-内置接口代码演示" class="headerlink" title="3.4.4 内置接口代码演示"></a>3.4.4 内置接口代码演示</h4><p>举例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.Arrays;
import java.util.List;

public class TestConsumer &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; list &#x3D; Arrays.asList(&quot;java&quot;,&quot;c&quot;,&quot;python&quot;,&quot;c++&quot;,&quot;VB&quot;,&quot;C#&quot;);
        &#x2F;&#x2F;遍历Collection集合，并将传递给action参数的操作代码应用在每一个元素上。
        list.forEach(s -&gt; System.out.println(s));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>举例2：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.function.Supplier;

public class TestSupplier &#123;
    public static void main(String[] args) &#123;
        Supplier&lt;String&gt; supplier &#x3D; () -&gt; &quot;尚硅谷&quot;;
        System.out.println(supplier.get());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>举例3：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.ArrayList;

public class TestPredicate &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
        list.add(&quot;hello&quot;);
        list.add(&quot;java&quot;);
        list.add(&quot;atguigu&quot;);
        list.add(&quot;ok&quot;);
        list.add(&quot;yes&quot;);

        System.out.println(&quot;删除之前：&quot;);
        list.forEach(t-&gt; System.out.println(t));
		
        &#x2F;&#x2F;用于删除集合中满足filter指定的条件判断的。
        &#x2F;&#x2F;删除包含o字母的元素
        list.removeIf(s -&gt; s.contains(&quot;o&quot;));

        System.out.println(&quot;删除包含o字母的元素之后：&quot;);
        list.forEach(t-&gt; System.out.println(t));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>举例4：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.four;

import java.util.function.Function;

public class TestFunction &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;使用Lambda表达式实现Function&lt;T,R&gt;接口，可以实现将一个字符串首字母转为大写的功能。
        Function&lt;String,String&gt; fun &#x3D; s -&gt; s.substring(0,1).toUpperCase() + s.substring(1);
        System.out.println(fun.apply(&quot;hello&quot;));
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-4-5-练习"><a href="#3-4-5-练习" class="headerlink" title="3.4.5 练习"></a>3.4.5 练习</h4><p><strong>练习1：无参无返回值形式</strong></p>
<p>假如有自定义函数式接口Call如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Call &#123;
    void shout();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在测试类中声明一个如下方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void callSomething(Call call)&#123;
		call.shout();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestLambda &#123;
	public static void main(String[] args) &#123;
		callSomething(()-&gt;System.out.println(&quot;回家吃饭&quot;));
		callSomething(()-&gt;System.out.println(&quot;我爱你&quot;));
		callSomething(()-&gt;System.out.println(&quot;滚蛋&quot;));
		callSomething(()-&gt;System.out.println(&quot;回来&quot;));
	&#125;
	public static void callSomething(Call call)&#123;
		call.shout();
	&#125;
&#125;
interface Call &#123;
    void shout();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>练习2：消费型接口</strong></p>
<p>代码示例：Consumer<T>接口</p>
<p>在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法：</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>在JDK1.8中Map集合接口中增加了一个默认方法：</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）创建一个Collection系列的集合，添加一些字符串，调用forEach方法遍历查看</p>
<p>（2）创建一个Map系列的集合，添加一些(key,value)键值对，调用forEach方法遍历查看</p>
<p>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test1()&#123;
	List&lt;String&gt; list &#x3D; Arrays.asList(&quot;hello&quot;,&quot;java&quot;,&quot;lambda&quot;,&quot;atguigu&quot;);
	list.forEach(s -&gt; System.out.println(s));
   &#125;
@Test
public void test2()&#123;
	HashMap&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();
	map.put(1, &quot;hello&quot;);
	map.put(2, &quot;java&quot;);
	map.put(3, &quot;lambda&quot;);
	map.put(4, &quot;atguigu&quot;);
	map.forEach((k,v) -&gt; System.out.println(k+&quot;-&gt;&quot;+v));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>练习3：供给型接口</strong></p>
<p>代码示例：Supplier<T>接口</p>
<p>在JDK1.8中增加了StreamAPI，java.util.stream.Stream<T>是一个数据流。这个类型有一个静态方法：</p>
<p><code>public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code>可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：<code>public void forEach(Consumer&lt;? super T&gt; action)</code>。</p>
<p>案例：</p>
<p>现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test2()&#123;
	Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>练习4：功能型接口</strong></p>
<p>代码示例：Function&lt;T,R&gt;接口</p>
<p>在JDK1.8时Map接口增加了很多方法，例如：</p>
<p><code>public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function) </code>按照function指定的操作替换map中的value。</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、薪资。</p>
<p>（2）添加n个员工对象到一个HashMap&lt;Integer,Employee&gt;集合中，其中员工编号为key，员工对象为value。</p>
<p>（3）调用Map的forEach遍历集合</p>
<p>（4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。</p>
<p>（5）再次调用Map的forEach遍历集合查看结果</p>
<p>Employee类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee&#123;
	private int id;
	private String name;
	private double salary;
	public Employee(int id, String name, double salary) &#123;
		super();
		this.id &#x3D; id;
		this.name &#x3D; name;
		this.salary &#x3D; salary;
	&#125;
	public Employee() &#123;
		super();
	&#125;
	public int getId() &#123;
		return id;
	&#125;
	public void setId(int id) &#123;
		this.id &#x3D; id;
	&#125;
	public String getName() &#123;
		return name;
	&#125;
	public void setName(String name) &#123;
		this.name &#x3D; name;
	&#125;
	public double getSalary() &#123;
		return salary;
	&#125;
	public void setSalary(double salary) &#123;
		this.salary &#x3D; salary;
	&#125;
	@Override
	public String toString() &#123;
		return &quot;Employee [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, salary&#x3D;&quot; + salary + &quot;]&quot;;
	&#125;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.HashMap;

public class TestLambda &#123;
	public static void main(String[] args) &#123;
		HashMap&lt;Integer,Employee&gt; map &#x3D; new HashMap&lt;&gt;();
		Employee e1 &#x3D; new Employee(1, &quot;张三&quot;, 8000);
		Employee e2 &#x3D; new Employee(2, &quot;李四&quot;, 9000);
		Employee e3 &#x3D; new Employee(3, &quot;王五&quot;, 10000);
		Employee e4 &#x3D; new Employee(4, &quot;赵六&quot;, 11000);
		Employee e5 &#x3D; new Employee(5, &quot;钱七&quot;, 12000);
		
		map.put(e1.getId(), e1);
		map.put(e2.getId(), e2);
		map.put(e3.getId(), e3);
		map.put(e4.getId(), e4);
		map.put(e5.getId(), e5);
		
		map.forEach((k,v) -&gt; System.out.println(k+&quot;&#x3D;&quot;+v));
		System.out.println();
		
		map.replaceAll((k,v)-&gt;&#123;
			if(v.getSalary()&lt;10000)&#123;
				v.setSalary(10000);
			&#125;
			return v;
		&#125;);
		map.forEach((k,v) -&gt; System.out.println(k+&quot;&#x3D;&quot;+v));
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>练习5：判断型接口</strong></p>
<p>代码示例：Predicate<T>接口</p>
<p>JDK1.8时，Collecton<E>接口增加了一下方法，其中一个如下：</p>
<p><code>public default boolean removeIf(Predicate&lt;? super E&gt; filter)</code> 用于删除集合中满足filter指定的条件判断的。</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action) </code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）添加一些字符串到一个Collection集合中</p>
<p>（2）调用forEach遍历集合</p>
<p>（3）调用removeIf方法，删除其中字符串的长度&lt;5的</p>
<p>（4）再次调用forEach遍历集合</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;

public class TestLambda &#123;
	public static void main(String[] args) &#123;
		ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
		list.add(&quot;hello&quot;);
		list.add(&quot;java&quot;);
		list.add(&quot;atguigu&quot;);
		list.add(&quot;ok&quot;);
		list.add(&quot;yes&quot;);
		
		list.forEach(str-&gt;System.out.println(str));
		System.out.println();
		
		list.removeIf(str-&gt;str.length()&lt;5);
		list.forEach(str-&gt;System.out.println(str));
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>练习6：判断型接口</strong></p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。</p>
<p>（2）声明一个EmployeeSerice员工管理类，包含一个ArrayList<Employee>集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。</p>
<p>（3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList<Employee> get(Predicate<Employee> p)，即将满足p指定的条件的员工，添加到一个新的ArrayList<Employee> 集合中返回。</p>
<p>（4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取：</p>
<ul>
<li>所有员工对象</li>
<li>所有年龄超过35的员工</li>
<li>所有薪资高于15000的女员工</li>
<li>所有编号是偶数的员工</li>
<li>名字是“张三”的员工</li>
<li>年龄超过25，薪资低于10000的男员工</li>
</ul>
<p>示例代码：</p>
<p>Employee类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;
	private int id;
	private String name;
	private char gender;
	private int age;
	private double salary;
	
	public Employee(int id, String name, char gender, int age, double salary) &#123;
		super();
		this.id &#x3D; id;
		this.name &#x3D; name;
		this.gender &#x3D; gender;
		this.age &#x3D; age;
		this.salary &#x3D; salary;
	&#125;
	public Employee() &#123;
		super();
	&#125;
	public int getId() &#123;
		return id;
	&#125;
	public void setId(int id) &#123;
		this.id &#x3D; id;
	&#125;
	public String getName() &#123;
		return name;
	&#125;
	public void setName(String name) &#123;
		this.name &#x3D; name;
	&#125;
	public double getSalary() &#123;
		return salary;
	&#125;
	public void setSalary(double salary) &#123;
		this.salary &#x3D; salary;
	&#125;
	@Override
	public String toString() &#123;
		return &quot;Employee [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, gender&#x3D;&quot; + gender + &quot;, age&#x3D;&quot; + age + &quot;, salary&#x3D;&quot; + salary
				+ &quot;]&quot;;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>员工管理类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class EmployeeService&#123;
	private ArrayList&lt;Employee&gt; all;
	public EmployeeService()&#123;
		all &#x3D; new ArrayList&lt;Employee&gt;();
		all.add(new Employee(1, &quot;张三&quot;, &#39;男&#39;, 33, 8000));
		all.add(new Employee(2, &quot;翠花&quot;, &#39;女&#39;, 23, 18000));
		all.add(new Employee(3, &quot;无能&quot;, &#39;男&#39;, 46, 8000));
		all.add(new Employee(4, &quot;李四&quot;, &#39;女&#39;, 23, 9000));
		all.add(new Employee(5, &quot;老王&quot;, &#39;男&#39;, 23, 15000));
		all.add(new Employee(6, &quot;大嘴&quot;, &#39;男&#39;, 23, 11000));
	&#125;
	public ArrayList&lt;Employee&gt; get(Predicate&lt;Employee&gt; p)&#123;
		ArrayList&lt;Employee&gt; result &#x3D; new ArrayList&lt;Employee&gt;();
		for (Employee emp : result) &#123;
			if(p.test(emp))&#123;
				result.add(emp);
			&#125;
		&#125;
		return result;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestLambda &#123;
	public static void main(String[] args) &#123;
		EmployeeService es &#x3D; new EmployeeService();
		
		es.get(e -&gt; true).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getAge()&gt;35).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getSalary()&gt;15000 &amp;&amp; e.getGender()&#x3D;&#x3D;&#39;女&#39;).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getId()%2&#x3D;&#x3D;0).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; &quot;张三&quot;.equals(e.getName())).forEach(e-&gt;System.out.println(e));
		System.out.println();
		es.get(e -&gt; e.getAge()&gt;25 &amp;&amp; e.getSalary()&lt;10000 &amp;&amp; e.getGender()&#x3D;&#x3D;&#39;男&#39;).forEach(e-&gt;System.out.println(e));
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-Java8新特性：方法引用与构造器引用"><a href="#4-Java8新特性：方法引用与构造器引用" class="headerlink" title="4. Java8新特性：方法引用与构造器引用"></a>4. Java8新特性：方法引用与构造器引用</h2><p>Lambda表达式是可以简化函数式接口的变量或形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。</p>
<h3 id="4-1-方法引用"><a href="#4-1-方法引用" class="headerlink" title="4.1 方法引用"></a>4.1 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>
<p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>
<blockquote>
<p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法<code>对语言的功能并没有影响，但是更方便程序员使用</code>。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
</blockquote>
<h4 id="4-1-1-方法引用格式"><a href="#4-1-1-方法引用格式" class="headerlink" title="4.1.1 方法引用格式"></a>4.1.1 方法引用格式</h4><ul>
<li><p>格式：使用方法引用操作符 “<code>::</code>” 将类(或对象) 与 方法名分隔开来。</p>
<ul>
<li>两个:中间不能有空格，而且必须英文状态下半角输入</li>
</ul>
</li>
<li><p>如下三种主要使用情况：</p>
<ul>
<li>情况1：<code>对象 :: 实例方法名</code></li>
<li>情况2：<code>类 :: 静态方法名</code></li>
<li>情况3：<code>类 :: 实例方法名</code></li>
</ul>
</li>
</ul>
<h4 id="4-1-2-方法引用使用前提"><a href="#4-1-2-方法引用使用前提" class="headerlink" title="4.1.2 方法引用使用前提"></a>4.1.2 方法引用使用前提</h4><p><strong>要求1：</strong>Lambda体只有一句语句，并且是通过调用一个对象的&#x2F;类现有的方法来完成的</p>
<p>例如：System.out对象，调用println()方法来完成Lambda体</p>
<p>​           Math类，调用random()静态方法来完成Lambda体</p>
<p><strong>要求2：</strong></p>
<p>针对情况1：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p>
<p>针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p>
<p>针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以）</p>
<p>例如：t-&gt;System.out.println(t)</p>
<p>​        () -&gt; Math.random() 都是无参</p>
<h4 id="4-1-3-举例"><a href="#4-1-3-举例" class="headerlink" title="4.1.3 举例"></a>4.1.3 举例</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MethodRefTest &#123;

	&#x2F;&#x2F; 情况一：对象 :: 实例方法
	&#x2F;&#x2F;Consumer中的void accept(T t)
	&#x2F;&#x2F;PrintStream中的void println(T t)
	@Test
	public void test1() &#123;
		Consumer&lt;String&gt; con1 &#x3D; str -&gt; System.out.println(str);
		con1.accept(&quot;北京&quot;);

		System.out.println(&quot;*******************&quot;);
		PrintStream ps &#x3D; System.out;
		Consumer&lt;String&gt; con2 &#x3D; ps::println;
		con2.accept(&quot;beijing&quot;);
	&#125;
	
	&#x2F;&#x2F;Supplier中的T get()
	&#x2F;&#x2F;Employee中的String getName()
	@Test
	public void test2() &#123;
		Employee emp &#x3D; new Employee(1001,&quot;Tom&quot;,23,5600);

		Supplier&lt;String&gt; sup1 &#x3D; () -&gt; emp.getName();
		System.out.println(sup1.get());

		System.out.println(&quot;*******************&quot;);
		Supplier&lt;String&gt; sup2 &#x3D; emp::getName;
		System.out.println(sup2.get());

	&#125;

	&#x2F;&#x2F; 情况二：类 :: 静态方法
	&#x2F;&#x2F;Comparator中的int compare(T t1,T t2)
	&#x2F;&#x2F;Integer中的int compare(T t1,T t2)
	@Test
	public void test3() &#123;
		Comparator&lt;Integer&gt; com1 &#x3D; (t1,t2) -&gt; Integer.compare(t1,t2);
		System.out.println(com1.compare(12,21));

		System.out.println(&quot;*******************&quot;);

		Comparator&lt;Integer&gt; com2 &#x3D; Integer::compare;
		System.out.println(com2.compare(12,3));

	&#125;
	
	&#x2F;&#x2F;Function中的R apply(T t)
	&#x2F;&#x2F;Math中的Long round(Double d)
	@Test
	public void test4() &#123;
		Function&lt;Double,Long&gt; func &#x3D; new Function&lt;Double, Long&gt;() &#123;
			@Override
			public Long apply(Double d) &#123;
				return Math.round(d);
			&#125;
		&#125;;

		System.out.println(&quot;*******************&quot;);

		Function&lt;Double,Long&gt; func1 &#x3D; d -&gt; Math.round(d);
		System.out.println(func1.apply(12.3));

		System.out.println(&quot;*******************&quot;);

		Function&lt;Double,Long&gt; func2 &#x3D; Math::round;
		System.out.println(func2.apply(12.6));
	&#125;

	&#x2F;&#x2F; 情况三：类 :: 实例方法  (有难度)
	&#x2F;&#x2F; Comparator中的int comapre(T t1,T t2)
	&#x2F;&#x2F; String中的int t1.compareTo(t2)
	@Test
	public void test5() &#123;
		Comparator&lt;String&gt; com1 &#x3D; (s1,s2) -&gt; s1.compareTo(s2);
		System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));

		System.out.println(&quot;*******************&quot;);

		Comparator&lt;String&gt; com2 &#x3D; String :: compareTo;
		System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));
	&#125;

	&#x2F;&#x2F;BiPredicate中的boolean test(T t1, T t2);
	&#x2F;&#x2F;String中的boolean t1.equals(t2)
	@Test
	public void test6() &#123;
		BiPredicate&lt;String,String&gt; pre1 &#x3D; (s1,s2) -&gt; s1.equals(s2);
		System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;));

		System.out.println(&quot;*******************&quot;);
		BiPredicate&lt;String,String&gt; pre2 &#x3D; String :: equals;
		System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;));
	&#125;
	
	&#x2F;&#x2F; Function中的R apply(T t)
	&#x2F;&#x2F; Employee中的String getName();
	@Test
	public void test7() &#123;
		Employee employee &#x3D; new Employee(1001, &quot;Jerry&quot;, 23, 6000);


		Function&lt;Employee,String&gt; func1 &#x3D; e -&gt; e.getName();
		System.out.println(func1.apply(employee));

		System.out.println(&quot;*******************&quot;);
		Function&lt;Employee,String&gt; func2 &#x3D; Employee::getName;
		System.out.println(func2.apply(employee));
	&#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-2-构造器引用"><a href="#4-2-构造器引用" class="headerlink" title="4.2 构造器引用"></a>4.2 构造器引用</h3><p>当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。</p>
<p>格式：<code>类名::new</code></p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ConstructorRefTest &#123;
	&#x2F;&#x2F;构造器引用
    &#x2F;&#x2F;Supplier中的T get()
    &#x2F;&#x2F;Employee的空参构造器：Employee()
    @Test
    public void test1()&#123;

        Supplier&lt;Employee&gt; sup &#x3D; new Supplier&lt;Employee&gt;() &#123;
            @Override
            public Employee get() &#123;
                return new Employee();
            &#125;
        &#125;;
        System.out.println(&quot;*******************&quot;);

        Supplier&lt;Employee&gt;  sup1 &#x3D; () -&gt; new Employee();
        System.out.println(sup1.get());

        System.out.println(&quot;*******************&quot;);

        Supplier&lt;Employee&gt;  sup2 &#x3D; Employee :: new;
        System.out.println(sup2.get());
    &#125;

	&#x2F;&#x2F;Function中的R apply(T t)
    @Test
    public void test2()&#123;
        Function&lt;Integer,Employee&gt; func1 &#x3D; id -&gt; new Employee(id);
        Employee employee &#x3D; func1.apply(1001);
        System.out.println(employee);

        System.out.println(&quot;*******************&quot;);

        Function&lt;Integer,Employee&gt; func2 &#x3D; Employee :: new;
        Employee employee1 &#x3D; func2.apply(1002);
        System.out.println(employee1);

    &#125;

	&#x2F;&#x2F;BiFunction中的R apply(T t,U u)
    @Test
    public void test3()&#123;
        BiFunction&lt;Integer,String,Employee&gt; func1 &#x3D; (id,name) -&gt; new Employee(id,name);
        System.out.println(func1.apply(1001,&quot;Tom&quot;));

        System.out.println(&quot;*******************&quot;);

        BiFunction&lt;Integer,String,Employee&gt; func2 &#x3D; Employee :: new;
        System.out.println(func2.apply(1002,&quot;Tom&quot;));

    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.java2;

&#x2F;**
 * @author 尚硅谷-宋红康 邮箱：shkstart@126.com
 *&#x2F;
public class Employee &#123;

	private int id;
	private String name;
	private int age;
	private double salary;

	public int getId() &#123;
		return id;
	&#125;

	public void setId(int id) &#123;
		this.id &#x3D; id;
	&#125;

	public String getName() &#123;
		return name;
	&#125;

	public void setName(String name) &#123;
		this.name &#x3D; name;
	&#125;

	public int getAge() &#123;
		return age;
	&#125;

	public void setAge(int age) &#123;
		this.age &#x3D; age;
	&#125;

	public double getSalary() &#123;
		return salary;
	&#125;

	public void setSalary(double salary) &#123;
		this.salary &#x3D; salary;
	&#125;

	public Employee() &#123;
		System.out.println(&quot;Employee().....&quot;);
	&#125;

	public Employee(int id) &#123;
		this.id &#x3D; id;
		System.out.println(&quot;Employee(int id).....&quot;);
	&#125;

	public Employee(int id, String name) &#123;
		this.id &#x3D; id;
		this.name &#x3D; name;
	&#125;

	public Employee(int id, String name, int age, double salary) &#123;

		this.id &#x3D; id;
		this.name &#x3D; name;
		this.age &#x3D; age;
		this.salary &#x3D; salary;
	&#125;

	@Override
	public String toString() &#123;
		return &quot;Employee&#123;&quot; + &quot;id&#x3D;&quot; + id + &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age&#x3D;&quot; + age + &quot;, salary&#x3D;&quot; + salary + &#39;&#125;&#39;;
	&#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-3-数组构造引用"><a href="#4-3-数组构造引用" class="headerlink" title="4.3 数组构造引用"></a>4.3 数组构造引用</h3><p>当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。</p>
<p>格式：<code>数组类型名::new</code></p>
<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;数组引用
&#x2F;&#x2F;Function中的R apply(T t)
@Test
public void test4()&#123;
    Function&lt;Integer,String[]&gt; func1 &#x3D; length -&gt; new String[length];
    String[] arr1 &#x3D; func1.apply(5);
    System.out.println(Arrays.toString(arr1));

    System.out.println(&quot;*******************&quot;);

    Function&lt;Integer,String[]&gt; func2 &#x3D; String[] :: new;
    String[] arr2 &#x3D; func2.apply(10);
    System.out.println(Arrays.toString(arr2));

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-Java8新特性：强大的Stream-API"><a href="#5-Java8新特性：强大的Stream-API" class="headerlink" title="5. Java8新特性：强大的Stream API"></a>5. Java8新特性：强大的Stream API</h2><h3 id="5-1-说明"><a href="#5-1-说明" class="headerlink" title="5.1 说明"></a>5.1 说明</h3><ul>
<li>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</li>
<li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库<code>最好的补充</code>，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
<li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li>
</ul>
<h3 id="5-2-为什么要使用Stream-API"><a href="#5-2-为什么要使用Stream-API" class="headerlink" title="5.2 为什么要使用Stream API"></a>5.2 为什么要使用Stream API</h3><p>实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</p>
<h3 id="5-3-什么是Stream"><a href="#5-3-什么是Stream" class="headerlink" title="5.3 什么是Stream"></a>5.3 什么是Stream</h3><p>Stream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
<p>Stream 和 Collection 集合的区别：<strong>Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。</strong>前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
<p>注意：</p>
<p>①Stream 自己不会存储元素。</p>
<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。</p>
<p>④ Stream一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。</p>
<h3 id="5-4-Stream的操作三个步骤"><a href="#5-4-Stream的操作三个步骤" class="headerlink" title="5.4 Stream的操作三个步骤"></a>5.4 Stream的操作三个步骤</h3><p><strong>1- 创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p>
<p><strong>2- 中间操作</strong><br>每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个<code>操作链</code>，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</p>
<p><strong>3- 终止操作(终端操作)</strong><br>终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</p>
<img src="../images/image-20220514180803311.png" alt="image-20220514180803311" style="zoom: 50%;" />

<h4 id="5-4-1-创建Stream实例"><a href="#5-4-1-创建Stream实例" class="headerlink" title="5.4.1 创建Stream实例"></a>5.4.1 创建Stream实例</h4><p><strong>方式一：通过集合</strong></p>
<p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>
<ul>
<li><p>default Stream<E> stream() : 返回一个顺序流</p>
</li>
<li><p>default Stream<E> parallelStream() : 返回一个并行流</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test01()&#123;
    List&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5);

    &#x2F;&#x2F;JDK1.8中，Collection系列集合增加了方法
    Stream&lt;Integer&gt; stream &#x3D; list.stream();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>方式二：通过数组</strong></p>
<p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<ul>
<li>static <T> Stream<T> stream(T[] array): 返回一个流</li>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test02()&#123;
    String[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;&#125;;
    Stream&lt;String&gt; stream &#x3D; Arrays.stream(arr); 
&#125;

@Test
public void test03()&#123;
    int[] arr &#x3D; &#123;1,2,3,4,5&#125;;
    IntStream stream &#x3D; Arrays.stream(arr);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>方式三：通过Stream的of()</strong></p>
<p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p>
<ul>
<li>public static<T> Stream<T> of(T… values) : 返回一个流</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void test04()&#123;
    Stream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5);
    stream.forEach(System.out::println);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>方式四：创建无限流(了解)</strong></p>
<p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>
<ul>
<li><p>迭代<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) </p>
</li>
<li><p>生成<br>public static<T> Stream<T> generate(Supplier<T> s)</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 方式四：创建无限流
@Test
public void test05() &#123;
	&#x2F;&#x2F; 迭代
	&#x2F;&#x2F; public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final
	&#x2F;&#x2F; UnaryOperator&lt;T&gt; f)
	Stream&lt;Integer&gt; stream &#x3D; Stream.iterate(0, x -&gt; x + 2);
	stream.limit(10).forEach(System.out::println);

	&#x2F;&#x2F; 生成
	&#x2F;&#x2F; public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
	Stream&lt;Double&gt; stream1 &#x3D; Stream.generate(Math::random);
	stream1.limit(10).forEach(System.out::println);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-4-2-一系列中间操作"><a href="#5-4-2-一系列中间操作" class="headerlink" title="5.4.2 一系列中间操作"></a>5.4.2 一系列中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<p>1-筛选与切片</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>filter(Predicatep)</strong></td>
<td>接收  Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td><strong>distinct()</strong></td>
<td>筛选，通过流所生成元素的  hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td><strong>limit(long maxSize)</strong></td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td><strong>skip(long n)</strong></td>
<td>跳过元素，返回一个扔掉了前  n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<p>2-映 射</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>map(Function f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td><strong>mapToDouble(ToDoubleFunction f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td><strong>mapToInt(ToIntFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  IntStream。</td>
</tr>
<tr>
<td><strong>mapToLong(ToLongFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  LongStream。</td>
</tr>
<tr>
<td><strong>flatMap(Function  f)</strong></td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<p>3-排序</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>sorted()</strong></td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td><strong>sorted(Comparator</strong> <strong>com)</strong></td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<p>代码举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stream;

import org.junit.Test;

import java.util.Arrays;
import java.util.stream.Stream;

public class StreamMiddleOperate &#123;
	@Test
    public void test01()&#123;
        &#x2F;&#x2F;1、创建Stream
        Stream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5,6);

        &#x2F;&#x2F;2、加工处理
        &#x2F;&#x2F;过滤：filter(Predicate p)
        &#x2F;&#x2F;把里面的偶数拿出来
        &#x2F;*
         * filter(Predicate p)
         * Predicate是函数式接口，抽象方法：boolean test(T t)
         *&#x2F;
        stream &#x3D; stream.filter(t -&gt; t%2&#x3D;&#x3D;0);

        &#x2F;&#x2F;3、终结操作：例如：遍历
        stream.forEach(System.out::println);
    &#125;
    @Test
    public void test02()&#123;
        Stream.of(1,2,3,4,5,6)
                .filter(t -&gt; t%2&#x3D;&#x3D;0)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test03()&#123;
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .distinct()
                .forEach(System.out::println);
    &#125;
    @Test
    public void test04()&#123;
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .limit(3)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test05()&#123;
        Stream.of(1,2,2,3,3,4,4,5,2,3,4,5,6,7)
                .distinct()  &#x2F;&#x2F;(1,2,3,4,5,6,7)
                .filter(t -&gt; t%2!&#x3D;0) &#x2F;&#x2F;(1,3,5,7)
                .limit(3)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test06()&#123;
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .skip(5)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test07()&#123;
        Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .skip(5)
                .distinct()
                .filter(t -&gt; t%3&#x3D;&#x3D;0)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test08()&#123;
        long count &#x3D; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5)
                .distinct()
                .peek(System.out::println)  &#x2F;&#x2F;Consumer接口的抽象方法  void accept(T t)
                .count();
        System.out.println(&quot;count&#x3D;&quot;+count);
    &#125;
    @Test
    public void test09()&#123;
        &#x2F;&#x2F;希望能够找出前三个最大值，前三名最大的，不重复
        Stream.of(11,2,39,4,54,6,2,22,3,3,4,54,54)
                .distinct()
                .sorted((t1,t2) -&gt; -Integer.compare(t1, t2))&#x2F;&#x2F;Comparator接口  int compare(T t1, T t2)
                .limit(3)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test10()&#123;
        Stream.of(1,2,3,4,5)
                .map(t -&gt; t+&#x3D;1)&#x2F;&#x2F;Function&lt;T,R&gt;接口抽象方法 R apply(T t)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test11()&#123;
        String[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;

        Arrays.stream(arr)
                .map(t-&gt;t.toUpperCase())
                .forEach(System.out::println);
    &#125;
    @Test
    public void test12()&#123;
        String[] arr &#x3D; &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;
        Arrays.stream(arr)
                .flatMap(t -&gt; Stream.of(t.split(&quot;|&quot;)))&#x2F;&#x2F;Function&lt;T,R&gt;接口抽象方法 R apply(T t)  现在的R是一个Stream
                .forEach(System.out::println);
    &#125; 
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-4-3-终止操作"><a href="#5-4-3-终止操作" class="headerlink" title="5.4.3 终止操作"></a>5.4.3 终止操作</h4><ul>
<li><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p>
</li>
<li><p>流进行了终止操作后，不能再次使用。</p>
</li>
</ul>
<p>1-匹配与查找</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>allMatch(Predicate  p)</strong></td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>**anyMatch(Predicate  p)  **</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td><strong>noneMatch(Predicate</strong>  <strong>p)</strong></td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td><strong>findFirst()</strong></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><strong>findAny()</strong></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><strong>count()</strong></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><strong>max(Comparator c)</strong></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><strong>min(Comparator c)</strong></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><strong>forEach(Consumer c)</strong></td>
<td>内部迭代(使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>2-归约</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reduce(T  identity, BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回  T</td>
</tr>
<tr>
<td><strong>reduce(BinaryOperator  b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
</tbody></table>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<p>3-收集</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collect(Collector  c)</strong></td>
<td>将流转换为其他形式。接收一个  Collector接口的实现，<br>用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p>
<p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toList</strong></td>
<td>Collector&lt;T, ?, List<T>&gt;</td>
<td>把流中元素收集到List</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Employee&gt; emps&#x3D; list.stream().collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toSet</strong></td>
<td>Collector&lt;T, ?, Set<T>&gt;</td>
<td>把流中元素收集到Set</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Set&lt;Employee&gt; emps&#x3D; list.stream().collect(Collectors.toSet());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toCollection</strong></td>
<td>Collector&lt;T, ?, C&gt;</td>
<td>把流中元素收集到创建的集合</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection&lt;Employee&gt; emps &#x3D;list.stream().collect(Collectors.toCollection(ArrayList::new));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>counting</strong></td>
<td>Collector&lt;T, ?, Long&gt;</td>
<td>计算流中元素的个数</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">long count &#x3D; list.stream().collect(Collectors.counting());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>summingInt</strong></td>
<td>Collector&lt;T, ?, Integer&gt;</td>
<td>对流中元素的整数属性求和</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int total&#x3D;list.stream().collect(Collectors.summingInt(Employee::getSalary));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>averagingInt</strong></td>
<td>Collector&lt;T, ?, Double&gt;</td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">double avg &#x3D; list.stream().collect(Collectors.averagingInt(Employee::getSalary));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>summarizingInt</strong></td>
<td>Collector&lt;T, ?, IntSummaryStatistics&gt;</td>
<td>收集流中Integer属性的统计值。如：平均值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int SummaryStatisticsiss&#x3D; list.stream().collect(Collectors.summarizingInt(Employee::getSalary));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>joining</strong></td>
<td>Collector&lt;CharSequence, ?, String&gt;</td>
<td>连接流中每个字符串</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String str&#x3D; list.stream().map(Employee::getName).collect(Collectors.joining());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>maxBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最大值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional&lt;Emp&gt;max&#x3D; list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>minBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最小值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional&lt;Emp&gt; min &#x3D; list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reducing</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int total&#x3D;list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collectingAndThen</strong></td>
<td>Collector&lt;T,A,RR&gt;</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int how&#x3D; list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>groupingBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;K, List<T>&gt;&gt;</td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map&#x3D; list.stream().collect(Collectors.groupingBy(Employee::getStatus));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>partitioningBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;Boolean, List<T>&gt;&gt;</td>
<td>根据true或false进行分区</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd &#x3D; list.stream().collect(Collectors.partitioningBy(Employee::getManage));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stream;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.junit.Test;

public class StreamEndding &#123;
    @Test
    public void test01()&#123;
        Stream.of(1,2,3,4,5)
                .forEach(System.out::println);
    &#125;
    @Test
    public void test02()&#123;
        long count &#x3D; Stream.of(1,2,3,4,5)
                .count();
        System.out.println(&quot;count &#x3D; &quot; + count);
    &#125;
    @Test
    public void test03()&#123;
        boolean result &#x3D; Stream.of(1,3,5,7,9)
                .allMatch(t -&gt; t%2!&#x3D;0);
        System.out.println(result);
    &#125;
	@Test
    public void test04()&#123;
        boolean result &#x3D; Stream.of(1,3,5,7,9)
                .anyMatch(t -&gt; t%2&#x3D;&#x3D;0);
        System.out.println(result);
    &#125;
	@Test
    public void test05()&#123;
        Optional&lt;Integer&gt; opt &#x3D; Stream.of(1,3,5,7,9).findFirst();
        System.out.println(opt);
    &#125;
	@Test
    public void test06()&#123;
        Optional&lt;Integer&gt; opt &#x3D; Stream.of(1,2,3,4,5,7,9)
                .filter(t -&gt; t%3&#x3D;&#x3D;0)
                .findFirst();
        System.out.println(opt);
    &#125;
	@Test
    public void test07()&#123;
        Optional&lt;Integer&gt; opt &#x3D; Stream.of(1,2,4,5,7,8)
                .filter(t -&gt; t%3&#x3D;&#x3D;0)
                .findFirst();
        System.out.println(opt);
    &#125;
    @Test
    public void test08()&#123;
        Optional&lt;Integer&gt; max &#x3D; Stream.of(1,2,4,5,7,8)
                .max((t1,t2) -&gt; Integer.compare(t1, t2));
        System.out.println(max);
    &#125;
    @Test
    public void test09()&#123;
        Integer reduce &#x3D; Stream.of(1,2,4,5,7,8)
                .reduce(0, (t1,t2) -&gt; t1+t2);&#x2F;&#x2F;BinaryOperator接口   T apply(T t1, T t2)
        System.out.println(reduce);
    &#125;
    @Test
    public void test10()&#123;
        Optional&lt;Integer&gt; max &#x3D; Stream.of(1,2,4,5,7,8)
                .reduce((t1,t2) -&gt; t1&gt;t2?t1:t2);&#x2F;&#x2F;BinaryOperator接口   T apply(T t1, T t2)
        System.out.println(max);
    &#125;
    @Test
    public void test11()&#123;
        List&lt;Integer&gt; list &#x3D; Stream.of(1,2,4,5,7,8)
                .filter(t -&gt; t%2&#x3D;&#x3D;0)
                .collect(Collectors.toList());

        System.out.println(list);
    &#125;   
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-5-Java9新增API"><a href="#5-5-Java9新增API" class="headerlink" title="5.5 Java9新增API"></a>5.5 Java9新增API</h3><p><strong>新增1：Stream实例化方法</strong></p>
<p>ofNullable()的使用：</p>
<p>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;报NullPointerException
&#x2F;&#x2F;Stream&lt;Object&gt; stream1 &#x3D; Stream.of(null);
&#x2F;&#x2F;System.out.println(stream1.count());

&#x2F;&#x2F;不报异常，允许通过
Stream&lt;String&gt; stringStream &#x3D; Stream.of(&quot;AA&quot;, &quot;BB&quot;, null);
System.out.println(stringStream.count());&#x2F;&#x2F;3

&#x2F;&#x2F;不报异常，允许通过
List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
list.add(&quot;AA&quot;);
list.add(null);
System.out.println(list.stream().count());&#x2F;&#x2F;2
&#x2F;&#x2F;ofNullable()：允许值为null
Stream&lt;Object&gt; stream1 &#x3D; Stream.ofNullable(null);
System.out.println(stream1.count());&#x2F;&#x2F;0

Stream&lt;String&gt; stream &#x3D; Stream.ofNullable(&quot;hello world&quot;);
System.out.println(stream.count());&#x2F;&#x2F;1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>iterator()重载的使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;原来的控制终止方式：
Stream.iterate(1,i -&gt; i + 1).limit(10).forEach(System.out::println);

&#x2F;&#x2F;现在的终止方式：
Stream.iterate(1,i -&gt; i &lt; 100,i -&gt; i + 1).forEach(System.out::println);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-6-练习"><a href="#5-6-练习" class="headerlink" title="5.6 练习"></a>5.6 练习</h3><p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以<br>下若干操作步骤：</p>
<ol>
<li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li>
<li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li>
<li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li>
<li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li>
<li>将两个队伍合并为一个队伍；存储到一个新集合中。</li>
<li>根据姓名创建 Person 对象；存储到一个新集合中。</li>
<li>打印整个队伍的Person对象信息。</li>
</ol>
<p>Person 类的代码为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;
    private String name;
    public Person() &#123;&#125;
    public Person(String name) &#123;
        this.name &#x3D; name;
    &#125;    
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Person&#123;name&#x3D;&#39;&quot; + name + &quot;&#39;&#125;&quot;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>两个队伍（集合）的代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;
       &#x2F;&#x2F;第一支队伍
        ArrayList&lt;String&gt; one &#x3D; new ArrayList&lt;&gt;();
        one.add(&quot;迪丽热巴&quot;);
        one.add(&quot;宋远桥&quot;);
        one.add(&quot;苏星河&quot;);
        one.add(&quot;石破天&quot;);
        one.add(&quot;石中玉&quot;);
        one.add(&quot;老子&quot;);
        one.add(&quot;庄子&quot;);
        one.add(&quot;洪七公&quot;);
        &#x2F;&#x2F;第二支队伍
        ArrayList&lt;String&gt; two &#x3D; new ArrayList&lt;&gt;();
        two.add(&quot;古力娜扎&quot;);
        two.add(&quot;张无忌&quot;);
        two.add(&quot;赵丽颖&quot;);
        two.add(&quot;张三丰&quot;);
        two.add(&quot;尼古拉斯赵四&quot;);
        two.add(&quot;张天爱&quot;);
        two.add(&quot;张二狗&quot;);
    
		&#x2F;&#x2F; ....编写代码完成题目要求 
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>参考答案：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;
       &#x2F;&#x2F;第一支队伍
        ArrayList&lt;String&gt; one &#x3D; new ArrayList&lt;&gt;();
        one.add(&quot;迪丽热巴&quot;);
        one.add(&quot;宋远桥&quot;);
        one.add(&quot;苏星河&quot;);
        one.add(&quot;石破天&quot;);
        one.add(&quot;石中玉&quot;);
        one.add(&quot;老子&quot;);
        one.add(&quot;庄子&quot;);
        one.add(&quot;洪七公&quot;);
    
        &#x2F;&#x2F;第二支队伍
        ArrayList&lt;String&gt; two &#x3D; new ArrayList&lt;&gt;();
        two.add(&quot;古力娜扎&quot;);
        two.add(&quot;张无忌&quot;);
        two.add(&quot;赵丽颖&quot;);
        two.add(&quot;张三丰&quot;);
        two.add(&quot;尼古拉斯赵四&quot;);
        two.add(&quot;张天爱&quot;);
        two.add(&quot;张二狗&quot;);
        
		&#x2F;&#x2F; 第一个队伍只要名字为3个字的成员姓名；
        &#x2F;&#x2F; 第一个队伍筛选之后只要前3个人；
        Stream&lt;String&gt; streamOne &#x3D; one.stream().filter(s ‐&gt; s.length() &#x3D;&#x3D; 3).limit(3);
    
        &#x2F;&#x2F; 第二个队伍只要姓张的成员姓名；
        &#x2F;&#x2F; 第二个队伍筛选之后不要前2个人；
        Stream&lt;String&gt; streamTwo &#x3D; two.stream().filter(s ‐&gt; s.startsWith(&quot;张&quot;)).skip(2);
    
        &#x2F;&#x2F; 将两个队伍合并为一个队伍；
        &#x2F;&#x2F; 根据姓名创建Person对象；
        &#x2F;&#x2F; 打印整个队伍的Person对象信息。
        Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println);
        
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">dawncoody</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://dawncoody.github.io/2023/03/13/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/">https://dawncoody.github.io/2023/03/13/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">dawncoody</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2023/03/13/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="JDK新特性上">
                        
                        <span class="card-title">JDK新特性上</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/02/10/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="IDEA快捷键">
                        
                        <span class="card-title">IDEA快捷键</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-02-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/">
                        <span class="chip bg-color">快捷键</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">dawncoody</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
